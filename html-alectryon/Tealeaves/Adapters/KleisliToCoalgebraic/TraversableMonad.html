<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>TraversableMonad.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Kleisli.TraversableMonad
  Classes.Coalgebraic.TraversableMonad
  Functors.Early.Batch.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Functors.Early.Batch.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Kleisli.TraversableMonad.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span> U T M A B.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> batch {A} (B)%type_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> toBatch6 {T U}%function_scope {ToBatch6}
  {A} (B)%type_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** * Coalgebraic Traversable Monads *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Derived Operations *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DerivedOperations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ToBatch6_Bindt</span> `{Bindt T U}
: Coalgebraic.TraversableMonad.ToBatch6 T U :=
  (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> =&gt; bindt (G := Batch A (T B)) (batch (T B)):
     U A -&gt; Batch A (T B) (U B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DerivedOperations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Compat_ToBatch6_Bindt</span>
  (<span class="nv">T</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">U</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  `{Bindt_TU: Bindt T U}
  `{ToBatch6_TU: ToBatch6 T U} :=
  compat_toBatch6_bindt:
    ToBatch6_TU = DerivedOperations.ToBatch6_Bindt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk0"><span class="kn">Lemma</span> <span class="nf">toBatch6_to_bindt</span>
  `{Compat_ToBatch6_Bindt T U}:
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>, toBatch6 (T := T) (U := U) (A := A) B =
           bindt (G := Batch A (T B)) (batch (T B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Bindt_TU</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>ToBatch6_TU</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, toBatch6 B = bindt (batch (T B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Bindt_TU</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>ToBatch6_TU</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, toBatch6 B = bindt (batch (T B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Bindt_TU</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>ToBatch6_TU</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch6 B = bindt (batch (T B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk3"><span class="nb">rewrite</span> compat_toBatch6_bindt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T, U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Bindt_TU</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>ToBatch6_TU</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DerivedOperations.ToBatch6_Bindt A B =
bindt (batch (T B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Compat_ToBatch6_Bindt_Self</span>
  `{Bindt T U}: Compat_ToBatch6_Bindt T U
                  (ToBatch6_TU := DerivedOperations.ToBatch6_Bindt)
  := <span class="kp">ltac</span>:(<span class="nb">hnf</span>; <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DerivedInstances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">to_coalgebraic</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{Kleisli.TraversableMonad.TraversableMonad T}
      `{Map U}
      `{Bindt T U}
      `{! Compat_Map_Bindt T U}
      `{! Kleisli.TraversableMonad.TraversableRightPreModule T U}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{ToBatch6 T T}
      `{ToBatch6 T U}
      `{! Compat_ToBatch6_Bindt T U}
      `{! Compat_ToBatch6_Bindt T T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** &lt;&lt;double_batch6&gt;&gt; as &lt;&lt;batch ‚ãÜ6 batch&gt;&gt; *)</span>
    <span class="sd">(******************************************************************)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk4"><span class="kn">Lemma</span> <span class="nf">double_batch6_spec</span>: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>),
        double_batch6 (T := T) (A := A) =
          batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>,
double_batch6 = batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>,
double_batch6 = batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">double_batch6 = batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk7"><span class="nb">rewrite</span> compat_toBatch6_bindt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">double_batch6 = batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** ** Derived Laws *)</span>
    <span class="sd">(******************************************************************)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk8"><span class="kn">Lemma</span> <span class="nf">toBatch6_ret_Kleisli</span>: <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>,
        toBatch6 B ‚àò ret (T := T) (A := A) = batch (T B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, toBatch6 B ‚àò ret = batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, toBatch6 B ‚àò ret = batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chka"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch6 B ‚àò ret = batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chkb"><span class="nb">rewrite</span> toBatch6_to_bindt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt (batch (T B)) ‚àò ret = batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chkc"><span class="nb">rewrite</span> (ktm_bindt0 A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">batch (T B) = batch (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chkd"><span class="kn">Lemma</span> <span class="nf">toBatch6_extract_Kleisli</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
        extract_Batch ‚àò mapfst_Batch ret ‚àò toBatch6 A = @id (U A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
extract_Batch ‚àò mapfst_Batch ret ‚àò toBatch6 A = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
extract_Batch ‚àò mapfst_Batch ret ‚àò toBatch6 A = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chkf"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch ‚àò mapfst_Batch ret ‚àò toBatch6 A = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk10">reassociate -&gt; on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch ‚àò (mapfst_Batch ret ‚àò toBatch6 A) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk11"><span class="nb">rewrite</span> toBatch6_to_bindt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch
‚àò (mapfst_Batch ret ‚àò bindt (batch (T A))) = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk12"><span class="nb">rewrite</span> (ktm_morph
                 (G1 := Batch A (T A))
                 (G2 := Batch (T A) (T A))
                 (morphism := ApplicativeMorphism_mapfst_Batch
                                (ret (T := T) (A := A)))
                 A A
                 (batch (T A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch ‚àò bindt (mapfst_Batch ret ‚àò batch (T A)) =
id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk13"><span class="nb">rewrite</span> (ktm_morph
                 (G1 := Batch (T A) (T A))
                 (G2 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)
                 (morphism := ApplicativeMorphism_extract_Batch (T A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt
  (extract_Batch ‚àò (mapfst_Batch ret ‚àò batch (T A))) =
id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk14">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt (extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A)) =
id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk15"><span class="nb">assert</span> (<span class="nb">cut</span>: extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A)
                   = ret).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A) = ret</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablemonad-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A) =
ret</span></span></span><br></div><label class="goal-separator" for="traversablemonad-v-chk16"><hr></label><div class="goal-conclusion">bindt (extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A)) =
id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk17">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A) = ret</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk18">ext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A)) a =
ret a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk19"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract_Batch (mapfst_Batch ret (batch (T A) a)) =
ret a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk1a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A) =
ret</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt (extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A)) =
id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk1b"><span class="nb">rewrite</span> <span class="nb">cut</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A) =
ret</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk1c"><span class="nb">rewrite</span> ktm_bindt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cut</var><span class="hyp-type"><b>: </b><span>extract_Batch ‚àò mapfst_Batch ret ‚àò batch (T A) =
ret</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk1d"><span class="kn">Lemma</span> <span class="nf">toBatch6_duplicate_Kleisli</span>: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>),
        cojoin_Batch6 A B C (R := U C) ‚àò toBatch6 (T := T) C =
          map (F := Batch A (T B)) (toBatch6 C) ‚àò toBatch6 (U := U) B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>,
cojoin_Batch6 A B C ‚àò toBatch6 C =
map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>,
cojoin_Batch6 A B C ‚àò toBatch6 C =
map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk1f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cojoin_Batch6 A B C ‚àò toBatch6 C =
map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk20"><span class="nb">rewrite</span> toBatch6_to_bindt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cojoin_Batch6 A B C ‚àò bindt (batch (T C)) =
map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk21"><span class="nb">change</span> (Batch A (T B) (Batch B (T C) <span class="nl">?x</span>))
        <span class="kr">with</span> ((Batch A (T B) ‚àò Batch B (T C)) x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cojoin_Batch6 A B C ‚àò bindt (batch (T C)) =
map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk22"><span class="nb">erewrite</span> (ktm_morph (T := T)
                  (G1 := Batch A (T C))
                  (G2 := Batch A (T B) ‚àò Batch B (T C))
                  (morphism := ApplicativeMorphism_cojoin_Batch6 _ _ _)
                  (œï := @cojoin_Batch6 T _ A B C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt (cojoin_Batch6 A B C ‚àò batch (T C)) =
map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk23">unfold_compose_in_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt (cojoin_Batch6 A B C ‚àò batch (T C)) =
map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk24"><span class="nb">rewrite</span> (cojoin_Batch6_batch).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt double_batch6 = map (toBatch6 C) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk25"><span class="nb">rewrite</span> toBatch6_to_bindt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt double_batch6 =
map (bindt (batch (T C))) ‚àò toBatch6 B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk26"><span class="nb">rewrite</span> toBatch6_to_bindt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt double_batch6 =
map (bindt (batch (T C))) ‚àò bindt (batch (T B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk27"><span class="nb">rewrite</span> (ktm_bindt2 _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt double_batch6 =
bindt (batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablemonad-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablemonad-v-chk28"><span class="nb">rewrite</span> double_batch6_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Return_T</var><span class="hyp-type"><b>: </b><span>Return T</span></span></span><br><span><var>Bindt_TT</var><span class="hyp-type"><b>: </b><span>Bindt T T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableMonad T</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map U</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Bindt T U</span></span></span><br><span><var>Compat_Map_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Bindt T U</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableMonad.TraversableRightPreModule
  T U</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ToBatch6 T T</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>ToBatch6 T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T U</span></span></span><br><span><var>Compat_ToBatch6_Bindt1</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch6_Bindt T T</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bindt (batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B)) =
bindt (batch (T C) ‚ãÜ<span class="mi">6</span> batch (T B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">to_coalgebraic</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Typeclass Instances *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">instances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{Return T}
      `{Map T}
      `{Bindt T T}
      `{! Compat_Map_Bindt T T}
      `{! Kleisli.TraversableMonad.TraversableMonad T}
      `{Map U}
      `{Bindt T U}
      `{! Compat_Map_Bindt T U}
      `{! Kleisli.TraversableMonad.TraversableRightPreModule T U}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{ToBatch6 T T}
      `{ToBatch6 T U}
      `{! Compat_ToBatch6_Bindt T U}
      `{! Compat_ToBatch6_Bindt T T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span>:
      Coalgebraic.TraversableMonad.TraversableRightPreModule T T :=
      {| trfm_extract := toBatch6_extract_Kleisli;
         trfm_duplicate := toBatch6_duplicate_Kleisli;
      |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Coalgebraic_TraversableRightPreModule_of_Kleisli</span>:
      Coalgebraic.TraversableMonad.TraversableRightPreModule T U :=
      {| trfm_extract := toBatch6_extract_Kleisli;
         trfm_duplicate := toBatch6_duplicate_Kleisli;
      |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Coalgebraic_TraversableMonad_of_Kleisli</span>:
      Coalgebraic.TraversableMonad.TraversableMonad T :=
      {| trfm_ret := toBatch6_ret_Kleisli;
      |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Coalgebraic_TraversableRightModule_of_Kleisli</span>:
      Coalgebraic.TraversableMonad.TraversableRightModule T U :=
      {| trfmod_monad := _
      |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">instances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DerivedInstances</span>.</span></span></pre>
</div>
</div></body>
</html>
