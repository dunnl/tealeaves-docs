<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>TraversableFunctor.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Adapters.CategoricalToKleisli.TraversableFunctor
  Adapters.KleisliToCoalgebraic.TraversableFunctor
  Classes.Coalgebraic.TraversableFunctor
  Functors.Batch
  Functors.List
  Functors.VectorRefinement
  Theory.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Coalgebraic.TraversableFunctor (ToBatch, toBatch).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Subset.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ContainerFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ProductFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Kleisli.TraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Batch.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> VectorRefinement.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">F</span> T G A B C M œï.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> mapfst_Batch {B C A1 A2}%type_scope
  f%function_scope b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> mapsnd_Batch {A B1 B2 C}%type_scope
  f%function_scope b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">



<span class="sd">(** * Lifting relations over Traversable functors *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lift_relation</span> {<span class="nv">X</span>} {<span class="nv">A</span> <span class="nv">B</span>:<span class="kt">Type</span>} `{Traverse X}
  (R: A -&gt; B -&gt; <span class="kt">Prop</span>): X A -&gt; X B -&gt; <span class="kt">Prop</span> :=
  traverse (G := subset) R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk0"><span class="kn">Lemma</span> <span class="nf">lift_relation_rw</span> {<span class="nv">X</span>} {<span class="nv">A</span> <span class="nv">B</span>:<span class="kt">Type</span>} `{Traverse X}
  (R: A -&gt; B -&gt; <span class="kt">Prop</span>) t1 t2:
  lift_relation R t1 t2 = traverse (G := subset) R t1 t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>X A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>X B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t1 t2 = traverse R t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>X A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>X B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t1 t2 = traverse R t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">lifting_relations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Classes.Categorical.TraversableFunctor.TraversableFunctor T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> CategoricalToKleisli.TraversableFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> CategoricalToKleisli.TraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{ToSubset T}
    `{! Compat_ToSubset_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2"><span class="kn">Lemma</span> <span class="nf">relation_spec</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B),
      lift_relation R t u &lt;-&gt;
        (<span class="kr">exists</span> <span class="nv">b</span>: Vector (plength t) B,
            traverse (G := subset) R (trav_contents t) b /\
              trav_make t b = u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B),
lift_relation R t u &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
   traverse R (trav_contents t) b /\ trav_make t b = u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B),
lift_relation R t u &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
   traverse R (trav_contents t) b /\ trav_make t b = u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t u &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
   traverse R (trav_contents t) b /\ trav_make t b = u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5"><span class="nb">unfold</span> lift_relation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R t u &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
   traverse R (trav_contents t) b /\ trav_make t b = u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6"><span class="nb">rewrite</span> traverse_repr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚àò R) (trav_contents t))) u &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
   traverse R (trav_contents t) b /\ trav_make t b = u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7">compose near (trav_contents t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  ((forwards ‚àò traverse (mkBackwards ‚àò R))
     (trav_contents t)) u &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
   traverse R (trav_contents t) b /\ trav_make t b = u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8"><span class="nb">rewrite</span> (traverse_commutative (G := subset) (T := Vector (plength t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t) (traverse R (trav_contents t)) u &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
   traverse R (trav_contents t) b /\ trav_make t b = u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Minor, not helpful  *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9"><span class="kn">Lemma</span> <span class="nf">relation1</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B)
      (<span class="nv">Plen</span>: plength u = plength t),
      lift_relation R t u -&gt;
        trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Plen</span> : plength u = plength t),
lift_relation R t u -&gt;
trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Plen</span> : plength u = plength t),
lift_relation R t u -&gt;
trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb">introv Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc"><span class="nb">rewrite</span> relation_spec <span class="kr">in</span> Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
  traverse R (trav_contents t) b /\
  trav_make t b = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd"><span class="nb">destruct</span> Hrel <span class="kr">as</span> [trav_contents_u [Htrav Hmake]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke"><span class="nb">assert</span> (Hcontents: trav_contents u ~~ trav_contents_u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_contents u ~~ trav_contents_u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Hcontents</var><span class="hyp-type"><b>: </b><span>trav_contents u ~~ trav_contents_u</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkf"><hr></label><div class="goal-conclusion">trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_contents u ~~ trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11"><span class="nb">apply</span> trav_contents_unique <span class="kr">in</span> Hmake.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_contents_u ~~ trav_contents u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_contents u ~~ trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_contents_u ~~ trav_contents u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig trav_contents_u =
proj1_sig (trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Hcontents</var><span class="hyp-type"><b>: </b><span>trav_contents u ~~ trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14"><span class="nb">rewrite</span> &lt;- Hmake.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Hcontents</var><span class="hyp-type"><b>: </b><span>trav_contents u ~~ trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Plen <span class="kr">in</span> trav_contents u) =
trav_make t trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15"><span class="nb">apply</span> Vector_fun_sim_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Hcontents</var><span class="hyp-type"><b>: </b><span>trav_contents u ~~ trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Hcontents</var><span class="hyp-type"><b>: </b><span>trav_contents u ~~ trav_contents_u</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk16"><hr></label><div class="goal-conclusion">coerce Plen <span class="kr">in</span> trav_contents u ~~ trav_contents_u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Hcontents</var><span class="hyp-type"><b>: </b><span>trav_contents u ~~ trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Plen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Hcontents</var><span class="hyp-type"><b>: </b><span>trav_contents u ~~ trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce Plen <span class="kr">in</span> trav_contents u ~~ trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">vector_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk19"><span class="kn">Lemma</span> <span class="nf">relation2</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B)
      (<span class="nv">Hlen</span>: plength u = plength t),
      lift_relation R t u -&gt;
      traverse (G := subset) R
        (trav_contents t)
        (coerce Hlen <span class="kr">in</span> trav_contents u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hlen</span> : plength u = plength t),
lift_relation R t u -&gt;
traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hlen</span> : plength u = plength t),
lift_relation R t u -&gt;
traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1b">introv Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1c"><span class="nb">rewrite</span> relation_spec <span class="kr">in</span> Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
  traverse R (trav_contents t) b /\
  trav_make t b = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1d"><span class="nb">destruct</span> Hrel <span class="kr">as</span> [trav_contents_u [Hrel Hmake]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1e"><span class="nb">enough</span> (Heq: coerce Hlen <span class="kr">in</span> trav_contents u =
                             trav_contents_u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>coerce Hlen <span class="kr">in</span> trav_contents u = trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk1f"><hr></label><div class="goal-conclusion">coerce Hlen <span class="kr">in</span> trav_contents u = trav_contents_u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk20">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>coerce Hlen <span class="kr">in</span> trav_contents u = trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk21"><span class="nb">rewrite</span> Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>coerce Hlen <span class="kr">in</span> trav_contents u = trav_contents_u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t) trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk22">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce Hlen <span class="kr">in</span> trav_contents u = trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk23"><span class="nb">apply</span> Vector_sim_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce Hlen <span class="kr">in</span> trav_contents u ~~ trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk24">vector_sim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_contents u ~~ trav_contents_u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk25"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig trav_contents_u =
proj1_sig (trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk26"><span class="nb">apply</span> trav_contents_unique.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t trav_contents_u = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk27"><span class="kn">Lemma</span> <span class="nf">relation3</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B)
      (<span class="nv">Hlen</span>: plength u = plength t),
      trav_make (B := B) t ~!~ trav_make u -&gt;
      traverse (G := subset) R
        (trav_contents t)
        (coerce Hlen <span class="kr">in</span> trav_contents u) -&gt;
            lift_relation R t u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hlen</span> : plength u = plength t),
trav_make t ~!~ trav_make u -&gt;
traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u) -&gt;
lift_relation R t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hlen</span> : plength u = plength t),
trav_make t ~!~ trav_make u -&gt;
traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u) -&gt;
lift_relation R t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk29">introv Htrav.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u) -&gt;
lift_relation R t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2a"><span class="nb">rewrite</span> relation_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u) -&gt;
<span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
  traverse R (trav_contents t) b /\ trav_make t b = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2b"><span class="kr">exists</span> (<span class="nv">coerce</span> <span class="nv">Hlen</span> <span class="nv">in</span> <span class="nv">trav_contents</span> <span class="nv">u</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u) /\
trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2c"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk2d"><hr></label><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2e"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2f"><span class="nb">change</span> u <span class="kr">with</span> (id u) <span class="nb">at</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = id u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk30"><span class="nb">rewrite</span> id_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) =
trav_make u (trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk31"><span class="nb">apply</span> Vector_fun_sim_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk32"><hr></label><div class="goal-conclusion">coerce Hlen <span class="kr">in</span> trav_contents u ~~ trav_contents u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk33"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>trav_make t ~!~ trav_make u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce Hlen <span class="kr">in</span> trav_contents u ~~ trav_contents u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">vector_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk34"><span class="kn">Lemma</span> <span class="nf">relation4</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B),
      lift_relation R t u -&gt;
      (<span class="kr">forall</span> <span class="nv">C</span>, trav_make (B := C) t ~!~ trav_make u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B),
lift_relation R t u -&gt;
<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B),
lift_relation R t u -&gt;
<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk36">introv Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk37"><span class="nb">intro</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk38"><span class="nb">rewrite</span> relation_spec <span class="kr">in</span> Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
  traverse R (trav_contents t) b /\
  trav_make t b = u</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk39"><span class="nb">destruct</span> Hrel <span class="kr">as</span> [trav_contents_u [Htrav Hmake]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3a"><span class="nb">eapply</span> trav_make_unique.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>trav_contents_u</var><span class="hyp-type"><b>: </b><span>Vector (plength t) B</span></span></span><br><span><var>Htrav</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t) trav_contents_u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span>trav_make t trav_contents_u = u</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t <span class="nl">?v</span> = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Related terms have the same shape *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3b"><span class="kn">Lemma</span> <span class="nf">relation_implies_shape</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B),
      lift_relation R t u -&gt; shape t = shape u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B), lift_relation R t u -&gt; shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B), lift_relation R t u -&gt; shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3d">introv Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3e"><span class="nb">apply</span> trav_same_shape_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B0</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3f"><span class="nb">eapply</span> relation4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation <span class="nl">?R</span> t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Related terms have a related zip *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk40"><span class="kn">Lemma</span> <span class="nf">Monoid_op_Opposite_and</span>:
    Monoid_op_Opposite Monoid_op_and = <span class="kn">and</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid_op_Opposite Monoid_op_and = <span class="kn">and</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Monoid_op_Opposite Monoid_op_and = <span class="kn">and</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">ext P1 P2; propext; <span class="nb">cbv</span>; <span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Hshape is trying to use Derived.Map_Traverse</span>
<span class="c">     so pass (H := H) to ensure the right Map F is chosen *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk42"><span class="kn">Lemma</span> <span class="nf">relation_to_zipped</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B)
      (<span class="nv">Hshape</span>: shape (H := H) t = shape u),
      lift_relation R t u -&gt;
      Forall (uncurry R)
        (same_shape_zip t u Hshape).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hshape</span> : shape t = shape u),
lift_relation R t u -&gt;
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hshape</span> : shape t = shape u),
lift_relation R t u -&gt;
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk44"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk45"><span class="nb">unfold</span> Forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk46"><span class="nb">unfold</span> same_shape_zip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (trav_make t (same_shape_zip_contents t u Hshape))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk47"><span class="nb">rewrite</span> foldMap_trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (same_shape_zip_contents t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk48"><span class="nb">rewrite</span> Monoid_op_Opposite_and.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (same_shape_zip_contents t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk49"><span class="nb">unfold</span> same_shape_zip_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (Vector_zip A B (plength t) (plength u)
     (trav_contents t) (trav_contents u)
     (same_shape_implies_plength t u Hshape))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4a"><span class="nb">unfold</span> Vector_zip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (Vector_zip_eq (trav_contents t)
     (coerce eq_sym
               (same_shape_implies_plength t u Hshape)
      <span class="kr">in</span> trav_contents u))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4b"><span class="nb">rewrite</span> &lt;- (traverse_zipped_vector
                 (R := R) (plength t) (trav_contents t)
                 (coerce eq_sym (same_shape_implies_plength t u Hshape)
                   <span class="kr">in</span> trav_contents u)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u Hshape)
   <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4c"><span class="nb">pose</span> relation2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br><span><var>t0</var><span><span class="hyp-body"><b>:= </b><span>relation2</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">t</span> : T A) (<span class="nv">u</span> : T B)
  (<span class="nv">Hlen</span> : plength u = plength t),
lift_relation R t u -&gt;
traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u Hshape)
   <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4d"><span class="nb">apply</span> t0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br><span><var>t0</var><span><span class="hyp-body"><b>:= </b><span>relation2</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) 
  (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">t</span> : T A) (<span class="nv">u</span> : T B)
  (<span class="nv">Hlen</span> : plength u = plength t),
lift_relation R t u -&gt;
traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4e"><span class="kn">Lemma</span> <span class="nf">foldMap_same_shape_zip</span> `{Monoid M}:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A * B -&gt; M) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B)
      (<span class="nv">Hshape</span>: shape (H := H) t = shape u),
      foldMap (T := T) f (same_shape_zip t u Hshape) =
        foldMap (op := Monoid_op_Opposite op) (T := Vector (plength t))
          f (same_shape_zip_contents t u Hshape).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A * B -&gt; M) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hshape</span> : shape t = shape u),
foldMap f (same_shape_zip t u Hshape) =
foldMap f (same_shape_zip_contents t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A * B -&gt; M) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hshape</span> : shape t = shape u),
foldMap f (same_shape_zip t u Hshape) =
foldMap f (same_shape_zip_contents t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk50"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A * B -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f (same_shape_zip t u Hshape) =
foldMap f (same_shape_zip_contents t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk51"><span class="nb">unfold</span> same_shape_zip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A * B -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f
  (trav_make t (same_shape_zip_contents t u Hshape)) =
foldMap f (same_shape_zip_contents t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk52"><span class="nb">rewrite</span> foldMap_trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A * B -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f (same_shape_zip_contents t u Hshape) =
foldMap f (same_shape_zip_contents t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk53"><span class="kn">Lemma</span> <span class="nf">relation_to_zipped_iff</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B)
      (<span class="nv">Hshape</span>: shape (H :=H) t = shape u),
      lift_relation R t u &lt;-&gt;
        (<span class="kr">forall</span> <span class="nv">C</span>, trav_make (B := C) t ~!~ trav_make u) /\
          Forall (uncurry R)
            (same_shape_zip t u Hshape).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hshape</span> : shape t = shape u),
lift_relation R t u &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; B -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A)
  (<span class="nv">u</span> : T B) (<span class="nv">Hshape</span> : shape t = shape u),
lift_relation R t u &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk55"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t u &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk56"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t u -&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk57"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape) -&gt;
lift_relation R t u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t u -&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk59">introv Hrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5a"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk5b"><hr></label><div class="goal-conclusion">Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5d"><span class="nb">eapply</span> relation4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation <span class="nl">?R</span> t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R) (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5f"><span class="nb">apply</span> relation_to_zipped.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hrel</var><span class="hyp-type"><b>: </b><span>lift_relation R t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry R) (same_shape_zip t u Hshape) -&gt;
lift_relation R t u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk61"><span class="nb">intros</span> [Hmake Hzip].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk62"><span class="nb">rewrite</span> relation_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
  traverse R (trav_contents t) b /\ trav_make t b = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk63"><span class="nb">assert</span> (Hlen: plength u = plength t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength u = plength t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk64"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
  traverse R (trav_contents t) b /\ trav_make t b = u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk65">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength u = plength t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk66"><span class="nb">apply</span> same_shape_implies_plength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape u = shape t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk67"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk68">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">b</span> : Vector (plength t) B,
  traverse R (trav_contents t) b /\ trav_make t b = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk69"><span class="kr">exists</span> (<span class="nv">coerce</span> <span class="nv">Hlen</span> <span class="nv">in</span> <span class="nv">trav_contents</span> <span class="nv">u</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u) /\
trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6a"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk6b"><hr></label><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6d"><span class="nb">unfold</span> same_shape_zip <span class="kr">in</span> Hzip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R)
  (trav_make t
     (same_shape_zip_contents t u Hshape))</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6e"><span class="nb">unfold</span> same_shape_zip_contents <span class="kr">in</span> Hzip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R)
  (trav_make t
     (Vector_zip A B 
        (plength t) 
        (plength u) 
        (trav_contents t) 
        (trav_contents u)
        (same_shape_implies_plength t u Hshape)))</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6f"><span class="nb">unfold</span> Vector_zip <span class="kr">in</span> Hzip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R)
  (trav_make t
     (Vector_zip_eq 
        (trav_contents t)
        (coerce 
         eq_sym
           (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
         trav_contents u)))</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk70"><span class="nb">unfold</span> Forall <span class="kr">in</span> Hzip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>foldMap (uncurry R)
  (trav_make t
     (Vector_zip_eq 
        (trav_contents t)
        (coerce 
         eq_sym
           (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
         trav_contents u)))</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk71"><span class="nb">rewrite</span> foldMap_trav_make <span class="kr">in</span> Hzip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>foldMap (uncurry R)
  (Vector_zip_eq 
     (trav_contents t)
     (coerce eq_sym
             (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
      trav_contents u))</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk72"><span class="nb">rewrite</span> Monoid_op_Opposite_and <span class="kr">in</span> Hzip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>foldMap (uncurry R)
  (Vector_zip_eq 
     (trav_contents t)
     (coerce eq_sym
             (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
      trav_contents u))</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk73"><span class="nb">rewrite</span> &lt;- (traverse_zipped_vector
                     (R := R) (plength t) (trav_contents t)
                     (coerce eq_sym (same_shape_implies_plength t u Hshape)
                       <span class="kr">in</span> trav_contents u)) <span class="kr">in</span> Hzip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
   trav_contents u)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk74"><span class="nb">enough</span> (Hcoerce: (coerce eq_sym (same_shape_implies_plength t u Hshape)
                   <span class="kr">in</span> trav_contents u) =
                  coerce Hlen <span class="kr">in</span> trav_contents u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
   trav_contents u)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Hcoerce</var><span class="hyp-type"><b>: </b><span>coerce eq_sym
         (same_shape_implies_plength t u
            Hshape) <span class="kr">in</span> 
trav_contents u =
coerce Hlen <span class="kr">in</span> trav_contents u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce Hlen <span class="kr">in</span> trav_contents u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
   trav_contents u)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk75"><hr></label><div class="goal-conclusion">coerce eq_sym (same_shape_implies_plength t u Hshape)
<span class="kr">in</span> trav_contents u = 
coerce Hlen <span class="kr">in</span> trav_contents u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk76"><span class="nb">rewrite</span> &lt;- Hcoerce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
   trav_contents u)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br><span><var>Hcoerce</var><span class="hyp-type"><b>: </b><span>coerce eq_sym
         (same_shape_implies_plength t u
            Hshape) <span class="kr">in</span> 
trav_contents u =
coerce Hlen <span class="kr">in</span> trav_contents u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u Hshape)
   <span class="kr">in</span> trav_contents u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
   trav_contents u)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk77"><hr></label><div class="goal-conclusion">coerce eq_sym (same_shape_implies_plength t u Hshape)
<span class="kr">in</span> trav_contents u = 
coerce Hlen <span class="kr">in</span> trav_contents u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk78"><span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
   trav_contents u)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce eq_sym (same_shape_implies_plength t u Hshape)
<span class="kr">in</span> trav_contents u = coerce Hlen <span class="kr">in</span> trav_contents u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk79"><span class="nb">apply</span> Vector_sim_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>traverse R (trav_contents t)
  (coerce eq_sym
            (same_shape_implies_plength t u
             Hshape) <span class="kr">in</span> 
   trav_contents u)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce eq_sym (same_shape_implies_plength t u Hshape)
<span class="kr">in</span> trav_contents u ~~ coerce Hlen <span class="kr">in</span> trav_contents u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">vector_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7b"><span class="nb">change</span> u <span class="kr">with</span> (id u) <span class="nb">at</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) = id u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7c"><span class="nb">rewrite</span> id_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t (coerce Hlen <span class="kr">in</span> trav_contents u) =
trav_make u (trav_contents u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7d"><span class="nb">apply</span> Vector_fun_sim_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk7e"><hr></label><div class="goal-conclusion">coerce Hlen <span class="kr">in</span> trav_contents u ~~ trav_contents u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hmake.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk80">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hmake</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>Hzip</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t u Hshape)</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span>plength u = plength t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">coerce Hlen <span class="kr">in</span> trav_contents u ~~ trav_contents u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">vector_sim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk81"><span class="kn">Lemma</span> <span class="nf">relation_natural1</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B1</span> <span class="nv">B2</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: B1 -&gt; B2 -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">f</span>: A -&gt; B1),
      lift_relation R (map f t) = lift_relation (R ‚àò map f) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B1</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; B1),
lift_relation R (map f t) =
lift_relation (R ‚àò map f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B1</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; B1),
lift_relation R (map f t) =
lift_relation (R ‚àò map f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk83"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R (map f t) =
lift_relation (R ‚àò map f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk84"><span class="nb">unfold</span> lift_relation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R (map f t) = traverse (R ‚àò map f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk85">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse R ‚àò map f) t = traverse (R ‚àò map f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk86"><span class="nb">rewrite</span> (traverse_map (G2 := subset) R f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (R ‚àò f) t = traverse (R ‚àò map f) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk87"><span class="kn">Lemma</span> <span class="nf">relation_natural2_lemma</span>:
    <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: B1 -&gt; B2 -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T B1) (<span class="nv">u</span>: T A) (<span class="nv">f</span>: A -&gt; B2)
      (<span class="nv">Hshape</span>: shape (H := H) t = shape (map f u))
      (<span class="nv">Hshape&#39;</span>: shape (H := H)  t = shape u),
      Forall (uncurry R) (same_shape_zip t (map f u) Hshape) =
        Forall (uncurry (precompose f ‚àò R)) (same_shape_zip t u Hshape&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T B1) (<span class="nv">u</span> : T A) (<span class="nv">f</span> : A -&gt; B2)
  (<span class="nv">Hshape</span> : shape t = shape (map f u))
  (<span class="nv">Hshape&#39;</span> : shape t = shape u),
Forall (uncurry R) (same_shape_zip t (map f u) Hshape) =
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T B1) (<span class="nv">u</span> : T A) (<span class="nv">f</span> : A -&gt; B2)
  (<span class="nv">Hshape</span> : shape t = shape (map f u))
  (<span class="nv">Hshape&#39;</span> : shape t = shape u),
Forall (uncurry R) (same_shape_zip t (map f u) Hshape) =
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk89"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R) (same_shape_zip t (map f u) Hshape) =
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8a"><span class="nb">unfold</span> Forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (same_shape_zip t (map f u) Hshape) =
foldMap (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8b"><span class="nb">rewrite</span> foldMap_same_shape_zip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (same_shape_zip_contents t (map f u) Hshape) =
foldMap (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8c"><span class="nb">rewrite</span> foldMap_same_shape_zip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (same_shape_zip_contents t (map f u) Hshape) =
foldMap (uncurry (precompose f ‚àò R))
  (same_shape_zip_contents t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8d"><span class="nb">rewrite</span> natural_snd_same_shape_zip_contents_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (map (map_snd f)
     (same_shape_zip_contents t u
        (same_shape_map_rev_r t u f Hshape))) =
foldMap (uncurry (precompose f ‚àò R))
  (same_shape_zip_contents t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8e">compose near (same_shape_zip_contents t u (same_shape_map_rev_r t u f Hshape)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap (uncurry R) ‚àò map (map_snd f))
  (same_shape_zip_contents t u
     (same_shape_map_rev_r t u f Hshape)) =
foldMap (uncurry (precompose f ‚àò R))
  (same_shape_zip_contents t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8f"><span class="nb">rewrite</span> (foldMap_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R ‚àò map_snd f)
  (same_shape_zip_contents t u
     (same_shape_map_rev_r t u f Hshape)) =
foldMap (uncurry (precompose f ‚àò R))
  (same_shape_zip_contents t u Hshape&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk90">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">uncurry R ‚àò map_snd f = uncurry (precompose f ‚àò R)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk91"><hr></label><div class="goal-conclusion">same_shape_zip_contents t u
  (same_shape_map_rev_r t u f Hshape) =
same_shape_zip_contents t u Hshape&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk92">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">uncurry R ‚àò map_snd f = uncurry (precompose f ‚àò R)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk93">ext [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(uncurry R ‚àò map_snd f) (x, y) =
uncurry (precompose f ‚àò R) (x, y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk94">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">same_shape_zip_contents t u
  (same_shape_map_rev_r t u f Hshape) =
same_shape_zip_contents t u Hshape&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> same_shape_zip_contents_proof_irrelevance.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk95"><span class="kn">Lemma</span> <span class="nf">relation_natural2_core</span>:
    <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: B1 -&gt; B2 -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T B1) (<span class="nv">u</span>: T A) (<span class="nv">f</span>: A -&gt; B2),
      shape t = shape u -&gt;
      lift_relation R t (map f u) = lift_relation (precompose f ‚àò R) t u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T B1) (<span class="nv">u</span> : T A) (<span class="nv">f</span> : A -&gt; B2),
shape t = shape u -&gt;
lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T B1) (<span class="nv">u</span> : T A) (<span class="nv">f</span> : A -&gt; B2),
shape t = shape u -&gt;
lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk97">introv Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk98"><span class="nb">assert</span> (Hshape&#39;: shape t = shape (map f u)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape (map f u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk99"><hr></label><div class="goal-conclusion">lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape (map f u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9b"><span class="nb">rewrite</span> shape_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9d"><span class="nb">apply</span> propositional_extensionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u) &lt;-&gt;
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9e"><span class="nb">rewrite</span> (relation_to_zipped_iff _ _ R t (map f u) Hshape&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry R)
  (same_shape_zip t (map f u) Hshape&#39;) &lt;-&gt;
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9f"><span class="nb">rewrite</span> (relation_to_zipped_iff _ _ (precompose f ‚àò R) t u Hshape).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry R)
  (same_shape_zip t (map f u) Hshape&#39;) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka0"><span class="nb">erewrite</span> relation_natural2_lemma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka1"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>) -&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chka2"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape) -&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>) -&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka4"><span class="nb">intros</span> [X1 X2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
trav_make t ~!~ trav_make (map f u)</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka5"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
trav_make t ~!~ trav_make (map f u)</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
trav_make t ~!~ trav_make (map f u)</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chka6"><hr></label><div class="goal-conclusion">Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
trav_make t ~!~ trav_make (map f u)</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
trav_make t ~!~ trav_make (map f u)</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trav_make t ~!~ trav_make u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka9"><span class="nb">apply</span> trav_same_shape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
trav_make t ~!~ trav_make (map f u)</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkaa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
trav_make t ~!~ trav_make (map f u)</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u <span class="nl">?Hshape&#39;</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkab">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape) -&gt;
(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkac"><span class="nb">intros</span> [X1 X2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)) /\
Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkad"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkae"><hr></label><div class="goal-conclusion">Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkaf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make (map f u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb0"><span class="nb">apply</span> trav_same_shape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape (map f u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br><span><var>Hshape'</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make u</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry (precompose f ‚àò R))
  (same_shape_zip t u Hshape)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb2"><span class="kn">Lemma</span> <span class="nf">relation_natural2</span>:
    <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: B1 -&gt; B2 -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T B1) (<span class="nv">u</span>: T A) (<span class="nv">f</span>: A -&gt; B2),
      lift_relation R t (map f u) = lift_relation (precompose f ‚àò R) t u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T B1) (<span class="nv">u</span> : T A) (<span class="nv">f</span> : A -&gt; B2),
lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T B1) (<span class="nv">u</span> : T A) (<span class="nv">f</span> : A -&gt; B2),
lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u) =
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb5"><span class="nb">apply</span> propositional_extensionality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u) &lt;-&gt;
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb6"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u) -&gt;
lift_relation (precompose f ‚àò R) t u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkb7"><hr></label><div class="goal-conclusion">lift_relation (precompose f ‚àò R) t u -&gt;
lift_relation R t (map f u)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u) -&gt;
lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb9">introv hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>lift_relation R t (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation (precompose f ‚àò R) t u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkba"><span class="nb">rewrite</span> &lt;- relation_natural2_core; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>lift_relation R t (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbb"><span class="nb">apply</span> relation_implies_shape <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>shape t = shape (map f u)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbc"><span class="nb">rewrite</span> shape_map <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation (precompose f ‚àò R) t u -&gt;
lift_relation R t (map f u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbe">introv hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>lift_relation (precompose f ‚àò R) t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t (map f u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbf"><span class="nb">rewrite</span> relation_natural2_core; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>lift_relation (precompose f ‚àò R) t u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc0"><span class="nb">apply</span> relation_implies_shape <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>B1, A, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T B1</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shape t = shape u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* TODO This can actually be strengthed into an IFF *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc1"><span class="kn">Lemma</span> <span class="nf">relation_respectful</span>:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B1</span> <span class="nv">B2</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: B1 -&gt; B2 -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A) (<span class="nv">f</span>: A -&gt; B1) (<span class="nv">g</span>: A -&gt; B2),
    (<span class="kr">forall</span> (<span class="nv">a</span>: A), a ‚àà t -&gt; R (f a) (g a)) -&gt; lift_relation R (map f t) (map g t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B1</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; B1) (<span class="nv">g</span> : A -&gt; B2),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)) -&gt;
lift_relation R (map f t) (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B1</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : B1 -&gt; B2 -&gt; <span class="kt">Prop</span>)
  (<span class="nv">t</span> : T A) (<span class="nv">f</span> : A -&gt; B1) (<span class="nv">g</span> : A -&gt; B2),
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)) -&gt;
lift_relation R (map f t) (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc3">introv hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R (map f t) (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc4"><span class="nb">rewrite</span> relation_natural1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation (R ‚àò map f) t (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc5"><span class="nb">rewrite</span> relation_natural2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation (precompose g ‚àò (R ‚àò map f)) t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc6"><span class="nb">unfold</span> lift_relation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (precompose g ‚àò (R ‚àò map f)) t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc7"><span class="nb">rewrite</span> traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch (precompose g ‚àò (R ‚àò map f)) ‚àò toBatch) t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc8"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (toBatch t) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc9"><span class="nb">unfold</span> element_of <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, tosubset t a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (toBatch t) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkca"><span class="nb">rewrite</span> tosubset_to_foldMap <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret t a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (toBatch t) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcb"><span class="nb">change</span> t <span class="kr">with</span> (id t) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret t a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (toBatch t) (id t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcc"><span class="nb">rewrite</span> id_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret t a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (toBatch t) ((runBatch id ‚àò toBatch) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcd"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret t a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (toBatch t) (runBatch id (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkce"><span class="nb">rewrite</span> (foldMap_through_toBatch A A) <span class="kr">in</span> hyp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (toBatch t) (runBatch id (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* induction (@toBatch T ToBatch_inst A A t). *)</span> <span class="c">(* Generates a weird hypothesis *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcf"><span class="nb">apply</span> (Batch_ind A A
      (<span class="kr">fun</span> (<span class="nv">C</span>: <span class="kt">Type</span>) (<span class="nv">b</span>: Batch A A C) =&gt;
           (<span class="kr">forall</span> <span class="nv">a</span>: A, foldMap (T := BATCH1 A C) (ret (T := subset)) b a -&gt; R (f a) (g a)) -&gt;
           runBatch (G := subset) (<span class="kr">fun</span> <span class="nv">a</span>: A =&gt; precompose g (R (map f a))) b (runBatch id b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">c</span> : C),
(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret (Done c) a -&gt; R (f a) (g a)) -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (Done c) (runBatch id (Done c))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkd0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkd0"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A A (A -&gt; C)),
((<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
 runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
   (runBatch id b)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">forall</span> <span class="nv">a0</span> : A,
 foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)) -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; precompose g (R (map f a0)))
  (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkd1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkd1"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">c</span> : C),
(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret (Done c) a -&gt; R (f a) (g a)) -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (Done c) (runBatch id (Done c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd3"><span class="nb">intros</span> C c hyp&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (Done c) a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (Done c) (runBatch id (Done c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A A (A -&gt; C)),
((<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
 runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
   (runBatch id b)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">forall</span> <span class="nv">a0</span> : A,
 foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)) -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; precompose g (R (map f a0)))
  (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd5">introv IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">forall</span> <span class="nv">a0</span> : A,
 foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)) -&gt;
runBatch (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; precompose g (R (map f a0)))
  (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd6">introv hyp&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a)))
  (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd7"><span class="nb">rewrite</span> runBatch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b &lt;‚ãÜ&gt;
 precompose g (R (map f a))) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd8"><span class="nb">rewrite</span> runBatch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b &lt;‚ãÜ&gt;
 precompose g (R (map f a))) (runBatch id b &lt;‚ãÜ&gt; id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd9"><span class="nb">rewrite</span> subset_ap_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">f0</span> : A -&gt; C) (<span class="nv">a0</span> : A),
  precompose g (R (map f a)) a0 /\
  runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
    f0 /\ f0 a0 = runBatch id b &lt;‚ãÜ&gt; id a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkda"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">f0</span> : A -&gt; C) (<span class="nv">a0</span> : A),
  precompose g (R (map f a)) a0 /\
  runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
    f0 /\
  f0 a0 =
  map (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) (runBatch id b ‚äó id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdb">unfold_ops @Map_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">f0</span> : A -&gt; C) (<span class="nv">a0</span> : A),
  precompose g (R (f a)) a0 /\
  runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (f a))) b f0 /\
  f0 a0 = (<span class="kr">let</span> &#39;(f, a) := runBatch id b ‚äó id a <span class="kr">in</span> f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdc">unfold_ops @Mult_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">f0</span> : A -&gt; C) (<span class="nv">a0</span> : A),
  precompose g (R (f a)) a0 /\
  runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (f a))) b f0 /\
  f0 a0 = runBatch id b (id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdd"><span class="kr">exists</span> (<span class="nv">runBatch</span> <span class="nv">id</span> <span class="nv">b</span>) <span class="nv">a</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precompose g (R (f a)) a /\
runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (f a))) b
  (runBatch id b) /\
runBatch id b a = runBatch id b (id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkde">splits.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precompose g (R (f a)) a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkdf"><hr></label><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (f a))) b
  (runBatch id b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chke0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chke0"><hr></label><div class="goal-conclusion">runBatch id b a = runBatch id b (id a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">precompose g (R (f a)) a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke2"><span class="nb">unfold</span> precompose, compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (f a) (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke3">unfold_ops @Map_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (f a) (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke4"><span class="nb">apply</span> hyp&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret (b ‚ßÜ a) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">right</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (f a))) b
  (runBatch id b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chke6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chke6"><hr></label><div class="goal-conclusion">runBatch id b a = runBatch id b (id a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (f a))) b
  (runBatch id b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke8"><span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>foldMap ret b a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (f a0) (g a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkea"><span class="nb">apply</span> hyp&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>foldMap ret b a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret (b ‚ßÜ a) a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkeb"><span class="nb">rewrite</span> foldMap_Batch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>foldMap ret b a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap ret b ‚óè ret a) a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkec">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch id b a = runBatch id b (id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chked">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">a</span> : A, foldMap ret b a -&gt; R (f a) (g a)) -&gt;
runBatch
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; precompose g (R (map f a))) b
  (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a0</span> : A,
foldMap ret (b ‚ßÜ a) a0 -&gt; R (f a0) (g a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch id b a = runBatch id b (id a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkee">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2 -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; B2</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
foldMap ret (toBatch t) a -&gt; R (f a) (g a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">lifting_relations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** * Properties of Relations *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">relprop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">relprop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Diagonal *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">relprop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Classes.Categorical.TraversableFunctor.TraversableFunctor T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> CategoricalToKleisli.TraversableFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> CategoricalToKleisli.TraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkef"><span class="kn">Lemma</span> <span class="nf">relation_diagonal1</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A),
      Forall (<span class="kr">fun</span> (<span class="nv">a</span>: A) =&gt; R a a) t -&gt; lift_relation R t t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t -&gt; lift_relation R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t -&gt; lift_relation R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf1">introv HF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf2"><span class="nb">unfold</span> Forall <span class="kr">in</span> HF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf3"><span class="nb">rewrite</span> (foldMap_to_traverse2 A) <span class="kr">in</span> HF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>traverse (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf4"><span class="nb">unfold</span> lift_relation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>traverse (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf5"><span class="nb">rewrite</span> traverse_through_runBatch <span class="kr">in</span> HF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) ‚àò toBatch) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf6"><span class="nb">rewrite</span> traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) ‚àò toBatch) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch R ‚àò toBatch) t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf7"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) ‚àò toBatch) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (toBatch t) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf8"><span class="nb">change</span> t <span class="kr">with</span> (id t) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) ‚àò toBatch) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (toBatch t) (id t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf9"><span class="nb">rewrite</span> (id_through_runBatch).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) ‚àò toBatch) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (toBatch t) ((runBatch id ‚àò toBatch) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfa"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) ‚àò toBatch) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (toBatch t) (runBatch id (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfb"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span> <span class="kr">in</span> HF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>HF</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (toBatch t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (toBatch t) (runBatch id (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfc"><span class="nb">generalize dependent</span> HF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (toBatch t) -&gt;
runBatch R (toBatch t) (runBatch id (toBatch t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfd"><span class="nb">apply</span> (Batch_ind A A
             (<span class="kr">fun</span> <span class="nv">C</span> (<span class="nv">b</span>: Batch A A C) =&gt;
                runBatch (G := const <span class="kt">Prop</span>) (<span class="kr">fun</span> <span class="nv">a</span>: A =&gt; R a a) b -&gt;
                runBatch (G := subset) R b (runBatch id b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">c</span> : C),
runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (Done c) -&gt;
runBatch R (Done c) (runBatch id (Done c))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkfe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkfe"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A A (A -&gt; C)),
(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
 runBatch R b (runBatch id b)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A,
runBatch (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; R a0 a0) (b ‚ßÜ a) -&gt;
runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkff">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">c</span> : C),
runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (Done c) -&gt;
runBatch R (Done c) (runBatch id (Done c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk100"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">c</span> : C), <span class="kt">True</span> -&gt; c = c</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk101">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : Batch A A (A -&gt; C)),
(runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
 runBatch R b (runBatch id b)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A,
runBatch (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; R a0 a0) (b ‚ßÜ a) -&gt;
runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk102">introv X1 X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (b ‚ßÜ a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk103"><span class="nb">rewrite</span> runBatch_rw2 <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b &lt;‚ãÜ&gt; R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk104"><span class="nb">unfold</span> ap <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>map (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b ‚äó R a a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk105"><span class="nb">unfold</span> map <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Map_const ((A -&gt; C) * A) C (<span class="kr">fun</span> &#39;(f, a) =&gt; f a)
  (runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b ‚äó R a a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk106"><span class="nb">unfold</span> Map_const <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b ‚äó R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk107"><span class="nb">unfold</span> mult <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Mult_const (A -&gt; C) A
  (runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b, R a a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk108"><span class="nb">unfold</span> Mult_const <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b ‚óè R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk109"><span class="nb">unfold</span> monoid_op <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Monoid_op_and (runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b)
  (R a a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10a"><span class="nb">unfold</span> Monoid_op_and <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b /\ R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10b"><span class="nb">destruct</span> X2 <span class="kr">as</span> [Y1 Y2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Y1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b</span></span></span><br><span><var>Y2</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch R (b ‚ßÜ a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10c"><span class="nb">rewrite</span> runBatch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Y1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b</span></span></span><br><span><var>Y2</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch R b &lt;‚ãÜ&gt; R a) (runBatch id (b ‚ßÜ a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10d"><span class="nb">rewrite</span> runBatch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Y1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b</span></span></span><br><span><var>Y2</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch R b &lt;‚ãÜ&gt; R a) (runBatch id b &lt;‚ãÜ&gt; id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10e"><span class="nb">rewrite</span> subset_ap_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Y1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b</span></span></span><br><span><var>Y2</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">f</span> : A -&gt; C) (<span class="nv">a0</span> : A),
  R a a0 /\
  runBatch R b f /\ f a0 = runBatch id b &lt;‚ãÜ&gt; id a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10f"><span class="kr">exists</span> (<span class="nv">runBatch</span> <span class="nv">id</span> <span class="nv">b</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Y1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b</span></span></span><br><span><var>Y2</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a0</span> : A,
  R a a0 /\
  runBatch R b (runBatch id b) /\
  runBatch id b a0 = runBatch id b &lt;‚ãÜ&gt; id a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk110"><span class="kr">exists</span> <span class="nv">a</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A A (A -&gt; C)</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b -&gt;
runBatch R b (runBatch id b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Y1</var><span class="hyp-type"><b>: </b><span>runBatch (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) b</span></span></span><br><span><var>Y2</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a /\
runBatch R b (runBatch id b) /\
runBatch id b a = runBatch id b &lt;‚ãÜ&gt; id a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk111"><span class="kn">Lemma</span> <span class="nf">Forall_vector</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A),
      Forall R t = Forall R (trav_contents t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
Forall R t = Forall R (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
Forall R t = Forall R (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk113"><span class="nb">unfold</span> Forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
foldMap R t = foldMap R (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk114"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap R t = foldMap R (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk115"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse R t = foldMap R (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk116"><span class="nb">rewrite</span> traverse_repr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards
     (traverse (mkBackwards ‚àò R) (trav_contents t))) =
foldMap R (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk117"><span class="nb">induction</span> (trav_contents t) <span class="nb">using</span> Vector_induction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards (traverse (mkBackwards ‚àò R) vnil)) =
foldMap R vnil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk118"><hr></label><div class="goal-conclusion">map (trav_make t)
  (forwards (traverse (mkBackwards ‚àò R) (vcons m a v))) =
foldMap R (vcons m a v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk119">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards (traverse (mkBackwards ‚àò R) vnil)) =
foldMap R vnil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (exist (<span class="kr">fun</span> <span class="nv">l</span> : list <span class="kt">False</span> =&gt; length l = <span class="mi">0</span>) nil
     eq_refl) =
pure
  (exist (<span class="kr">fun</span> <span class="nv">l</span> : list <span class="kt">False</span> =&gt; length l = <span class="mi">0</span>) nil
     eq_refl)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards (traverse (mkBackwards ‚àò R) (vcons m a v))) =
foldMap R (vcons m a v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11c"><span class="nb">rewrite</span> traverse_Vector_vcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards
     (pure (vcons m) &lt;‚ãÜ&gt; (mkBackwards ‚àò R) a &lt;‚ãÜ&gt;
      traverse (mkBackwards ‚àò R) v)) =
foldMap R (vcons m a v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11d"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards
     (pure (vcons m) &lt;‚ãÜ&gt; (mkBackwards ‚àò R) a &lt;‚ãÜ&gt;
      traverse (mkBackwards ‚àò R) v)) =
traverse R (vcons m a v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11e"><span class="nb">rewrite</span> traverse_Vector_vcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards
     (pure (vcons m) &lt;‚ãÜ&gt; (mkBackwards ‚àò R) a &lt;‚ãÜ&gt;
      traverse (mkBackwards ‚àò R) v)) =
pure (vcons m) &lt;‚ãÜ&gt; R a &lt;‚ãÜ&gt; traverse R v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11f"><span class="nb">rewrite</span> &lt;- foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (trav_make t)
  (forwards
     (pure (vcons m) &lt;‚ãÜ&gt; (mkBackwards ‚àò R) a &lt;‚ãÜ&gt;
      traverse (mkBackwards ‚àò R) v)) =
pure (vcons m) &lt;‚ãÜ&gt; R a &lt;‚ãÜ&gt; foldMap R v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk120"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (traverse (mkBackwards ‚àò R) v)
‚óè (R a ‚óè pure (vcons m)) =
(pure (vcons m) ‚óè R a) ‚óè foldMap R v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk121"><span class="nb">rewrite</span> &lt;- IHv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (traverse (mkBackwards ‚àò R) v)
‚óè (R a ‚óè pure (vcons m)) =
(pure (vcons m) ‚óè R a)
‚óè map (trav_make t)
    (forwards (traverse (mkBackwards ‚àò R) v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk122"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (traverse (mkBackwards ‚àò R) v)
‚óè (R a ‚óè pure (vcons m)) =
(pure (vcons m) ‚óè R a)
‚óè map (trav_make t)
    (forwards (traverse (mkBackwards ‚àò R) v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk123"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(forwards
   (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
      (mkBackwards ‚àò R) v) /\ R a /\ ∆µ) =
((∆µ /\ R a) /\
 (<span class="kr">let</span> (<span class="nv">forwards</span>) :=
    traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
      (mkBackwards ‚àò R) v <span class="kr">in</span>
  forwards))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk124"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(forwards
   (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
      (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span>) =
((<span class="kt">True</span> /\ R a) /\
 (<span class="kr">let</span> (<span class="nv">forwards</span>) :=
    traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
      (mkBackwards ‚àò R) v <span class="kr">in</span>
  forwards))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk125">propext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span> -&gt;
(<span class="kt">True</span> /\ R a) /\
(<span class="kr">let</span> (<span class="nv">forwards</span>) :=
   traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v <span class="kr">in</span>
 forwards)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk126" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk126"><hr></label><div class="goal-conclusion">(<span class="kt">True</span> /\ R a) /\
(<span class="kr">let</span> (<span class="nv">forwards</span>) :=
   traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v <span class="kr">in</span>
 forwards) -&gt;
forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk127">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span> -&gt;
(<span class="kt">True</span> /\ R a) /\
(<span class="kr">let</span> (<span class="nv">forwards</span>) :=
   traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v <span class="kr">in</span>
 forwards)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk128"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> /\ R a) /\
(<span class="kr">let</span> (<span class="nv">forwards</span>) :=
   traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v <span class="kr">in</span>
 forwards)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk129">preprocess.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> /\ R a) /\
(<span class="kr">let</span> (<span class="nv">forwards</span>) :=
   traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v <span class="kr">in</span>
 forwards)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> /\ R a) /\
(<span class="kr">let</span> (<span class="nv">forwards</span>) :=
   traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v <span class="kr">in</span>
 forwards) -&gt;
forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>(<span class="kt">True</span> /\ R a) /\
(<span class="kr">let</span> (<span class="nv">forwards</span>) :=
   traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v <span class="kr">in</span>
 forwards)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12c">preprocess.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>map (trav_make t) (forwards (traverse (mkBackwards ‚àò R) v)) = foldMap R v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>R a</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> (<span class="nv">forwards</span>) :=
  traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
    (mkBackwards ‚àò R) v <span class="kr">in</span>
forwards</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards
  (traverse_Vector m (Backwards (const <span class="kt">Prop</span>))
     (mkBackwards ‚àò R) v) /\ R a /\ <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12d"><span class="kn">Lemma</span> <span class="nf">relation_diagonal2</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A),
      lift_relation R t t -&gt; Forall (<span class="kr">fun</span> (<span class="nv">a</span>: A) =&gt; R a a) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
lift_relation R t t -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
lift_relation R t t -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12f">introv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t t -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk130"><span class="nb">rewrite</span> (relation_to_zipped_iff _ _ R t t (eq_refl)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t) /\
Forall (uncurry R) (same_shape_zip t t eq_refl) -&gt;
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk131"><span class="nb">intros</span> [X1 X2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Forall (uncurry R) (same_shape_zip t t eq_refl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk132"><span class="nb">generalize dependent</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R) (same_shape_zip t t eq_refl) -&gt;
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk133"><span class="nb">unfold</span> same_shape_zip.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R)
  (trav_make t (same_shape_zip_contents t t eq_refl)) -&gt;
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk134"><span class="nb">unfold</span> same_shape_zip_contents.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R)
  (trav_make t
     (Vector_zip A A (plength t) (plength t)
        (trav_contents t) (trav_contents t)
        (same_shape_implies_plength t t eq_refl))) -&gt;
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk135"><span class="nb">rewrite</span> Vector_zip_proof_irrelevance2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R)
  (trav_make t
     (Vector_zip_eq (trav_contents t)
        (trav_contents t))) -&gt;
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk136"><span class="nb">rewrite</span> Vector_zip_diagonal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (uncurry R)
  (trav_make t
     (map (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (a, a)) (trav_contents t))) -&gt;
Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk137"><span class="nb">unfold</span> Forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (trav_make t
     (map (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (a, a)) (trav_contents t))) -&gt;
foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk138"><span class="nb">rewrite</span> foldMap_trav_make.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R)
  (map (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (a, a)) (trav_contents t)) -&gt;
foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk139">compose near (trav_contents t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap (uncurry R) ‚àò map (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (a, a)))
  (trav_contents t) -&gt; foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13a"><span class="nb">rewrite</span> foldMap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (uncurry R ‚àò (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (a, a)))
  (trav_contents t) -&gt; foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13b"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; uncurry R (a, a))
  (trav_contents t) -&gt; foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13c"><span class="nb">intro</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; uncurry R (a, a))
  (trav_contents t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13d"><span class="nb">change</span> (Forall (<span class="kr">fun</span> <span class="nv">a</span> =&gt; R a a) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; uncurry R (a, a))
  (trav_contents t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13e"><span class="nb">rewrite</span> Forall_vector.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; uncurry R (a, a))
  (trav_contents t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13f"><span class="nb">unfold</span> uncurry <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (trav_contents t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (trav_contents t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk140"><span class="nb">induction</span> (trav_contents t) <span class="nb">using</span> Vector_induction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) vnil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) vnil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk141" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (vcons m a v)</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk141"><hr></label><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (vcons m a v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk142">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) vnil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) vnil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk143"><span class="nb">unfold</span> Forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) vnil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) vnil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk144"><span class="nb">rewrite</span> foldMap_Vector_vnil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) vnil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk145">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (vcons m a v)</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (vcons m a v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk146"><span class="nb">unfold</span> Forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (vcons m a v)</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (vcons m a v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk147"><span class="nb">rewrite</span> foldMap_Vector_vcons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) (vcons m a v)</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk148"><span class="nb">rewrite</span> foldMap_Vector_vcons <span class="kr">in</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk149"><span class="nb">inversion</span> X2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14a"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk14b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk14b"><hr></label><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14e"><span class="nb">apply</span> IHv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, trav_make t ~!~ trav_make t</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Vector m A</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>R a a ‚óè foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>IHv</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v -&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>R a a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14f"><span class="kn">Lemma</span> <span class="nf">relation_diagonal_iff</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">R</span>: A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span>: T A),
      lift_relation R t t &lt;-&gt; Forall (<span class="kr">fun</span> (<span class="nv">a</span>: A) =&gt; R a a) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
lift_relation R t t &lt;-&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk150"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : T A),
lift_relation R t t &lt;-&gt; Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk151">introv; <span class="nb">split</span>; <span class="nb">intro</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>lift_relation R t t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk152" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk152"><hr></label><div class="goal-conclusion">lift_relation R t t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk153"><span class="nb">apply</span> relation_diagonal2; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor.ApplicativeDist T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Categorical.TraversableFunctor.TraversableFunctor
  T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; R a a) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_relation R t t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> relation_diagonal1; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">relprop</span>.</span></span></pre>
</div>
</div></body>
</html>
