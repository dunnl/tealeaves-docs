<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>List_Telescoping_General.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Kleisli.DecoratedTraversableFunctor
  Classes.Kleisli.DecoratedTraversableCommIdemFunctor
  Classes.Categorical.ApplicativeCommutativeIdempotent
  Functors.Early.List
  Functors.Diagonal
  Functors.Pair
  Functors.Early.Writer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> TraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DecoratedTraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DecoratedTraversableCommIdemFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span> œï.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Prefix Decoration Operation for the [List] Functor *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Accumulator-Based Specification *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rec_version</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">decorate_prefix_list_rec</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">ctx</span>: list A) (<span class="nv">l</span>: list A):
    list (list A * A) :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | nil =&gt; nil
    | x :: xs =&gt;
        <span class="c">(* (ctx, x) :: decorate_prefix_list_rec (x :: ctx) xs *)</span>
        (ctx, x) :: decorate_prefix_list_rec (ctx ++ [x]) xs
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">decorate_prefix_list_</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">l</span>: list A):
    list (list A * A) := decorate_prefix_list_rec nil l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rec_version</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Map-Based Specification *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">decorate_prefix_list</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">l</span>: list A):
  list (list A * A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; nil
  | x :: xs =&gt;
      (nil, x) :: map (F := list) (incr [x]) (decorate_prefix_list xs)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalence *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk0"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_equiv_rec</span>:
  <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">ctx</span>: list A) (<span class="nv">l</span>: list A),
    decorate_prefix_list_rec ctx l =
      map (F := list) (incr ctx) (decorate_prefix_list l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> <span class="nv">l</span> : list A),
decorate_prefix_list_rec ctx l =
map (incr ctx) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> <span class="nv">l</span> : list A),
decorate_prefix_list_rec ctx l =
map (incr ctx) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec ctx l =
map (incr ctx) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3"><span class="nb">generalize dependent</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l =
map (incr ctx) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk4"><span class="nb">induction</span> l; <span class="nb">intro</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec ctx [] =
map (incr ctx) (decorate_prefix_list [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk5"><hr></label><div class="goal-conclusion">decorate_prefix_list_rec ctx (a :: l) =
map (incr ctx) (decorate_prefix_list (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec ctx [] =
map (incr ctx) (decorate_prefix_list [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec ctx (a :: l) =
map (incr ctx) (decorate_prefix_list (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ctx, a) :: decorate_prefix_list_rec (ctx ++ [a]) l =
(ctx ‚óè [], a)
:: map (incr ctx)
     (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk9"><span class="nb">unfold</span> Monoid_op_list <span class="nb">at</span> <span class="mi">1</span>, monoid_op <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ctx, a) :: decorate_prefix_list_rec (ctx ++ [a]) l =
(ctx ++ [], a)
:: map (incr ctx)
     (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka"><span class="nb">rewrite</span> List.app_nil_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ctx, a) :: decorate_prefix_list_rec (ctx ++ [a]) l =
(ctx, a)
:: map (incr ctx)
     (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec (ctx ++ [a]) l =
map (incr ctx)
  (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc">compose near (decorate_prefix_list l) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec (ctx ++ [a]) l =
(map (incr ctx) ‚àò map (incr [a]))
  (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec (ctx ++ [a]) l =
map (incr ctx ‚àò incr [a]) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke"><span class="nb">rewrite</span> incr_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec (ctx ++ [a]) l =
map (incr (ctx ‚óè [a])) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf">unfold_ops @Monoid_op_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec (ctx ++ [a]) l =
map (incr (ctx ++ [a])) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk10"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
decorate_prefix_list_rec ctx l = map (incr ctx) (decorate_prefix_list l)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (incr (ctx ++ [a])) (decorate_prefix_list l) =
map (incr (ctx ++ [a])) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk11"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_equiv</span>:
  <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">l</span>: list A),
    decorate_prefix_list_ l = decorate_prefix_list l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk13"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk14"><span class="nb">assert</span> (incr [] = id (A := list A * A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">incr [] = id</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>incr [] = id</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk15"><hr></label><div class="goal-conclusion">decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk16">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">incr [] = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext [l&#39; a].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk17">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>incr [] = id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk18"><span class="nb">specialize</span> (decorate_prefix_list_equiv_rec A nil l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>incr [] = id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec [] l =
map (incr []) (decorate_prefix_list l) -&gt;
decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk19"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>incr [] = id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec [] l =
map id (decorate_prefix_list l) -&gt;
decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>incr [] = id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list_rec [] l =
id (decorate_prefix_list l) -&gt;
decorate_prefix_list_ l = decorate_prefix_list l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Examples *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Examples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">list1</span> := [ <span class="mi">3</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">list2</span> := [ <span class="mi">3</span> ; <span class="mi">5</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Example</span> <span class="nf">list3</span> := [ <span class="mi">3</span> ; <span class="mi">5</span> ; <span class="mi">7</span> ; <span class="mi">8</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Compute decorate_prefix_list list3. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Examples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting Laws *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">decorate_prefix_list_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">A</span>: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_rw_nil</span>:
    decorate_prefix_list (@nil A) = (@nil (list A * A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list [] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list [] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_rw_one</span>: <span class="kr">forall</span> (<span class="nv">a</span>: A),
      decorate_prefix_list [a] = [([], a)].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, decorate_prefix_list [a] = [([], a)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, decorate_prefix_list [a] = [([], a)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_rw_cons</span>: <span class="kr">forall</span> (<span class="nv">a</span>: A) (<span class="nv">l</span>: list A),
      decorate_prefix_list (a :: l) =
        ([], a) :: map (incr [a]) (decorate_prefix_list l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
decorate_prefix_list (a :: l) =
([], a) :: map (incr [a]) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
decorate_prefix_list (a :: l) =
([], a) :: map (incr [a]) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk21"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list (a :: l) =
([], a) :: map (incr [a]) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk22"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a) :: map (incr [a]) (decorate_prefix_list l) =
([], a) :: map (incr [a]) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk23"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_rw_app</span>: <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span>: list A),
      decorate_prefix_list (l1 ++ l2) =
        decorate_prefix_list l1 ++ map (incr l1) (decorate_prefix_list l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk25"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk26"><span class="nb">induction</span> l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list ([] ++ l2) =
decorate_prefix_list [] ++
map (incr []) (decorate_prefix_list l2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk27"><hr></label><div class="goal-conclusion">decorate_prefix_list ((a :: l1) ++ l2) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list ([] ++ l2) =
decorate_prefix_list [] ++
map (incr []) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk29"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list l2 =
map (incr []) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a"><span class="nb">change</span> (incr []) <span class="kr">with</span> (incr (A := A) (∆µ: list A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list l2 =
map (incr (∆µ : list A)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b"><span class="nb">rewrite</span> incr_zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list l2 =
map id (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c"><span class="nb">rewrite</span> (fun_map_id (F := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list l2 = id (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d">- <span class="c">(* left *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list ((a :: l1) ++ l2) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e"><span class="nb">rewrite</span> &lt;- List.app_comm_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list (a :: l1 ++ l2) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a)
:: map (incr [a]) (decorate_prefix_list (l1 ++ l2)) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk30"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a)
:: map (incr [a])
     (decorate_prefix_list l1 ++
      map (incr l1) (decorate_prefix_list l2)) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk31"><span class="nb">rewrite</span> map_list_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a)
:: map (incr [a]) (decorate_prefix_list l1) ++
   map (incr [a])
     (map (incr l1) (decorate_prefix_list l2)) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk32">compose near (decorate_prefix_list l2) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a)
:: map (incr [a]) (decorate_prefix_list l1) ++
   (map (incr [a]) ‚àò map (incr l1))
     (decorate_prefix_list l2) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk33"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a)
:: map (incr [a]) (decorate_prefix_list l1) ++
   map (incr [a] ‚àò incr l1) (decorate_prefix_list l2) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk34"><span class="nb">rewrite</span> incr_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a)
:: map (incr [a]) (decorate_prefix_list l1) ++
   map (incr ([a] ‚óè l1)) (decorate_prefix_list l2) =
decorate_prefix_list (a :: l1) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk35"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>decorate_prefix_list (l1 ++ l2) =
decorate_prefix_list l1 ++
map (incr l1) (decorate_prefix_list l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], a)
:: map (incr [a]) (decorate_prefix_list l1) ++
   map (incr ([a] ‚óè l1)) (decorate_prefix_list l2) =
(([], a) :: map (incr [a]) (decorate_prefix_list l1)) ++
map (incr (a :: l1)) (decorate_prefix_list l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">decorate_prefix_list_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The &lt;&lt;Z&gt;&gt; Comonad (Categorical) *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span> Categorical.Comonad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Z</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span> := <span class="kr">fun</span> <span class="nv">A</span> =&gt; list A * A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Tactical Support: Folding/Unfolding *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfold_Z</span>:=
  <span class="kp">repeat</span> <span class="nb">change</span> (Z <span class="nl">?A</span>) <span class="kr">with</span> (list A * A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfold_Z_in</span> H:=
  <span class="kp">repeat</span> <span class="nb">change</span> (Z <span class="nl">?A</span>) <span class="kr">with</span> (list A * A) <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">unfold_Z_all</span>:=
  <span class="kp">repeat</span> <span class="nb">change</span> (Z <span class="nl">?A</span>) <span class="kr">with</span> (list A * A) <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fold_Z</span> :=
  <span class="kp">repeat</span> <span class="nb">change</span> (list <span class="nl">?A</span> * <span class="nl">?A</span>) <span class="kr">with</span> (Z A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fold_Z_in</span> H :=
  <span class="kp">repeat</span> <span class="nb">change</span> (list <span class="nl">?A</span> * <span class="nl">?A</span>) <span class="kr">with</span> (Z A) <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">fold_Z_all</span> :=
  <span class="kp">repeat</span> <span class="nb">change</span> (list <span class="nl">?A</span> * <span class="nl">?A</span>) <span class="kr">with</span> (Z A) <span class="kr">in</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functor Instance *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Map_Z</span>: Map Z :=
  <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> =&gt; map_pair (map (F := list) f) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk36">#[export] <span class="kn">Instance</span> <span class="nf">Functor_Z</span>: Functor Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk38"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map id = id</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map id (l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id (map id l), id (id a)) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id (id l), id (id a)) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C),
map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g ‚àò map f = map (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk40">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò map f) (l, a) = map (g ‚àò f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk41"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id (map g (id (map f l))), g (id (f (id a)))) =
(id (map (g ‚àò f) l), (g ‚àò f) (id a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk42"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g (map f l), g (f a)) =
(map (g ‚àò f) l, (g ‚àò f) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk43">compose near l on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((map g ‚àò map f) l, g (f a)) =
(map (g ‚àò f) l, (g ‚àò f) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk44"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (g ‚àò f) l, g (f a)) = (map (g ‚àò f) l, (g ‚àò f) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Naturality of &lt;&lt;decorated_prefix_list&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk45">#[export] <span class="kn">Instance</span> <span class="nf">Natural_decorate_prefix_list</span>:
  Natural (@decorate_prefix_list).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@decorate_prefix_list)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@decorate_prefix_list)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk47"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò decorate_prefix_list =
decorate_prefix_list ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk48"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò decorate_prefix_list =
decorate_prefix_list ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk49"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚óã decorate_prefix_list =
decorate_prefix_list ‚óã map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk4a">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (decorate_prefix_list l) =
decorate_prefix_list (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk4b"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) =
decorate_prefix_list (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk4c"><span class="nb">induction</span> l; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (decorate_prefix_list []) =
decorate_prefix_list (map f [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk4d"><hr></label><div class="goal-conclusion">map f (decorate_prefix_list (a :: l)) =
decorate_prefix_list (map f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk4e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (decorate_prefix_list []) =
decorate_prefix_list (map f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk4f">- <span class="c">(* left *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (decorate_prefix_list (a :: l)) =
decorate_prefix_list (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk50"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f
  (([], a) :: map (incr [a]) (decorate_prefix_list l)) =
decorate_prefix_list (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk51">unfold_ops @Map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f)
  (([], a) :: map (incr [a]) (decorate_prefix_list l)) =
decorate_prefix_list (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk52"><span class="nb">rewrite</span> map_list_cons <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f)
     (map (incr [a]) (decorate_prefix_list l)) =
decorate_prefix_list (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk53">compose near (decorate_prefix_list l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: (map (map f) ‚àò map (incr [a]))
     (decorate_prefix_list l) =
decorate_prefix_list (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk54"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
decorate_prefix_list (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* right *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk55"><span class="nb">rewrite</span> map_list_cons <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
decorate_prefix_list (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk56"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
([], f a)
:: map (incr [f a]) (decorate_prefix_list (map f l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk57"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
([], f a)
:: map (incr [f a]) (map f (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk58">compose near (decorate_prefix_list l) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
([], f a)
:: (map (incr [f a]) ‚àò map f) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk59">unfold_ops @Map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
([], f a)
:: (map (incr [f a]) ‚àò map (map f))
     (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk5a"><span class="nb">change</span> (prod (list <span class="nl">?B</span>) <span class="nl">?B</span>) <span class="kr">with</span> (Z B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
([], f a)
:: (map (incr [f a]) ‚àò map (map f))
     (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk5b"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ([], a)
:: map (map f ‚àò incr [a]) (decorate_prefix_list l) =
([], f a)
:: map (incr [f a] ‚àò map f) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk5c">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f ‚àò incr [a]) (decorate_prefix_list l) =
map (incr [f a] ‚àò map f) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk5d">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò incr [a] = incr [f a] ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk5e">ext [z z&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; B,
map f (decorate_prefix_list l) = decorate_prefix_list (map f l)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f ‚àò incr [a]) (z, z&#39;) =
(incr [f a] ‚àò map f) (z, z&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Operations &lt;&lt;cojoin_Z&gt;&gt; and &lt;&lt;extract_Z&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Cojoin_Z</span>: Cojoin Z :=
  <span class="kr">fun</span> <span class="nv">A</span> &#39;(l, a) =&gt; (decorate_prefix_list l, (l, a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Extract_Z</span>: Extract Z :=
  <span class="kr">fun</span> (<span class="nv">A</span>: <span class="kt">Type</span>) =&gt; @snd (list A) A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting Laws *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Cojoin_Z_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span>: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk5f"><span class="kn">Lemma</span> <span class="nf">cojoin_Z_rw_nil</span>: <span class="kr">forall</span> (<span class="nv">a</span>: A),
      cojoin (W := Z) (@nil A, a) = (nil, (nil, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, cojoin ([], a) = ([], ([], a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, cojoin ([], a) = ([], ([], a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk61"><span class="kn">Lemma</span> <span class="nf">cojoin_Z_rw_cons</span>: <span class="kr">forall</span> (<span class="nv">a1</span> <span class="nv">a2</span>: A) (<span class="nv">l</span>: list A),
      cojoin (W := Z) (a1 :: l, a2) =
        (([], a1) ::
           map (incr [a1]) (decorate_prefix_list l), (a1 :: l, a2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a1</span> <span class="nv">a2</span> : A) (<span class="nv">l</span> : list A),
cojoin (a1 :: l, a2) =
(([], a1) :: map (incr [a1]) (decorate_prefix_list l),
 (a1 :: l, a2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a1</span> <span class="nv">a2</span> : A) (<span class="nv">l</span> : list A),
cojoin (a1 :: l, a2) =
(([], a1) :: map (incr [a1]) (decorate_prefix_list l),
 (a1 :: l, a2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk63">unfold_ops @Cojoin_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a1</span> <span class="nv">a2</span> : A) (<span class="nv">l</span> : list A),
(decorate_prefix_list (a1 :: l), (a1 :: l, a2)) =
(([], a1) :: map (incr [a1]) (decorate_prefix_list l),
 (a1 :: l, a2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk64"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (a1 :: l), (a1 :: l, a2)) =
(([], a1) :: map (incr [a1]) (decorate_prefix_list l),
 (a1 :: l, a2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk65"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(([], a1) :: map (incr [a1]) (decorate_prefix_list l),
 (a1 :: l, a2)) =
(([], a1) :: map (incr [a1]) (decorate_prefix_list l),
 (a1 :: l, a2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk66"><span class="kn">Lemma</span> <span class="nf">cojoin_Z_rw_app</span>: <span class="kr">forall</span> (<span class="nv">a</span>: A) (<span class="nv">l1</span> <span class="nv">l2</span>: list A),
      cojoin (W := Z) (l1 ++ l2, a) =
        (decorate_prefix_list l1 ++
           map (incr l1) (decorate_prefix_list l2),
          (l1 ++ l2, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
cojoin (l1 ++ l2, a) =
(decorate_prefix_list l1 ++
 map (incr l1) (decorate_prefix_list l2),
 (l1 ++ l2, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk67"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
cojoin (l1 ++ l2, a) =
(decorate_prefix_list l1 ++
 map (incr l1) (decorate_prefix_list l2),
 (l1 ++ l2, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk68">unfold_ops @Cojoin_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
(decorate_prefix_list (l1 ++ l2), (l1 ++ l2, a)) =
(decorate_prefix_list l1 ++
 map (incr l1) (decorate_prefix_list l2),
 (l1 ++ l2, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk69"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (l1 ++ l2), (l1 ++ l2, a)) =
(decorate_prefix_list l1 ++
 map (incr l1) (decorate_prefix_list l2),
 (l1 ++ l2, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk6a"><span class="nb">rewrite</span> decorate_prefix_list_rw_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list l1 ++
 map (incr l1) (decorate_prefix_list l2),
 (l1 ++ l2, a)) =
(decorate_prefix_list l1 ++
 map (incr l1) (decorate_prefix_list l2),
 (l1 ++ l2, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk6b"><span class="kn">Lemma</span> <span class="nf">cojoin_Z_rw_preincr_one</span>: <span class="kr">forall</span> (<span class="nv">ctx</span>: A) (<span class="nv">l</span>: list A) (<span class="nv">a</span>: A),
      (cojoin (W := Z) ‚¶ø [ctx]) (l, a) =
        map_pair (cons ([], ctx) ‚àò map (incr [ctx])) (incr [ctx])
          (cojoin (W := Z) (l, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
(cojoin ‚¶ø [ctx]) (l, a) =
map_pair (cons ([], ctx) ‚àò map (incr [ctx]))
  (incr [ctx]) (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
(cojoin ‚¶ø [ctx]) (l, a) =
map_pair (cons ([], ctx) ‚àò map (incr [ctx]))
  (incr [ctx]) (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk6d"><span class="kn">Lemma</span> <span class="nf">cojoin_Z_rw_preincr</span>: <span class="kr">forall</span> (<span class="nv">ctx</span>: list A) (<span class="nv">l</span>: list A) (<span class="nv">a</span>: A),
      (cojoin (W := Z) ‚¶ø ctx) (l, a) =
        map_pair (app (decorate_prefix_list ctx) ‚àò
                    map (incr ctx)) (incr ctx)
          (cojoin (W := Z) (l, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx</span> <span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
(cojoin ‚¶ø ctx) (l, a) =
map_pair
  (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
  (incr ctx) (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx</span> <span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
(cojoin ‚¶ø ctx) (l, a) =
map_pair
  (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
  (incr ctx) (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk6f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cojoin ‚¶ø ctx) (l, a) =
map_pair
  (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
  (incr ctx) (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk70"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (ctx ‚óè l), (ctx ‚óè l, a)) =
(id
   ((app (decorate_prefix_list ctx) ‚àò map (incr ctx))
      (decorate_prefix_list l)), (ctx ‚óè l, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk71"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (ctx ‚óè l), (ctx ‚óè l, a)) =
((app (decorate_prefix_list ctx) ‚àò map (incr ctx))
   (decorate_prefix_list l), (ctx ‚óè l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk72"><span class="nb">change</span> (<span class="nl">?x</span> ‚óè <span class="nl">?y</span>) <span class="kr">with</span> (x ++ y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (ctx ++ l), (ctx ++ l, a)) =
((app (decorate_prefix_list ctx) ‚àò map (incr ctx))
   (decorate_prefix_list l), (ctx ++ l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk73"><span class="nb">rewrite</span> decorate_prefix_list_rw_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list ctx ++
 map (incr ctx) (decorate_prefix_list l),
 (ctx ++ l, a)) =
((app (decorate_prefix_list ctx) ‚àò map (incr ctx))
   (decorate_prefix_list l), (ctx ++ l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk74"><span class="kn">Lemma</span> <span class="nf">cojoin_Z_rw_preincr_pf</span>: <span class="kr">forall</span> (<span class="nv">ctx</span>: list A),
      cojoin (W := Z) ‚¶ø ctx =
        map_pair (app (decorate_prefix_list ctx) ‚àò
                    map (incr ctx)) (incr ctx) ‚àò cojoin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
cojoin ‚¶ø ctx =
map_pair
  (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
  (incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list A,
cojoin ‚¶ø ctx =
map_pair
  (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
  (incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk76"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cojoin ‚¶ø ctx =
map_pair
  (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
  (incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk77">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cojoin ‚¶ø ctx) (l, a) =
(map_pair
   (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
   (incr ctx) ‚àò cojoin) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> cojoin_Z_rw_preincr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk78"><span class="kn">Lemma</span> <span class="nf">extract_Z_incr</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">ctx</span>: list A),
      extract (W := Z) ‚àò incr ctx = extract (W := Z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list A),
extract ‚àò incr ctx = extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list A),
extract ‚àò incr ctx = extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk7a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ‚àò incr ctx = extract</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk7b">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(extract ‚àò incr ctx) (l, a) = extract (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk7c"><span class="kn">Lemma</span> <span class="nf">extract_Z_prod</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
      @extract Z Extract_Z A = @extract (prod (list A)) (@Extract_reader (list A)) A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, extract = extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, extract = extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Cojoin_Z_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Naturality *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk7e">#[export] <span class="kn">Instance</span> <span class="nf">Natural_Extract_Z</span>: Natural (@extract Z Extract_Z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@extract Z Extract_Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@extract Z Extract_Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk80"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò extract = extract ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk81"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò extract = extract ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk82">ext [ctx a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f ‚àò extract) (ctx, a) =
(extract ‚àò map f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk83">#[export] <span class="kn">Instance</span> <span class="nf">Natural_Cojoin_Z</span>: Natural (@cojoin Z Cojoin_Z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@cojoin Z Cojoin_Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk84"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@cojoin Z Cojoin_Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk85"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò cojoin = cojoin ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk86"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò cojoin = cojoin ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk87">ext [ctx a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f ‚àò cojoin) (ctx, a) = (cojoin ‚àò map f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk88"><span class="nb">cbn</span>; <span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map f) (decorate_prefix_list ctx),
 (map f ctx, f a)) =
(decorate_prefix_list (map f ctx), (map f ctx, f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk89">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map f) (decorate_prefix_list ctx) =
decorate_prefix_list (map f ctx)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk8a">compose near ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map f) ‚àò decorate_prefix_list) ctx =
(decorate_prefix_list ‚àò map f) ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk8b"><span class="nb">rewrite</span> &lt;- (natural (Natural := Natural_decorate_prefix_list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map f) ‚àò decorate_prefix_list) ctx =
(map f ‚àò decorate_prefix_list) ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Comonad Laws *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">map_args</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;&#39;dec&#39;&quot;</span> := decorate_prefix_list.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> map (F)%function_scope {Map} {A B}%type_scope f%function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk8c"><span class="kn">Lemma</span> <span class="nf">cojoin_assoc_lemma</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">l</span>: list A),
      dec (dec l) = map list cojoin (dec l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
dec (dec l) = map list cojoin (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
dec (dec l) = map list cojoin (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk8e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec (dec l) = map list cojoin (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk8f"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec (dec []) = map list cojoin (dec [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk90"><hr></label><div class="goal-conclusion">dec (dec (a :: l)) = map list cojoin (dec (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec (dec []) = map list cojoin (dec [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk92">- <span class="c">(* left *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec (dec (a :: l)) = map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk93"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec (([], a) :: map list (incr [a]) (dec l)) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk94"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)])
     (dec (map list (incr [a]) (dec l))) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk95">compose near (dec l) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)])
     ((dec ‚àò map list (incr [a])) (dec l)) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk96"><span class="nb">rewrite</span> &lt;- (natural (Natural := Natural_decorate_prefix_list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)])
     ((map (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; list (list A * A))
         (incr [a]) ‚àò dec) (dec l)) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk97"><span class="nb">change</span> (map (A := <span class="nl">?A</span>) (B := <span class="nl">?B</span>)
                (<span class="kr">fun</span> <span class="nv">A0</span>: <span class="kt">Type</span> =&gt; list (list A0 * A0))) <span class="kr">with</span>
        (map (list ‚àò Z) (A := A) (B := B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)])
     ((map (list ‚àò Z) (incr [a]) ‚àò dec) (dec l)) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk98">unfold_ops @Map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)])
     ((map list (map Z (incr [a])) ‚àò dec) (dec l)) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk99"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)])
     (map list (map Z (incr [a])) (dec (dec l))) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk9a">compose near (dec (dec l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: (map list (incr [([], a)])
    ‚àò map list (map Z (incr [a]))) (dec (dec l)) =
map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk9b"><span class="nb">rewrite</span> (fun_map_map (F := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)] ‚àò map Z (incr [a]))
     (dec (dec l)) = map list cojoin (dec (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* right *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk9c"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)] ‚àò map Z (incr [a]))
     (dec (dec l)) =
map list cojoin
  (([], a) :: map list (incr [a]) (dec l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk9d"><span class="nb">rewrite</span> map_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)] ‚àò map Z (incr [a]))
     (dec (dec l)) =
cojoin ([], a)
:: map list cojoin (map list (incr [a]) (dec l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk9e"><span class="nb">unfold</span> cojoin <span class="nb">at</span> <span class="mi">1</span>, Cojoin_Z <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)] ‚àò map Z (incr [a]))
     (dec (dec l)) =
(dec [], ([], a))
:: map list cojoin (map list (incr [a]) (dec l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk9f"><span class="nb">rewrite</span> decorate_prefix_list_rw_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], a))
:: map list (incr [([], a)] ‚àò map Z (incr [a]))
     (dec (dec l)) =
([], ([], a))
:: map list cojoin (map list (incr [a]) (dec l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* fequal *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka0">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map list (incr [([], a)] ‚àò map Z (incr [a]))
  (dec (dec l)) =
map list cojoin (map list (incr [a]) (dec l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka1">compose near (dec l) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map list (incr [([], a)] ‚àò map Z (incr [a]))
  (dec (dec l)) =
(map list cojoin ‚àò map list (incr [a])) (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka2"><span class="nb">rewrite</span> (fun_map_map (F := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map list (incr [([], a)] ‚àò map Z (incr [a]))
  (dec (dec l)) = map list (cojoin ‚àò incr [a]) (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* panic *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka3"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map list (incr [([], a)] ‚àò map Z (incr [a]))
  (map list cojoin (dec l)) =
map list (cojoin ‚àò incr [a]) (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka4">compose near (dec l) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map list (incr [([], a)] ‚àò map Z (incr [a]))
 ‚àò map list cojoin) (dec l) =
map list (cojoin ‚àò incr [a]) (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka5"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map list (incr [([], a)] ‚àò map Z (incr [a]) ‚àò cojoin)
  (dec l) = map list (cojoin ‚àò incr [a]) (dec l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka6">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">incr [([], a)] ‚àò map Z (incr [a]) ‚àò cojoin =
cojoin ‚àò incr [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka7">ext [zl za].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br><span><var>zl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>za</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(incr [([], a)] ‚àò map Z (incr [a]) ‚àò cojoin) (zl, za) =
(cojoin ‚àò incr [a]) (zl, za)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka8"><span class="nb">cbn</span>; <span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>dec (dec l) = map list cojoin (dec l)</span></span></span><br><span><var>zl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>za</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(([], a) :: map list (incr [a]) (dec zl),
 (a :: zl, za)) =
(([], a) :: map list (incr [a]) (dec zl),
 (a :: zl, za))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">map_args</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chka9"><span class="kn">Lemma</span> <span class="nf">cojoin_assoc</span>:
  <span class="kr">forall</span> <span class="nv">A</span>: <span class="kt">Type</span>,
    cojoin (W := Z) ‚àò cojoin (W := Z) =
      map (F := Z) (cojoin (W := Z)) ‚àò cojoin (W := Z) (A := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, cojoin ‚àò cojoin = map cojoin ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, cojoin ‚àò cojoin = map cojoin ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkab"><span class="nb">intros</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cojoin ‚àò cojoin = map cojoin ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkac">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cojoin ‚àò cojoin) (l, a) =
(map cojoin ‚àò cojoin) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkad"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cojoin (cojoin (l, a)) = map cojoin (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkae"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (decorate_prefix_list l),
 (decorate_prefix_list l, (l, a))) =
(id (map cojoin (decorate_prefix_list l)),
 (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkaf"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (decorate_prefix_list l),
 (decorate_prefix_list l, (l, a))) =
(map cojoin (decorate_prefix_list l),
 (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb0"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (decorate_prefix_list []),
 (decorate_prefix_list [], ([], a))) =
(map cojoin (decorate_prefix_list []),
 (decorate_prefix_list [], ([], a)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chkb1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(decorate_prefix_list (decorate_prefix_list l),
(decorate_prefix_list l, (l, a))) =
(map cojoin (decorate_prefix_list l), (decorate_prefix_list l, (l, a)))</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chkb1"><hr></label><div class="goal-conclusion">(decorate_prefix_list (decorate_prefix_list (a0 :: l)),
 (decorate_prefix_list (a0 :: l), (a0 :: l, a))) =
(map cojoin (decorate_prefix_list (a0 :: l)),
 (decorate_prefix_list (a0 :: l), (a0 :: l, a)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (decorate_prefix_list []),
 (decorate_prefix_list [], ([], a))) =
(map cojoin (decorate_prefix_list []),
 (decorate_prefix_list [], ([], a)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], ([], ([], a))) = ([], ([], ([], a)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(decorate_prefix_list (decorate_prefix_list l),
(decorate_prefix_list l, (l, a))) =
(map cojoin (decorate_prefix_list l), (decorate_prefix_list l, (l, a)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(decorate_prefix_list (decorate_prefix_list (a0 :: l)),
 (decorate_prefix_list (a0 :: l), (a0 :: l, a))) =
(map cojoin (decorate_prefix_list (a0 :: l)),
 (decorate_prefix_list (a0 :: l), (a0 :: l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb5">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(decorate_prefix_list (decorate_prefix_list l),
(decorate_prefix_list l, (l, a))) =
(map cojoin (decorate_prefix_list l), (decorate_prefix_list l, (l, a)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list (decorate_prefix_list (a0 :: l)) =
map cojoin (decorate_prefix_list (a0 :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cojoin_assoc_lemma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Typeclass Instance *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb6">#[export] <span class="kn">Instance</span> <span class="nf">Comonad_Z</span>: Comonad Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Comonad Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Comonad Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb8"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor Z</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@extract Z Extract_Z)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@cojoin Z Cojoin_Z)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, extract ‚àò cojoin = id</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map extract ‚àò cojoin = id</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, cojoin ‚àò cojoin = map cojoin ‚àò cojoin</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@extract Z Extract_Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkbb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@cojoin Z Cojoin_Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkbc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, extract ‚àò cojoin = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkbd"><span class="nb">intros</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ‚àò cojoin = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkbe">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(extract ‚àò cojoin) (l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkbf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, map extract ‚àò cojoin = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc0"><span class="nb">intros</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract ‚àò cojoin = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc1">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map extract ‚àò cojoin) (l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc2"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id (map extract (decorate_prefix_list l)), a) =
id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc3">compose near l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id ((map extract ‚àò decorate_prefix_list) l), a) =
id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc4"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((map extract ‚àò decorate_prefix_list) l, a) = (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc5">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map extract ‚àò decorate_prefix_list) l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc6"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc7"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list []) = []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chkc8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chkc8"><hr></label><div class="goal-conclusion">map extract (decorate_prefix_list (a0 :: l)) = a0 :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkc9">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list []) = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkca">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list (a0 :: l)) = a0 :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkcb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0
:: map extract
     (map (incr [a0]) (decorate_prefix_list l)) =
a0 :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkcc">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (map (incr [a0]) (decorate_prefix_list l)) =
l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkcd">compose near (decorate_prefix_list l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map extract ‚àò map (incr [a0]))
  (decorate_prefix_list l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkce"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (extract ‚àò incr [a0]) (decorate_prefix_list l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkcf"><span class="nb">assert</span> (extract (W := Z) ‚àò incr [a0] = extract (A := A) (W := Z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ‚àò incr [a0] = extract</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chkd0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>extract ‚àò incr [a0] = extract</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chkd0"><hr></label><div class="goal-conclusion">map (extract ‚àò incr [a0]) (decorate_prefix_list l) = l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ‚àò incr [a0] = extract</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd2">ext [l&#39; a&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(extract ‚àò incr [a0]) (l&#39;, a&#39;) = extract (l&#39;, a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>extract ‚àò incr [a0] = extract</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (extract ‚àò incr [a0]) (decorate_prefix_list l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd4"><span class="nb">unfold</span> Z <span class="kr">in</span> H <span class="nb">at</span> <span class="mi">1</span>; <span class="nb">cbn</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>extract ‚àò incr [a0] = extract</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (extract ‚àò incr [a0]) (decorate_prefix_list l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd5"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>extract ‚àò incr [a0] = extract</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, cojoin ‚àò cojoin = map cojoin ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cojoin_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** [decorate_prefix_list] as a Right Coaction *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd7"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_extract</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
    map extract ‚àò decorate_prefix_list = @id (list A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map extract ‚àò decorate_prefix_list = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map extract ‚àò decorate_prefix_list = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkd9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract ‚àò decorate_prefix_list = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkda">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map extract ‚àò decorate_prefix_list) l = id l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkdb"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list l) = id l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkdc"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list []) = id []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chkdd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chkdd"><hr></label><div class="goal-conclusion">map extract (decorate_prefix_list (a :: l)) =
id (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkde">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list []) = id []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkdf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract (decorate_prefix_list (a :: l)) =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke0"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map extract
  (([], a) :: map (incr [a]) (decorate_prefix_list l)) =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke1"><span class="nb">rewrite</span> map_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ([], a)
:: map extract
     (map (incr [a]) (decorate_prefix_list l)) =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke2"><span class="nb">change</span> (extract ([], a)) <span class="kr">with</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a
:: map extract
     (map (incr [a]) (decorate_prefix_list l)) =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke3">compose near (decorate_prefix_list l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a
:: (map extract ‚àò map (incr [a]))
     (decorate_prefix_list l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke4"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: map (extract ‚àò incr [a]) (decorate_prefix_list l) =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke5"><span class="nb">rewrite</span> extract_Z_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: map extract (decorate_prefix_list l) =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke6">fold_Z_all.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: map extract (decorate_prefix_list l) =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke7"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map extract (decorate_prefix_list l) = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: id l = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke8"><span class="kn">Lemma</span> <span class="nf">decorate_prefix_list_cojoin</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
    map cojoin ‚àò decorate_prefix_list =
      decorate_prefix_list ‚àò decorate_prefix_list (A := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map cojoin ‚àò decorate_prefix_list =
decorate_prefix_list ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chke9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
map cojoin ‚àò decorate_prefix_list =
decorate_prefix_list ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkea"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map cojoin ‚àò decorate_prefix_list =
decorate_prefix_list ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkeb">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map cojoin ‚àò decorate_prefix_list) l =
(decorate_prefix_list ‚àò decorate_prefix_list) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkec"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map cojoin (decorate_prefix_list l) =
decorate_prefix_list (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> cojoin_assoc_lemma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Traversable Functor Instance (Kleisli) *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Operation &lt;&lt;traverse_Z&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chked">#[export] <span class="kn">Instance</span> <span class="nf">Traverse_Z</span>: Traverse Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Traverse Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkee"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Traverse Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkef"><span class="nb">intros</span> G MapG PureG MultG A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z A -&gt; G (Z B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf0"><span class="nb">unfold</span> Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list A * A -&gt; G (list B * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf1"><span class="nb">intros</span> [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G (list B * B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pure pair &lt;‚ãÜ&gt; (traverse (T:=list) f l) &lt;‚ãÜ&gt; f a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Compatibility with &lt;&lt;map&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf2">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Map_Traverse</span>: Compat_Map_Traverse Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Traverse Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Traverse Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf4"><span class="nb">unfold</span> Compat_Map_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Map_Z = DerivedOperations.Map_Traverse Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf5">ext A B f [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Map_Z A B f (l, a) =
DerivedOperations.Map_Traverse Z A B f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id (map f l), f (id a)) =
pure pair (traverse f l) (f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf7"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f l, f a) = pure pair (traverse f l) (f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf8">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = traverse f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkf9"><span class="nb">rewrite</span> (map_to_traverse (T := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f l = traverse f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Specification for &lt;&lt;traverse_Z&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">traverse_Z_spec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>: <span class="kt">Type</span>}
    (<span class="nv">f</span>: A -&gt; G B)
    (<span class="nv">g</span>: C -&gt; G D).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkfa"><span class="kn">Lemma</span> <span class="nf">traverse_Z_spec</span>:
    traverse (T := Z) f =
      traverse_pair (traverse (T := list) f) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse_pair (traverse f) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkfb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse_pair (traverse f) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkfc"><span class="kn">Lemma</span> <span class="nf">traverse_Z_rw</span>: <span class="kr">forall</span> (<span class="nv">l</span>: list A) (<span class="nv">a</span>: A),
      traverse (T := Z) f (l, a) =
        (pure pair &lt;‚ãÜ&gt; (traverse (T:=list) f l) &lt;‚ãÜ&gt; f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
traverse f (l, a) = pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
traverse f (l, a) = pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Naturality *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">X</span> <span class="nv">Y</span>: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkfe"><span class="kn">Lemma</span> <span class="nf">traverse_Z_map</span>:
    <span class="kr">forall</span> (<span class="nv">h</span>:  X -&gt; list A) (<span class="nv">j</span>: Y -&gt; A),
    traverse (T := Z) f ‚àò map_pair h j =
      traverse_pair (traverse f ‚àò h) (f ‚àò j).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">h</span> : X -&gt; list A) (<span class="nv">j</span> : Y -&gt; A),
traverse f ‚àò map_pair h j =
traverse_pair (traverse f ‚àò h) (f ‚àò j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chkff"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">h</span> : X -&gt; list A) (<span class="nv">j</span> : Y -&gt; A),
traverse f ‚àò map_pair h j =
traverse_pair (traverse f ‚àò h) (f ‚àò j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk100"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X -&gt; list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚àò map_pair h j =
traverse_pair (traverse f ‚àò h) (f ‚àò j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk101">ext [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X -&gt; list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse f ‚àò map_pair h j) (x, y) =
traverse_pair (traverse f ‚àò h) (f ‚àò j) (x, y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk102"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X -&gt; list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse f (id (h x)) &lt;‚ãÜ&gt; f (j (id y)) =
pure pair &lt;‚ãÜ&gt; (traverse f ‚àò h) x &lt;‚ãÜ&gt; (f ‚àò j) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk103"><span class="kn">Lemma</span> <span class="nf">map_traverse_Z</span>:
    <span class="kr">forall</span> (<span class="nv">i</span>: B -&gt; X) (<span class="nv">j</span>: D -&gt; Y),
      map (map_pair i j) ‚àò traverse_pair f g =
        traverse_pair (map i ‚àò f) (map j ‚àò g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : B -&gt; X) (<span class="nv">j</span> : D -&gt; Y),
map (map_pair i j) ‚àò traverse_pair f g =
traverse_pair (map i ‚àò f) (map j ‚àò g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk104"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : B -&gt; X) (<span class="nv">j</span> : D -&gt; Y),
map (map_pair i j) ‚àò traverse_pair f g =
traverse_pair (map i ‚àò f) (map j ‚àò g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk105"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map_pair i j) ‚àò traverse_pair f g =
traverse_pair (map i ‚àò f) (map j ‚àò g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk106">ext [a c].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map_pair i j) ‚àò traverse_pair f g) (a, c) =
traverse_pair (map i ‚àò f) (map j ‚àò g) (a, c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk107"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map_pair i j) (traverse_pair f g (a, c)) =
traverse_pair (map i ‚óã f) (map j ‚óã g) (a, c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk108"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map_pair i j) (pure pair &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; g c) =
pure pair &lt;‚ãÜ&gt; map i (f a) &lt;‚ãÜ&gt; map j (g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk109"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map_pair i j)) (pure pair &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
g c = pure pair &lt;‚ãÜ&gt; map i (f a) &lt;‚ãÜ&gt; map j (g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk10a"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (map_pair i j))) (pure pair) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; g c =
pure pair &lt;‚ãÜ&gt; map i (f a) &lt;‚ãÜ&gt; map j (g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk10b"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map_pair i j) ‚àò pair) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; g c =
pure pair &lt;‚ãÜ&gt; map i (f a) &lt;‚ãÜ&gt; map j (g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk10c"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map_pair i j) ‚àò pair) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; g c =
map (precompose j) (pure pair &lt;‚ãÜ&gt; map i (f a)) &lt;‚ãÜ&gt; g c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk10d"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map_pair i j) ‚àò pair) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; g c =
map (compose (precompose j)) (pure pair) &lt;‚ãÜ&gt;
map i (f a) &lt;‚ãÜ&gt; g c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk10e"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map_pair i j) ‚àò pair) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; g c =
pure (precompose j ‚àò pair) &lt;‚ãÜ&gt; map i (f a) &lt;‚ãÜ&gt; g c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk10f"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map_pair i j) ‚àò pair) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; g c =
map (precompose i) (pure (precompose j ‚àò pair)) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; g c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk110"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; G D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>B -&gt; X</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>D -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map_pair i j) ‚àò pair) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; g c =
pure (precompose i (precompose j ‚àò pair)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
g c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">traverse_Z_spec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Interaction with &lt;&lt;incr&gt;&gt; and &lt;&lt;‚¶ø&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">traverse_Z_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}
    {<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** &lt;&lt;g: Z A -&gt; G B&gt;&gt; *)</span>
  <span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      (<span class="nv">g</span>: list A * A -&gt; G B) (* g: Z A -&gt; G B *)
      (<span class="nv">ctx</span>: list A)
      (<span class="nv">j</span>: list (list A * A))
      (<span class="nv">l</span>: list A)
      (<span class="nv">a</span>: A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk111"><span class="kn">Lemma</span> <span class="nf">traverse_Z_incr</span>:
      (traverse (T := Z) g ‚àò
         map_pair
         (app (decorate_prefix_list ctx) ‚àò
            map (incr ctx)) (incr ctx))
        (j, (l, a)) =
        pure (compose pair ‚àò app (A:=B))
          &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx)
          &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j
          &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk113"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk114"><span class="nb">rewrite</span> traverse_Z_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse_pair
  (traverse g
   ‚àò (app (decorate_prefix_list ctx) ‚àò map (incr ctx)))
  (g ‚àò incr ctx) (j, (l, a)) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk115"><span class="nb">rewrite</span> traverse_pair_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt;
(traverse g
 ‚àò (app (decorate_prefix_list ctx) ‚àò map (incr ctx)))
  j &lt;‚ãÜ&gt; (g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk116"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt;
traverse g
  (decorate_prefix_list ctx ++ map (incr ctx) j) &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk117"><span class="nb">rewrite</span> (traverse_list_app G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
 traverse g (map (incr ctx) j)) &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk118"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse g (map (incr ctx) j) &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk119"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse g (map (incr ctx) j) &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk11a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose pair) &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse g (map (incr ctx) j) &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk11b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose pair)) &lt;‚ãÜ&gt; pure (app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse g (map (incr ctx) j) &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk11c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse g (map (incr ctx) j) &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk11d">compose near j on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
(traverse g ‚àò map (incr ctx)) j &lt;‚ãÜ&gt;
(g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk11e"><span class="nb">rewrite</span> traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚àò incr ctx) j &lt;‚ãÜ&gt; (g ‚àò incr ctx) (l, a) =
pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk11f"><span class="kn">Lemma</span> <span class="nf">traverse_Z_incr2</span>:
      (traverse (T := Z) g ‚àò
         map_pair
         (app (decorate_prefix_list ctx) ‚àò
            map (incr ctx)) (incr ctx))
        (j, (l, a)) =
        map incr (traverse g (decorate_prefix_list ctx))
          &lt;‚ãÜ&gt; (pure pair
                 &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j
                 &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
 (g ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk120"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
 (g ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk121"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
 (g ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* rewrite traverse_Z_incr isn&#39;t working for some reason *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk122"><span class="nb">setoid_rewrite</span> traverse_Z_incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
 (g ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk123"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure incr &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
 (g ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk124"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure compose &lt;‚ãÜ&gt;
(pure incr &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j) &lt;‚ãÜ&gt;
(g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk125"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt;
 (pure incr &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx))) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
(g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk126"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure incr &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
(g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk127"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure (compose compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure incr &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
(g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk128"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure (compose ‚àò compose) &lt;‚ãÜ&gt;
(pure incr &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
(g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk129"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure compose &lt;‚ãÜ&gt; pure (compose ‚àò compose) &lt;‚ãÜ&gt;
pure incr &lt;‚ãÜ&gt; traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
(g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk12a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure (compose (compose ‚àò compose)) &lt;‚ãÜ&gt; pure incr &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk12b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk12c"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure (evalAt pair) &lt;‚ãÜ&gt;
(pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt;
 traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk12d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure compose &lt;‚ãÜ&gt; pure (evalAt pair) &lt;‚ãÜ&gt;
pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk12e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure (compose (evalAt pair)) &lt;‚ãÜ&gt;
pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk12f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a) =
pure (evalAt pair ‚àò (compose ‚àò compose ‚àò incr)) &lt;‚ãÜ&gt;
traverse g (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt; (g ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk130"><span class="kn">Lemma</span> <span class="nf">traverse_Z_incr3</span>:
      (traverse (T := Z) g ‚àò
         map_pair
         (app (decorate_prefix_list ctx) ‚àò
            map (incr ctx)) (incr ctx))
        (j, (l, a)) =

        map incr (traverse g (decorate_prefix_list ctx))
          &lt;‚ãÜ&gt; (traverse (T := Z) (g ‚¶ø ctx) (j, (l, a))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) (j, (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk131"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) (j, (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk132"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse g
 ‚àò map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx)) (j, (l, a)) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) (j, (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk133"><span class="nb">setoid_rewrite</span> traverse_Z_incr2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse (g ‚¶ø ctx) j &lt;‚ãÜ&gt;
 (g ‚¶ø ctx) (l, a)) =
map incr (traverse g (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (g ‚¶ø ctx) (j, (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** &lt;&lt;f: A -&gt; G B&gt;&gt; *)</span>
  <span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk134"><span class="kn">Lemma</span> <span class="nf">traverse_Z_incr_one</span>
    {<span class="nv">f</span>: A -&gt; G B} {<span class="nv">a</span>: A}:
    traverse (T := Z) f ‚àò incr [a] =
      ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse (T := Z) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚àò incr [a] =
ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk135"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚àò incr [a] =
ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk136"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚àò incr [a] =
ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk137">ext [l&#39; a&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse f ‚àò incr [a]) (l&#39;, a&#39;) =
(ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse f)
  (l&#39;, a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk138"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (incr [a] (l&#39;, a&#39;)) =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f (l&#39;, a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk139"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l&#39;) &lt;‚ãÜ&gt;
f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* lhs *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk13a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; (pure cons &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk13b"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; (pure compose &lt;‚ãÜ&gt; pure pair) &lt;‚ãÜ&gt;
pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk13c"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt;
f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk13d"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk13e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose ‚àò compose) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk13f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk140"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk141"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt; (pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l&#39;) &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk142"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; (pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a)) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk143"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk144"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose) &lt;‚ãÜ&gt;
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk145"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; pure compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk146"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt; (pure compose &lt;‚ãÜ&gt; pure compose) &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk147"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk148"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (compose compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk149"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (compose ‚àò compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk14a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure ((compose ‚àò compose) compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk14b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure ((compose ‚àò compose) compose compose) &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk14c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure ((compose ‚àò compose) compose compose compose) &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk14d"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure
  ((compose ‚àò compose) compose compose compose compose) &lt;‚ãÜ&gt;
pure (map_fst ‚óã cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk14e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure
  ((compose ‚àò compose) compose compose compose compose
     (map_fst ‚óã cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk14f"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (evalAt pair) &lt;‚ãÜ&gt;
(pure
   ((compose ‚àò compose) compose compose compose
      compose (map_fst ‚óã cons)) &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk150"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure compose &lt;‚ãÜ&gt; pure (evalAt pair) &lt;‚ãÜ&gt;
pure
  ((compose ‚àò compose) compose compose compose compose
     (map_fst ‚óã cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt;
f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk151"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure (compose (evalAt pair)) &lt;‚ãÜ&gt;
pure
  ((compose ‚àò compose) compose compose compose compose
     (map_fst ‚óã cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l&#39; &lt;‚ãÜ&gt;
f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk152"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) pair cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39; =
pure
  (evalAt pair
   ‚àò (compose ‚àò compose) compose compose compose
       compose (map_fst ‚óã cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f l&#39; &lt;‚ãÜ&gt; f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk153"><span class="kn">Lemma</span> <span class="nf">traverse_preincr_one</span>
    {<span class="nv">f</span>: A -&gt; G B} {<span class="nv">a</span>: A}:
    (traverse (T := Z) f) ‚¶ø [a] =
      ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse (T := Z) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚¶ø [a] =
ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk154"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚¶ø [a] =
ap G (pure (map_fst ‚àò cons) &lt;‚ãÜ&gt; f a) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> traverse_Z_incr_one.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk155"><span class="kn">Lemma</span> <span class="nf">traverse_preincr</span>
    {<span class="nv">f</span>: A -&gt; G B} {<span class="nv">ctx</span>: list A}:
    (traverse (T := Z) f) ‚¶ø ctx =
      ap G (map incr (traverse (T := list) f ctx)) ‚àò traverse (T := Z) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚¶ø ctx =
ap G (map incr (traverse f ctx)) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk156"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚¶ø ctx =
ap G (map incr (traverse f ctx)) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk157"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚¶ø ctx =
ap G (map incr (traverse f ctx)) ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk158">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse f ‚¶ø ctx) (l, a) =
(ap G (map incr (traverse f ctx)) ‚àò traverse f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk159"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(traverse f ‚¶ø ctx) (l, a) =
map incr (traverse f ctx) &lt;‚ãÜ&gt; traverse f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk15a">unfold_ops @Traverse_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">X</span> : list A * A =&gt;
  <span class="kr">let</span> (<span class="nv">a</span>, b) := X <span class="kr">in</span>
  pure pair &lt;‚ãÜ&gt; traverse f a &lt;‚ãÜ&gt; f b) ‚¶ø ctx) (l, a) =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk15b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse f (ctx ‚óè l) &lt;‚ãÜ&gt; f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk15c"><span class="nb">change</span> (ctx ‚óè l) <span class="kr">with</span> (ctx ++ l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse f (ctx ++ l) &lt;‚ãÜ&gt; f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk15d"><span class="nb">rewrite</span> (traverse_list_app G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; traverse f l) &lt;‚ãÜ&gt;
f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk15e"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk15f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk160"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose pair) &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk161"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose pair)) &lt;‚ãÜ&gt; pure (app (A:=B)) &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk162"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
map incr (traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk163"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure incr &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk164"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; (pure incr &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l) &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk165"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; (pure incr &lt;‚ãÜ&gt; traverse f ctx)) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk166"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure incr &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk167"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (compose compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure incr &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk168"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (compose ‚àò compose) &lt;‚ãÜ&gt;
(pure incr &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk169"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; pure (compose ‚àò compose) &lt;‚ãÜ&gt;
pure incr &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk16a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (compose (compose ‚àò compose)) &lt;‚ãÜ&gt; pure incr &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; 
f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk16b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk16c"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (evalAt pair) &lt;‚ãÜ&gt;
(pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk16d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; pure (evalAt pair) &lt;‚ãÜ&gt;
pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk16e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (compose (evalAt pair)) &lt;‚ãÜ&gt;
pure (compose ‚àò compose ‚àò incr) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk16f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò app (A:=B)) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (evalAt pair ‚àò (compose ‚àò compose ‚àò incr)) &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">traverse_Z_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Typeclass Instance *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk170">#[export] <span class="kn">Instance</span>: TraversableFunctor Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TraversableFunctor Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk171"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TraversableFunctor Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk172"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, traverse id = id</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G1)
  (<span class="nv">Pure_G</span> : Pure G1) (<span class="nv">Mult_G</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G0</span> : Map G2)
  (<span class="nv">Pure_G0</span> : Pure G2) (<span class="nv">Mult_G0</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; G2 C) (<span class="nv">f</span> : A -&gt; G1 B),
map (traverse g) ‚àò traverse f = traverse (kc2 g f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G1 B),
œï (Z B) ‚àò traverse f = traverse (œï B ‚àò f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk173">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, traverse id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk174"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk175">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse id (l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk176"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair (traverse id l) (id a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> trf_traverse_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk177">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G1)
  (<span class="nv">Pure_G</span> : Pure G1) (<span class="nv">Mult_G</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G0</span> : Map G2)
  (<span class="nv">Pure_G0</span> : Pure G2) (<span class="nv">Mult_G0</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; G2 C) (<span class="nv">f</span> : A -&gt; G1 B),
map (traverse g) ‚àò traverse f = traverse (kc2 g f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk178"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g) ‚àò traverse f = traverse (kc2 g f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk179">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (traverse g) ‚àò traverse f) (l, a) =
traverse (kc2 g f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk17a"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g) (traverse f (l, a)) =
traverse (kc2 g f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk17b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g) (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a) =
pure pair &lt;‚ãÜ&gt; traverse (kc2 g f) l &lt;‚ãÜ&gt; kc2 g f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk17c"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (traverse g))) (pure pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt; traverse (kc2 g f) l &lt;‚ãÜ&gt; kc2 g f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk17d"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a = pure pair &lt;‚ãÜ&gt; traverse (kc2 g f) l &lt;‚ãÜ&gt; kc2 g f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk17e"><span class="nb">rewrite</span> &lt;- (trf_traverse_traverse _ _ _ g f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
pure pair &lt;‚ãÜ&gt; (map (traverse g) ‚àò traverse f) l &lt;‚ãÜ&gt;
kc2 g f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk17f"><span class="nb">unfold</span> kc2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
pure pair &lt;‚ãÜ&gt; (map (traverse g) ‚àò traverse f) l &lt;‚ãÜ&gt;
(map g ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk180"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
pure pair &lt;‚ãÜ&gt; (map (traverse g) ‚àò traverse f) l &lt;‚ãÜ&gt;
map g (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk181"><span class="kp">repeat</span> <span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
map (ap G2)
  (map (ap G2) (pure pair) &lt;‚ãÜ&gt;
   (map (traverse g) ‚àò traverse f) l) &lt;‚ãÜ&gt; map g (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk182">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
map (ap G2)
  (map (ap G2) (pure (pure pair)) &lt;‚ãÜ&gt;
   (map (traverse g) ‚àò traverse f) l) &lt;‚ãÜ&gt; map g (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk183"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
map (precompose g)
  (map (ap G2)
     (map (ap G2) (pure (pure pair)) &lt;‚ãÜ&gt;
      (map (traverse g) ‚àò traverse f) l)) &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk184"><span class="kp">repeat</span> <span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
map (compose (precompose g))
  (map (compose (ap G2))
     (map (ap G2) (pure (pure pair)))) &lt;‚ãÜ&gt;
(map (traverse g) ‚àò traverse f) l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk185"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">5</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
map (compose (precompose g))
  (map (compose (ap G2))
     (map (ap G2) (pure (pure pair)))) &lt;‚ãÜ&gt;
map (traverse g) (traverse f l) &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk186"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a =
map (precompose (traverse g))
  (map (compose (precompose g))
     (map (compose (ap G2))
        (map (ap G2) (pure (pure pair))))) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk187">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) &lt;‚ãÜ&gt; traverse f l =
map (precompose (traverse g))
  (map (compose (precompose g))
     (map (compose (ap G2))
        (map (ap G2) (pure (pure pair))))) &lt;‚ãÜ&gt;
traverse f l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk188">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) =
map (precompose (traverse g))
  (map (compose (precompose g))
     (map (compose (ap G2))
        (map (ap G2) (pure (pure pair)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk189"><span class="kp">repeat</span> <span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (traverse g) ‚àò pair) =
pure
  (precompose (traverse g)
     (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk18a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G1 B),
œï (Z B) ‚àò traverse f = traverse (œï B ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk18b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (Z B) ‚àò traverse f = traverse (œï B ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk18c">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(œï (Z B) ‚àò traverse f) (l, a) =
traverse (œï B ‚àò f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk18d"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (Z B) (traverse f (l, a)) =
traverse (œï B ‚àò f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk18e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (Z B) (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a) =
pure pair &lt;‚ãÜ&gt; traverse (œï B ‚àò f) l &lt;‚ãÜ&gt; (œï B ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk18f"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (list B -&gt; B -&gt; Z B) (pure pair) &lt;‚ãÜ&gt;
œï (list B) (traverse f l) &lt;‚ãÜ&gt; œï B (f a) =
pure pair &lt;‚ãÜ&gt; traverse (œï B ‚àò f) l &lt;‚ãÜ&gt; (œï B ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk190"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; œï (list B) (traverse f l) &lt;‚ãÜ&gt; œï B (f a) =
pure pair &lt;‚ãÜ&gt; traverse (œï B ‚àò f) l &lt;‚ãÜ&gt; (œï B ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk191">compose near l on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; (œï (list B) ‚àò traverse f) l &lt;‚ãÜ&gt;
œï B (f a) =
pure pair &lt;‚ãÜ&gt; traverse (œï B ‚àò f) l &lt;‚ãÜ&gt; (œï B ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk192"><span class="nb">rewrite</span> trf_traverse_morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse (œï B ‚àò f) l &lt;‚ãÜ&gt; œï B (f a) =
pure pair &lt;‚ãÜ&gt; traverse (œï B ‚àò f) l &lt;‚ãÜ&gt; (œï B ‚àò f) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Decoration Commutes with Traversals *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">commute_law</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Categorical.Monad (Return, ret).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{G: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
    `{Map G} `{Mult G} `{Pure G}
    `{! Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}
    {<span class="nv">f</span>: A -&gt; G B}
    {<span class="nv">Hci</span>: <span class="kr">forall</span> (<span class="nv">a</span>: A),  IdempotentCenter G B (f a)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk193"><span class="kn">Lemma</span> <span class="nf">traverse_incr_one_spec</span>:
    <span class="kr">forall</span> (<span class="nv">a</span>: A) (<span class="nv">x</span>: list A * A ),
      traverse (T := Z) f (incr [a] x) =
        map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse (T := Z) f x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">x</span> : list A * A),
traverse f (incr [a] x) =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk194"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">x</span> : list A * A),
traverse f (incr [a] x) =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk195"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (incr [a] x) =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk196"><span class="nb">destruct</span> x <span class="kr">as</span> [ctx xa].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (incr [a] (ctx, xa)) =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk197"><span class="nb">unfold</span> incr <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ([a] ‚óè ctx, xa) =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk198"><span class="nb">change</span> ([<span class="nl">?a</span>] ‚óè <span class="nl">?l</span>) <span class="kr">with</span> (a :: l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: ctx, xa) =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk199"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse f (a :: ctx) &lt;‚ãÜ&gt; f xa =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk19a"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt;
f xa = map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk19b"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; (pure cons &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f xa =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk19c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair) &lt;‚ãÜ&gt; (pure cons &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f xa =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk19d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose pair) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk19e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose pair)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f xa =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk19f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa = map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f (ctx, xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a0"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a1"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure compose &lt;‚ãÜ&gt; map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a2"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
map (precompose (incr ‚àò ret)) (pure compose) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a3"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure (precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a4"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure compose &lt;‚ãÜ&gt;
(pure (precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a6"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure (compose compose) &lt;‚ãÜ&gt;
pure (precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure (compose ‚àò precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a8"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure (evalAt pair) &lt;‚ãÜ&gt;
(pure (compose ‚àò precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt;
 f a) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1a9"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure compose &lt;‚ãÜ&gt; pure (evalAt pair) &lt;‚ãÜ&gt;
pure (compose ‚àò precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1aa"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure (compose (evalAt pair)) &lt;‚ãÜ&gt;
pure (compose ‚àò precompose (incr ‚àò ret) compose) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ab"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>xa</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose pair ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f xa =
pure
  (evalAt pair
   ‚àò (compose ‚àò precompose (incr ‚àò ret) compose)) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f xa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ac"><span class="kn">Lemma</span> <span class="nf">decorate_commute_cons</span>:
    <span class="kr">forall</span> (<span class="nv">a</span>: A) (<span class="nv">l</span>: list (list A * A)),
      l &lt;&gt; nil -&gt;
      traverse (T := list)
        (traverse (T := Z) f)
        (map (F := list) (A := Z A) (B := Z A)
           (incr [a]) l) =
        map (F := G)
          (map (F := list) (A := Z B) (B := Z B)
             ‚àò incr ‚àò ret (T := list)) (f a) &lt;‚ãÜ&gt;
          traverse (T := list) (traverse (T := Z) f) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list (list A * A)),
l &lt;&gt; [] -&gt;
traverse (traverse f) (map (incr [a]) l) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list (list A * A)),
l &lt;&gt; [] -&gt;
traverse (traverse f) (map (incr [a]) l) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ae">introv Hneqnil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Hneqnil</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) l) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1af"><span class="nb">induction</span> l <span class="kr">as</span> [| x xs IHxs ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hneqnil</var><span class="hyp-type"><b>: </b><span>[] &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) []) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk1b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Hneqnil</var><span class="hyp-type"><b>: </b><span>x :: xs &lt;&gt; []</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>xs &lt;&gt; [] -&gt;
traverse (traverse f) (map (incr [a]) xs) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) xs</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk1b0"><hr></label><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) (x :: xs)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: xs)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hneqnil</var><span class="hyp-type"><b>: </b><span>[] &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) []) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Hneqnil</var><span class="hyp-type"><b>: </b><span>x :: xs &lt;&gt; []</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>xs &lt;&gt; [] -&gt;
traverse (traverse f) (map (incr [a]) xs) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) (x :: xs)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: xs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b3"><span class="nb">clear</span> Hneqnil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>xs &lt;&gt; [] -&gt;
traverse (traverse f) (map (incr [a]) xs) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) (x :: xs)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b4"><span class="nb">destruct</span> xs <span class="kr">as</span> [| y ys ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>[] &lt;&gt; [] -&gt;
traverse (traverse f) (map (incr [a]) []) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) [x]) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [x]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>y :: ys &lt;&gt; [] -&gt;
traverse (traverse f)
  (map (incr [a]) (y :: ys)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (y :: ys)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk1b5"><hr></label><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) (x :: y :: ys)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: y :: ys)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>[] &lt;&gt; [] -&gt;
traverse (traverse f) (map (incr [a]) []) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) [x]) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b7"><span class="nb">clear</span> IHxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) [x]) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b8"><span class="nb">destruct</span> x <span class="kr">as</span> [ctx b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) [(ctx, b)]) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1b9"><span class="nb">rewrite</span> map_list_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) [incr [a] (ctx, b)] =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ba"><span class="nb">change</span> ([<span class="nl">?a</span>]) <span class="kr">with</span> (ret (T := list) a) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (ret (incr [a] (ctx, b))) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1bb"><span class="nb">rewrite</span> (traverse_list_one G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ret (traverse f (incr [a] (ctx, b))) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1bc"><span class="nb">unfold</span> incr <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ret (traverse f ([a] ‚óè ctx, b)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1bd"><span class="nb">change</span> ([<span class="nl">?a</span>] ‚óè <span class="nl">?l</span>) <span class="kr">with</span> (a :: l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ret (traverse f (a :: ctx, b)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1be"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ret (pure pair &lt;‚ãÜ&gt; traverse f (a :: ctx) &lt;‚ãÜ&gt; f b) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1bf"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose ret)
  (pure pair &lt;‚ãÜ&gt; traverse f (a :: ctx)) &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c0"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose ret)) (pure pair) &lt;‚ãÜ&gt;
traverse f (a :: ctx) &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c1"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f (a :: ctx) &lt;‚ãÜ&gt;
f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c2"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose ret ‚àò pair) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c3"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose ret ‚àò pair) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c4"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair)) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose (compose ret ‚àò pair)) &lt;‚ãÜ&gt;
pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c6"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (compose ret ‚àò pair))) &lt;‚ãÜ&gt;
pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) [(ctx, b)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c8"><span class="nb">change</span> ([<span class="nl">?x</span>]) <span class="kr">with</span> (ret (T := list) x) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (ret (ctx, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1c9"><span class="nb">rewrite</span> (traverse_list_one G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
map ret (traverse f (ctx, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ca"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
map ret (pure pair &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1cb"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(map (compose ret) (pure pair &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt;
 f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1cc"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(map (compose (compose ret)) (pure pair) &lt;‚ãÜ&gt;
 traverse f ctx &lt;‚ãÜ&gt; f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1cd"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ce"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure compose &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; 
f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1cf"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
map (precompose (map ‚àò incr ‚àò ret)) (pure compose) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; (pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt;
f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d0"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure (precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
(pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx) &lt;‚ãÜ&gt; 
f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d1"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure compose &lt;‚ãÜ&gt;
(pure (precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d2"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d3"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure (compose compose) &lt;‚ãÜ&gt;
pure (precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d4"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure (compose ‚àò precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt;
f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d5"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure (evalAt (compose ret ‚àò pair)) &lt;‚ãÜ&gt;
(pure
   (compose ‚àò precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt;
 f a) &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d6"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure compose &lt;‚ãÜ&gt; pure (evalAt (compose ret ‚àò pair)) &lt;‚ãÜ&gt;
pure (compose ‚àò precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure (compose (evalAt (compose ret ‚àò pair))) &lt;‚ãÜ&gt;
pure (compose ‚àò precompose (map ‚àò incr ‚àò ret) compose) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d8"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose ret ‚àò pair) ‚àò cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f ctx &lt;‚ãÜ&gt; f b =
pure
  (evalAt (compose ret ‚àò pair)
   ‚àò (compose ‚àò precompose (map ‚àò incr ‚àò ret) compose)) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f ctx &lt;‚ãÜ&gt; f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1d9">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>y :: ys &lt;&gt; [] -&gt;
traverse (traverse f)
  (map (incr [a]) (y :: ys)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (y :: ys)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) (x :: y :: ys)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: y :: ys)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1da"><span class="nb">specialize</span> (IHxs <span class="kp">ltac</span>:(<span class="bp">discriminate</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f)
  (map (incr [a]) (y :: ys)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (y :: ys)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) (x :: y :: ys)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: y :: ys)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1db"><span class="nb">remember</span> (y :: ys) <span class="kr">as</span> rest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f) (map (incr [a]) (x :: rest)) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1dc"><span class="nb">rewrite</span> map_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (traverse f)
  (incr [a] x :: map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1dd"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; traverse f (incr [a] x) &lt;‚ãÜ&gt;
traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1de"><span class="nb">rewrite</span> traverse_incr_one_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt;
(map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f x) &lt;‚ãÜ&gt;
traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1df"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e0"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose cons) &lt;‚ãÜ&gt; map (incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e1"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose (incr ‚àò ret)) (pure (compose cons)) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e2"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) (map (incr [a]) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e3"><span class="nb">rewrite</span> IHxs; <span class="nb">clear</span> IHxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt;
(map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
 traverse (traverse f) rest) =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e4"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt;
(pure (precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
 traverse f x) &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure (precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e6"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; (pure compose &lt;‚ãÜ&gt; pure compose) &lt;‚ãÜ&gt;
pure (precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; 
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose compose) &lt;‚ãÜ&gt;
pure (precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; 
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e8"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose compose)) &lt;‚ãÜ&gt;
pure (precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; 
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1e9"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose compose
   ‚àò precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ea"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose (map ‚àò incr ‚àò ret))
  (pure
     (compose compose
      ‚àò precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt;
   f a &lt;‚ãÜ&gt; traverse f x) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1eb"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (precompose (map ‚àò incr ‚àò ret)))
  (pure
     (compose compose
      ‚àò precompose (incr ‚àò ret) (compose cons)) &lt;‚ãÜ&gt;
   f a) &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ec"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (compose (compose (precompose (map ‚àò incr ‚àò ret))))
  (pure
     (compose compose
      ‚àò precompose (incr ‚àò ret) (compose cons))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ed"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (precompose (map ‚àò incr ‚àò ret))
   ‚àò (compose compose
      ‚àò precompose (incr ‚àò ret) (compose cons))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ee"><span class="nb">rewrite</span> (ap_flip1 (rhs := f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map flip
  (pure
     (compose (precompose (map ‚àò incr ‚àò ret))
      ‚àò (compose compose
         ‚àò precompose (incr ‚àò ret) (compose cons))) &lt;‚ãÜ&gt;
   f a) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ef"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose flip)
  (pure
     (compose (precompose (map ‚àò incr ‚àò ret))
      ‚àò (compose compose
         ‚àò precompose (incr ‚àò ret) (compose cons)))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f0"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
   ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
      ‚àò (compose compose
         ‚àò precompose (incr ‚àò ret) (compose cons)))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f1"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map double_input
  (pure
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f2"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
traverse (traverse f) (x :: rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f3"><span class="nb">rewrite</span> (traverse_list_cons G (Z A) (Z B) (traverse f) x rest).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
 traverse (traverse f) rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f4"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure compose &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; traverse f x) &lt;‚ãÜ&gt;
traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; map (map ‚àò incr ‚àò ret) (f a)) &lt;‚ãÜ&gt;
pure cons &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f6"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure (compose compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f8"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure (compose ‚àò compose) &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1f9"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure (evalAt cons) &lt;‚ãÜ&gt;
(pure (compose ‚àò compose) &lt;‚ãÜ&gt;
 map (map ‚àò incr ‚àò ret) (f a)) &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1fa"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure compose &lt;‚ãÜ&gt; pure (evalAt cons) &lt;‚ãÜ&gt;
pure (compose ‚àò compose) &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1fb"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure (compose (evalAt cons)) &lt;‚ãÜ&gt;
pure (compose ‚àò compose) &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1fc"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure (evalAt cons ‚àò (compose ‚àò compose)) &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f a) &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt;
traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1fd"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
map (precompose (map ‚àò incr ‚àò ret))
  (pure (evalAt cons ‚àò (compose ‚àò compose))) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1fe"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>list A * A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list (list A * A)</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      ‚àò (compose (precompose (map ‚àò incr ‚àò ret))
         ‚àò (compose compose
            ‚àò precompose (incr ‚àò ret) (compose cons))))) &lt;‚ãÜ&gt;
f a &lt;‚ãÜ&gt; traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest =
pure
  (precompose (map ‚àò incr ‚àò ret)
     (evalAt cons ‚àò (compose ‚àò compose))) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt;
traverse f x &lt;‚ãÜ&gt; traverse (traverse f) rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk1ff"><span class="kn">Theorem</span> <span class="nf">decorate_commute</span>:
    map (F := G) (decorate_prefix_list) ‚àò traverse (T := list) f =
      traverse (T := list) (traverse (T := Z) f) ‚àò decorate_prefix_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list ‚àò traverse f =
traverse (traverse f) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk200"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list ‚àò traverse f =
traverse (traverse f) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk201"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list ‚àò traverse f =
traverse (traverse f) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk202"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list ‚óã traverse f =
traverse (traverse f) ‚óã decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk203">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f l) =
traverse (traverse f) (decorate_prefix_list l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk204"><span class="nb">induction</span> l <span class="kr">as</span> [| x xs IHxs ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk205" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f xs) =
traverse (traverse f) (decorate_prefix_list xs)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk205"><hr></label><div class="goal-conclusion">map decorate_prefix_list (traverse f (x :: xs)) =
traverse (traverse f) (decorate_prefix_list (x :: xs))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk206">- <span class="c">(* LHS *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk207"><span class="nb">rewrite</span> traverse_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (pure []) =
traverse (traverse f) (decorate_prefix_list [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk208"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (decorate_prefix_list []) =
traverse (traverse f) (decorate_prefix_list [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk209"><span class="nb">rewrite</span> decorate_prefix_list_rw_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] =
traverse (traverse f) (decorate_prefix_list [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk20a"><span class="nb">rewrite</span> traverse_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* Done *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk20b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f xs) =
traverse (traverse f) (decorate_prefix_list xs)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f (x :: xs)) =
traverse (traverse f) (decorate_prefix_list (x :: xs))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk20c"><span class="nb">destruct</span> xs <span class="kr">as</span> [| y ys ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f [x]) =
traverse (traverse f) (decorate_prefix_list [x])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk20d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f (y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (y :: ys))</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk20d"><hr></label><div class="goal-conclusion">map decorate_prefix_list (traverse f (x :: y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (x :: y :: ys))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk20e">{ <span class="c">(* LHS *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f [x]) =
traverse (traverse f) (decorate_prefix_list [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk20f"><span class="nb">change</span> [x] <span class="kr">with</span> (ret (T := list) x) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f (ret x)) =
traverse (traverse f) (decorate_prefix_list [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk210"><span class="nb">rewrite</span> (traverse_list_one G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (map ret (f x)) =
traverse (traverse f) (decorate_prefix_list [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk211">compose near (f x) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map decorate_prefix_list ‚àò map ret) (f x) =
traverse (traverse f) (decorate_prefix_list [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk212"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
traverse (traverse f) (decorate_prefix_list [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk213"><span class="nb">rewrite</span> decorate_prefix_list_rw_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
traverse (traverse f) [([], x)]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk214"><span class="nb">change</span> [<span class="nl">?pair</span>] <span class="kr">with</span> (ret (T := list) pair) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
traverse (traverse f) (ret ([], x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk215"><span class="nb">rewrite</span> (traverse_list_one G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
map ret (traverse f ([], x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk216"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
map ret (pure pair &lt;‚ãÜ&gt; traverse f [] &lt;‚ãÜ&gt; f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk217"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
map (compose ret) (pure pair &lt;‚ãÜ&gt; traverse f []) &lt;‚ãÜ&gt;
f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk218"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
map (compose (compose ret)) (pure pair) &lt;‚ãÜ&gt;
traverse f [] &lt;‚ãÜ&gt; f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk219"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; traverse f [] &lt;‚ãÜ&gt; f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk21a"><span class="nb">rewrite</span> traverse_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
pure (compose ret ‚àò pair) &lt;‚ãÜ&gt; pure [] &lt;‚ãÜ&gt; f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk21b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (decorate_prefix_list ‚àò ret) (f x) =
pure ((compose ret ‚àò pair) []) &lt;‚ãÜ&gt; f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk21c"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f []) =
traverse (traverse f) (decorate_prefix_list [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (decorate_prefix_list ‚àò ret) &lt;‚ãÜ&gt; f x =
pure ((compose ret ‚àò pair) []) &lt;‚ãÜ&gt; f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk21d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f (y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (y :: ys))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f (x :: y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (x :: y :: ys))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk21e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f (y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (y :: ys))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f (x :: y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (x :: y :: ys))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk21f"><span class="nb">remember</span> (y :: ys) <span class="kr">as</span> rest.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list (traverse f (x :: rest)) =
traverse (traverse f)
  (decorate_prefix_list (x :: rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk220"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map decorate_prefix_list
  (pure cons &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt; traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list (x :: rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk221"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose decorate_prefix_list) (pure cons &lt;‚ãÜ&gt; f x) &lt;‚ãÜ&gt;
traverse f rest =
traverse (traverse f)
  (decorate_prefix_list (x :: rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk222"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose decorate_prefix_list))
  (pure cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt; traverse f rest =
traverse (traverse f)
  (decorate_prefix_list (x :: rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk223"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
traverse (traverse f)
  (decorate_prefix_list (x :: rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
        <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk224"><span class="nb">rewrite</span> decorate_prefix_list_rw_cons; fold_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
traverse (traverse f)
  (([], x)
   :: map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk225"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure cons &lt;‚ãÜ&gt; traverse f ([], x) &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk226"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure cons &lt;‚ãÜ&gt; (pure pair &lt;‚ãÜ&gt; traverse f [] &lt;‚ãÜ&gt; f x) &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk227"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk228"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose cons) &lt;‚ãÜ&gt; (pure pair &lt;‚ãÜ&gt; traverse f []) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk229"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt; pure (compose cons) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f [] &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk22a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose (compose cons)) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse f [] &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk22b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose cons ‚àò pair) &lt;‚ãÜ&gt; traverse f [] &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk22c"><span class="nb">rewrite</span> traverse_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose cons ‚àò pair) &lt;‚ãÜ&gt; pure [] &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk22d"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure ((compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f)
  (map (incr [x]) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk22e"><span class="nb">rewrite</span> (decorate_commute_cons x (decorate_prefix_list rest)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure ((compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
(map (map ‚àò incr ‚àò ret) (f x) &lt;‚ãÜ&gt;
 traverse (traverse f) (decorate_prefix_list rest))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk22f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk22f"><hr></label><div class="goal-conclusion">decorate_prefix_list rest &lt;&gt; []</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* where prior lemma gets used! *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk230"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list rest &lt;&gt; []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk231"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f (y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (y :: ys))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decorate_prefix_list (y :: ys) &lt;&gt; []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk232"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f (y :: ys)) =
traverse (traverse f)
  (decorate_prefix_list (y :: ys))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([], y) :: map (incr [y]) (decorate_prefix_list ys) &lt;&gt;
[]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk233">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure ((compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
(map (map ‚àò incr ‚àò ret) (f x) &lt;‚ãÜ&gt;
 traverse (traverse f) (decorate_prefix_list rest))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk234"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt;
(pure ((compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x) &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f x) &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk235"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure ((compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f x) &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk236"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose compose) &lt;‚ãÜ&gt;
pure ((compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f x) &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk237"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose ‚àò (compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
map (map ‚àò incr ‚àò ret) (f x) &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk238"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose ‚àò (compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
(pure (map ‚àò incr ‚àò ret) &lt;‚ãÜ&gt; f x) &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk239"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt;
(pure (compose ‚àò (compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x) &lt;‚ãÜ&gt;
pure (map ‚àò incr ‚àò ret) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk23a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk23a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (compose ‚àò (compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
pure (map ‚àò incr ‚àò ret) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk23b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose compose) &lt;‚ãÜ&gt;
pure (compose ‚àò (compose cons ‚àò pair) []) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
pure (map ‚àò incr ‚àò ret) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk23c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose ‚àò (compose ‚àò (compose cons ‚àò pair) [])) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; pure (map ‚àò incr ‚àò ret) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk23d"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (evalAt (map ‚àò incr ‚àò ret)) &lt;‚ãÜ&gt;
(pure (compose ‚àò (compose ‚àò (compose cons ‚àò pair) [])) &lt;‚ãÜ&gt;
 f x) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk23e"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt; pure (evalAt (map ‚àò incr ‚àò ret)) &lt;‚ãÜ&gt;
pure (compose ‚àò (compose ‚àò (compose cons ‚àò pair) [])) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk23f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose (evalAt (map ‚àò incr ‚àò ret))) &lt;‚ãÜ&gt;
pure (compose ‚àò (compose ‚àò (compose cons ‚àò pair) [])) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk240"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure
  (evalAt (map ‚àò incr ‚àò ret)
   ‚àò (compose ‚àò (compose ‚àò (compose cons ‚àò pair) []))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk241"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
map double_input
  (pure
     (evalAt (map ‚àò incr ‚àò ret)
      ‚àò (compose
         ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk242"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure
  (double_input
     (evalAt (map ‚àò incr ‚àò ret)
      ‚àò (compose
         ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk243"><span class="nb">rewrite</span> &lt;- IHxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure
  (double_input
     (evalAt (map ‚àò incr ‚àò ret)
      ‚àò (compose
         ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; map decorate_prefix_list (traverse f rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk244"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure
  (double_input
     (evalAt (map ‚àò incr ‚àò ret)
      ‚àò (compose
         ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt;
(pure decorate_prefix_list &lt;‚ãÜ&gt; traverse f rest)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk245"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt;
(pure
   (double_input
      (evalAt (map ‚àò incr ‚àò ret)
       ‚àò (compose
          ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
 f x) &lt;‚ãÜ&gt; pure decorate_prefix_list &lt;‚ãÜ&gt;
traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk246"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure
  (double_input
     (evalAt (map ‚àò incr ‚àò ret)
      ‚àò (compose
         ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; pure decorate_prefix_list &lt;‚ãÜ&gt; traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk247"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose compose) &lt;‚ãÜ&gt;
pure
  (double_input
     (evalAt (map ‚àò incr ‚àò ret)
      ‚àò (compose
         ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; pure decorate_prefix_list &lt;‚ãÜ&gt; traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk248"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure
  (compose
   ‚àò double_input
       (evalAt (map ‚àò incr ‚àò ret)
        ‚àò (compose
           ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; pure decorate_prefix_list &lt;‚ãÜ&gt; traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk249"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (evalAt decorate_prefix_list) &lt;‚ãÜ&gt;
(pure
   (compose
    ‚àò double_input
        (evalAt (map ‚àò incr ‚àò ret)
         ‚àò (compose
            ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
 f x) &lt;‚ãÜ&gt; traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk24a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk24a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure compose &lt;‚ãÜ&gt; pure (evalAt decorate_prefix_list) &lt;‚ãÜ&gt;
pure
  (compose
   ‚àò double_input
       (evalAt (map ‚àò incr ‚àò ret)
        ‚àò (compose
           ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk24b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure (compose (evalAt decorate_prefix_list)) &lt;‚ãÜ&gt;
pure
  (compose
   ‚àò double_input
       (evalAt (map ‚àò incr ‚àò ret)
        ‚àò (compose
           ‚àò (compose ‚àò (compose cons ‚àò pair) [])))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk24c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ys, rest</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heqrest</var><span class="hyp-type"><b>: </b><span>rest = y :: ys</span></span></span><br><span><var>IHxs</var><span class="hyp-type"><b>: </b><span>map decorate_prefix_list (traverse f rest) =
traverse (traverse f)
  (decorate_prefix_list rest)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose decorate_prefix_list ‚àò cons) &lt;‚ãÜ&gt; f x &lt;‚ãÜ&gt;
traverse f rest =
pure
  (evalAt decorate_prefix_list
   ‚àò (compose
      ‚àò double_input
          (evalAt (map ‚àò incr ‚àò ret)
           ‚àò (compose
              ‚àò (compose ‚àò (compose cons ‚àò pair) []))))) &lt;‚ãÜ&gt;
f x &lt;‚ãÜ&gt; traverse f rest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk24d"><span class="kn">Lemma</span> <span class="nf">mult_to_ap</span>: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; B) (<span class="nv">a</span>: A),
      map (<span class="kr">fun</span> &#39;(f, a) =&gt; f a) (f ‚äó a) = f &lt;‚ãÜ&gt; a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">a</span> : A),
map (<span class="kr">fun</span> &#39;(f0, a0) =&gt; f0 a0) (f ‚äó a) = f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk24e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">a</span> : A),
map (<span class="kr">fun</span> &#39;(f0, a0) =&gt; f0 a0) (f ‚äó a) = f &lt;‚ãÜ&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;ev&#39;&quot;</span> := (<span class="kr">fun</span> &#39;(f, a) =&gt; (f a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;pr&#39;&quot;</span> := (<span class="kr">fun</span> &#39;(x0, y) =&gt; (y, x0)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk24f"><span class="kn">Lemma</span> <span class="nf">map_map_</span> {<span class="nv">F</span>} `{Functor F} {X Y Z} {f&#39;: X  -&gt; Y} {g&#39;: Y -&gt; Z} {t: F X}:
    map g&#39; (map f&#39; t) = map (g&#39; ‚àò f&#39;) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_F</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g&#39; (map f&#39; t) = map (g&#39; ‚àò f&#39;) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk250"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_F</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g&#39; (map f&#39; t) = map (g&#39; ‚àò f&#39;) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk251">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_F</var><span class="hyp-type"><b>: </b><span>Map F</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Functor F</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>F X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g&#39; ‚àò map f&#39;) t = map (g&#39; ‚àò f&#39;) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> fun_map_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">normalize</span> :=
    <span class="kp">repeat</span> ( <span class="nb">rewrite</span> (app_mult_natural_l G) ||
                <span class="nb">rewrite</span> (app_mult_natural_r G) ||
                  <span class="nb">rewrite</span> &lt;- (app_assoc) ||
                    <span class="nb">rewrite</span> map_map_ ||
                      (<span class="nb">rewrite</span> triangle_3; <span class="nb">unfold</span> strength) ||
                        <span class="nb">rewrite</span> triangle_4
      ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">assoc_right</span> :=
    <span class="kp">repeat</span> ( <span class="nb">rewrite</span> &lt;- (app_assoc_inv _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk252"><span class="kn">Lemma</span> <span class="nf">traverse_center_list</span>: <span class="kr">forall</span> (<span class="nv">l</span>: list A),
      Center G (list B) (traverse f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A, Center G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk253"><span class="kn">Proof with</span> normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A, Center G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk254"><span class="nb">intros</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Center G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk255"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk256" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk256"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk257">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk258"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f [] = map pr (traverse f [] ‚äó x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk259" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk259"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f (a :: l) =
map pr (traverse f (a :: l) ‚äó x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk25a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f [] = map pr (traverse f [] ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk25b"><span class="nb">intros</span> C x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó traverse f [] = map pr (traverse f [] ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk25c"><span class="nb">rewrite</span> traverse_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó pure [] = map pr (pure [] ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk25d">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, [])) x = map (pr ‚àò pair []) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk25e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f (a :: l) =
map pr (traverse f (a :: l) ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk25f"><span class="nb">intros</span> C x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó traverse f (a :: l) =
map pr (traverse f (a :: l) ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk260"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l) =
map pr (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk261"><span class="nb">unfold</span> ap...</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (x ‚äó f a ‚äó traverse f l) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)))
  (f a ‚äó traverse f l ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk262"><span class="nb">rewrite</span> (appcenter_left (f a))...</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons)))
   ‚àò map_fst pr) (f a ‚äó x ‚äó traverse f l) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)))
  (f a ‚äó traverse f l ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk263"><span class="nb">rewrite</span> &lt;- (app_assoc_inv G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons)))
   ‚àò map_fst pr)
  (map associator_inv (f a ‚äó (x ‚äó traverse f l))) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)))
  (f a ‚äó traverse f l ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk264"><span class="nb">rewrite</span> IHl...</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons)))
   ‚àò map_fst pr ‚àò associator_inv ‚àò map_snd pr
   ‚àò associator) (f a ‚äó traverse f l ‚äó x) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)))
  (f a ‚äó traverse f l ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk265">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
‚àò map_fst associator
‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons)))
‚àò map_fst pr ‚àò associator_inv ‚àò map_snd pr
‚àò associator =
pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
‚àò map_fst (map_fst (pair cons))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk266">ext [[b&#39; l&#39;] c&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
x ‚äó traverse f l = map pr (traverse f l ‚äó x)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
 ‚àò map_fst associator
 ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons)))
 ‚àò map_fst pr ‚àò associator_inv ‚àò map_snd pr
 ‚àò associator) (b&#39;, l&#39;, c&#39;) =
(pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
 ‚àò map_fst (map_fst (pair cons))) (b&#39;, l&#39;, c&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk267">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk268"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f [] ‚äó x = map pr (x ‚äó traverse f [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk269" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk269"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f (a :: l) ‚äó x =
map pr (x ‚äó traverse f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk26a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f [] ‚äó x = map pr (x ‚äó traverse f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk26b"><span class="nb">intros</span> C x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f [] ‚äó x = map pr (x ‚äó traverse f [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk26c"><span class="nb">rewrite</span> traverse_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] ‚äó x = map pr (x ‚äó pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk26d"><span class="nb">rewrite</span> triangle_4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] ‚äó x = map pr (map (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, [])) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk26e"><span class="nb">rewrite</span> triangle_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">strength ([], x) =
map pr (map (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, [])) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk26f"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pair []) x =
map pr (map (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, [])) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk270">compose near x on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pair []) x =
(map pr ‚àò map (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, []))) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk271"><span class="nb">rewrite</span> (fun_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pair []) x = map (pr ‚àò (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, []))) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk272">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f (a :: l) ‚äó x =
map pr (x ‚äó traverse f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk273"><span class="nb">intros</span> C x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: l) ‚äó x =
map pr (x ‚äó traverse f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk274"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l ‚äó x =
map pr (x ‚äó (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk275"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ev (map ev (pure cons ‚äó f a) ‚äó traverse f l) ‚äó x =
map pr
  (x
   ‚äó map ev (map ev (pure cons ‚äó f a) ‚äó traverse f l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk276">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)))
  (f a ‚äó traverse f l ‚äó x) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (x ‚äó f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk277"><span class="nb">rewrite</span> &lt;- (app_assoc_inv G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)))
  (map associator_inv (f a ‚äó (traverse f l ‚äó x))) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (x ‚äó f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk278"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)))
  (map associator_inv
     (f a ‚äó map pr (x ‚äó traverse f l))) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (x ‚äó f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk279">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)) ‚àò associator_inv
   ‚àò map_snd pr ‚àò associator) (f a ‚äó x ‚äó traverse f l) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (x ‚äó f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk27a"><span class="nb">rewrite</span> (appcenter_right (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)) ‚àò associator_inv
   ‚àò map_snd pr ‚àò associator)
  (map pr (x ‚äó f a) ‚äó traverse f l) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (x ‚äó f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk27b">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair cons)) ‚àò associator_inv
   ‚àò map_snd pr ‚àò associator ‚àò map_fst pr)
  (x ‚äó f a ‚äó traverse f l) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (x ‚äó f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk27c">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_fst ev ‚àò map_fst (map_fst ev)
‚àò map_fst (map_fst (pair cons)) ‚àò associator_inv
‚àò map_snd pr ‚àò associator ‚àò map_fst pr =
pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
‚àò map_fst associator
‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk27d">ext [[c&#39; b&#39;] l&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : G B0),
traverse f l ‚äó x = map pr (x ‚äó traverse f l)</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G C</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map_fst ev ‚àò map_fst (map_fst ev)
 ‚àò map_fst (map_fst (pair cons)) ‚àò associator_inv
 ‚àò map_snd pr ‚àò associator ‚àò map_fst pr) (c&#39;, b&#39;, l&#39;) =
(pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
 ‚àò map_fst associator
 ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : C =&gt; (b, cons))))
  (c&#39;, b&#39;, l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk27e"><span class="kn">Lemma</span> <span class="nf">traverse_idem_list</span>: <span class="kr">forall</span> (<span class="nv">l</span>: list A),
      Idempotent G (list B) (traverse f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
Idempotent G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk27f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
Idempotent G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk280"><span class="nb">intros</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk281"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk282"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f [] ‚äó traverse f [] =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk283" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk283"><hr></label><div class="goal-conclusion">traverse f (a :: l) ‚äó traverse f (a :: l) =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk284">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f [] ‚äó traverse f [] =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk285"><span class="nb">rewrite</span> traverse_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] ‚äó pure [] =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk286"><span class="nb">rewrite</span> app_mult_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ([], []) =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk287"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ([], []) = pure ([], [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk288">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: l) ‚äó traverse f (a :: l) =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk289"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l
‚äó (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l) =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a))
  (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk28a"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l
‚äó (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l) =
map (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
  (pure cons &lt;‚ãÜ&gt; f a) &lt;‚ãÜ&gt; traverse f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk28b"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l
‚äó (pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l) =
map (compose (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a))))
  (pure cons) &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk28c"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ev (map ev (pure cons ‚äó f a) ‚äó traverse f l)
‚äó map ev (map ev (pure cons ‚äó f a) ‚äó traverse f l) =
map ev
  (map ev
     (map
        (compose (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a))))
        (pure cons) ‚äó f a) ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk28d">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons))))
  (f a ‚äó traverse f l ‚äó f a ‚äó traverse f l) =
map
  (ev ‚àò map_fst ev
   ‚àò map_fst
       (map_fst
          (compose
             (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
   ‚àò map_fst (pair cons)) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk28e"><span class="nb">rewrite</span> (appcenter_left (f a)); normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
   ‚àò map_fst pr ‚àò map_fst associator)
  (f a ‚äó f a ‚äó traverse f l ‚äó traverse f l) =
map
  (ev ‚àò map_fst ev
   ‚àò map_fst
       (map_fst
          (compose
             (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
   ‚àò map_fst (pair cons)) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk28f"><span class="nb">rewrite</span> (appidem (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
   ‚àò map_fst pr ‚àò map_fst associator)
  (map (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a)) (f a) ‚äó traverse f l
   ‚äó traverse f l) =
map
  (ev ‚àò map_fst ev
   ‚àò map_fst
       (map_fst
          (compose
             (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
   ‚àò map_fst (pair cons)) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk290">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
   ‚àò map_fst pr ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a))))
  (f a ‚äó traverse f l ‚äó traverse f l) =
map
  (ev ‚àò map_fst ev
   ‚àò map_fst
       (map_fst
          (compose
             (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
   ‚àò map_fst (pair cons)) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk291">assoc_right.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
   ‚àò map_fst pr ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a))))
  (map associator_inv
     (f a ‚äó (traverse f l ‚äó traverse f l))) =
map
  (ev ‚àò map_fst ev
   ‚àò map_fst
       (map_fst
          (compose
             (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
   ‚àò map_fst (pair cons)) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk292"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
   ‚àò map_fst pr ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a))))
  (map associator_inv
     (f a
      ‚äó map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l))) =
map
  (ev ‚àò map_fst ev
   ‚àò map_fst
       (map_fst
          (compose
             (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
   ‚àò map_fst (pair cons)) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk293">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
   ‚àò map_fst pr ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a)))
   ‚àò associator_inv
   ‚àò map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
  (f a ‚äó traverse f l) =
map
  (ev ‚àò map_fst ev
   ‚àò map_fst
       (map_fst
          (compose
             (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
   ‚àò map_fst (pair cons)) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk294">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
‚àò map_snd (map_fst ev) ‚àò associator
‚àò map_fst associator
‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
‚àò map_fst pr ‚àò map_fst associator
‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a)))
‚àò associator_inv ‚àò map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) =
ev ‚àò map_fst ev
‚àò map_fst
    (map_fst
       (compose (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
‚àò map_fst (pair cons)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk295">ext [b&#39; l&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l ‚äó traverse f l =
map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l)</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
 ‚àò map_snd (map_fst ev) ‚àò associator
 ‚àò map_fst associator
 ‚àò map_fst (map_fst (map_fst (map_fst (pair cons))))
 ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B * list B =&gt; (b, cons)))
 ‚àò map_fst pr ‚àò map_fst associator
 ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a)))
 ‚àò associator_inv ‚àò map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
  (b&#39;, l&#39;) =
(ev ‚àò map_fst ev
 ‚àò map_fst
     (map_fst
        (compose (compose (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))))
 ‚àò map_fst (pair cons)) (b&#39;, l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk296"><span class="kn">Lemma</span> <span class="nf">traverse_idem_center_list</span>: <span class="kr">forall</span> (<span class="nv">l</span>: list A),
      IdempotentCenter G (list B) (traverse f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
IdempotentCenter G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk297"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
IdempotentCenter G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk298"><span class="nb">intros</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IdempotentCenter G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk299"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent G (list B) (traverse f l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk29a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk29a"><hr></label><div class="goal-conclusion">Center G (list B) (traverse f l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk29b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> traverse_idem_list.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk29c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Center G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> traverse_center_list.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk29d">#[export] <span class="kn">Instance</span> <span class="nf">IdempotentCenter_traverse_list</span>: <span class="kr">forall</span> (<span class="nv">l</span>: list A),
      IdempotentCenter G (list B) (traverse f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
IdempotentCenter G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk29e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
IdempotentCenter G (list B) (traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> traverse_idem_center_list.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(*</span>
<span class="c">  #[export] Instance Idempotent_traverse_list: forall (l: list A),</span>
<span class="c">      Idempotent G (list B) (traverse f l).</span>
<span class="c">  Proof.</span>
<span class="c">    apply traverse_idem_center_list.</span>
<span class="c">  Qed.</span>

<span class="c">  #[export] Instance Center_traverse_list: forall (l: list A),</span>
<span class="c">      Center G (list B) (traverse f l).</span>
<span class="c">  Proof.</span>
<span class="c">    apply traverse_idem_center_list.</span>
<span class="c">  Qed.</span>
<span class="c">  *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk29f"><span class="kn">Lemma</span> <span class="nf">traverse_idem_center_Z</span>: <span class="kr">forall</span> (<span class="nv">z</span>: Z A),
      IdempotentCenter G (Z B) (traverse (T := Z) f z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Z A,
IdempotentCenter G (Z B) (traverse f z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Z A,
IdempotentCenter G (Z B) (traverse f z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a1"><span class="nb">intros</span> [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IdempotentCenter G (Z B) (traverse f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a2"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent G (Z B) (traverse f (l, a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk2a3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk2a3"><hr></label><div class="goal-conclusion">Center G (Z B) (traverse f (l, a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Idempotent G (Z B) (traverse f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a5"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (l, a) ‚äó traverse f (l, a) =
map (<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) (traverse f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a6"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a
‚äó (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a) =
map (<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a))
  (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a7"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ev (map ev (pure pair ‚äó traverse f l) ‚äó f a)
‚äó map ev (map ev (pure pair ‚äó traverse f l) ‚äó f a) =
map (<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a))
  (map ev (map ev (pure pair ‚äó traverse f l) ‚äó f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a8">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair))))
  (traverse f l ‚äó f a ‚äó traverse f l ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair)) (traverse f l ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2a9"><span class="nb">rewrite</span> (appcenter_right (traverse f l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair))))
  (map pr (f a ‚äó traverse f l) ‚äó traverse f l ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair))
  (map pr (f a ‚äó traverse f l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2aa">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr))
  (f a ‚äó traverse f l ‚äó traverse f l ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ab"><span class="nb">rewrite</span> &lt;- (app_assoc_inv G _ _ _ (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr))
  (map associator_inv
     (f a ‚äó (traverse f l ‚äó traverse f l)) ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ac"><span class="nb">rewrite</span> (appidem); [|<span class="nb">typeclasses eauto</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr))
  (map associator_inv
     (f a
      ‚äó map (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)) (traverse f l))
   ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ad">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr) ‚àò map_fst associator_inv
   ‚àò map_fst (map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a))))
  (f a ‚äó traverse f l ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr) (f a ‚äó traverse f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ae"><span class="nb">rewrite</span> (appcenter_right (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr) ‚àò map_fst associator_inv
   ‚àò map_fst (map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a))))
  (map pr (traverse f l ‚äó f a) ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr)
  (map pr (traverse f l ‚äó f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2af">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr) ‚àò map_fst associator_inv
   ‚àò map_fst (map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
   ‚àò map_fst pr) (traverse f l ‚äó f a ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr ‚àò pr)
  (traverse f l ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b0">assoc_right.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr) ‚àò map_fst associator_inv
   ‚àò map_fst (map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
   ‚àò map_fst pr)
  (map associator_inv (traverse f l ‚äó (f a ‚äó f a))) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr ‚àò pr)
  (traverse f l ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b1"><span class="nb">rewrite</span> (appidem); [|<span class="nb">typeclasses eauto</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr) ‚àò map_fst associator_inv
   ‚àò map_fst (map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
   ‚àò map_fst pr)
  (map associator_inv
     (traverse f l ‚äó map (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a)) (f a))) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr ‚àò pr)
  (traverse f l ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b2">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
   ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
   ‚àò map_fst
       (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
   ‚àò map_fst (map_fst pr) ‚àò map_fst associator_inv
   ‚àò map_fst (map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
   ‚àò map_fst pr ‚àò associator_inv
   ‚àò map_snd (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a)))
  (traverse f l ‚äó f a) =
map
  ((<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
   ‚àò map_fst (pair pair) ‚àò pr ‚àò pr)
  (traverse f l ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b3">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_fst ev ‚àò map_fst (map_fst ev) ‚àò map_snd ev
‚àò map_snd (map_fst ev) ‚àò associator
‚àò map_fst associator
‚àò map_fst (map_fst (map_fst (map_fst (pair pair))))
‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : list B * B =&gt; (b, pair)))
‚àò map_fst (map_fst pr) ‚àò map_fst associator_inv
‚àò map_fst (map_snd (<span class="kr">fun</span> <span class="nv">a</span> : list B =&gt; (a, a)))
‚àò map_fst pr ‚àò associator_inv
‚àò map_snd (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (a, a)) =
(<span class="kr">fun</span> <span class="nv">a</span> : Z B =&gt; (a, a)) ‚àò ev ‚àò map_fst ev
‚àò map_fst (pair pair) ‚àò pr ‚àò pr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext [l&#39; b&#39;].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Center G (Z B) (traverse f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b5"><span class="nb">constructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó traverse f (l, a) = map pr (traverse f (l, a) ‚äó x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk2b6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk2b6"><hr></label><div class="goal-conclusion">traverse f (l, a) ‚äó x = map pr (x ‚äó traverse f (l, a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó traverse f (l, a) = map pr (traverse f (l, a) ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b8"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a) =
map pr (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2b9"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚äó map ev (map ev (pure pair ‚äó traverse f l) ‚äó f a) =
map pr
  (map ev (map ev (pure pair ‚äó traverse f l) ‚äó f a)
   ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ba">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))))
  (x ‚äó traverse f l ‚äó f a) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2bb"><span class="nb">rewrite</span> (appcenter_left (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))))
  (map pr (f a ‚äó (x ‚äó traverse f l))) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2bc">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))) ‚àò pr
   ‚àò associator) (f a ‚äó x ‚äó traverse f l) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2bd"><span class="nb">rewrite</span> (appcenter_left (traverse f l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))) ‚àò pr
   ‚àò associator) (map pr (traverse f l ‚äó (f a ‚äó x))) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2be">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))) ‚àò pr
   ‚àò associator ‚àò pr ‚àò associator)
  (traverse f l ‚äó f a ‚äó x) =
map
  (pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2bf">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
‚àò map_fst associator
‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))) ‚àò pr
‚àò associator ‚àò pr ‚àò associator =
pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
‚àò map_fst (map_fst (pair pair))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c0">ext [[? ?] ?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
 ‚àò map_fst associator
 ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))) ‚àò pr
 ‚àò associator ‚àò pr ‚àò associator) (l0, b, b0) =
(pr ‚àò map_fst ev ‚àò map_fst (map_fst ev)
 ‚àò map_fst (map_fst (pair pair))) (l0, b, b0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (l, a) ‚äó x = map pr (x ‚äó traverse f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c2"><span class="nb">rewrite</span> traverse_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a ‚äó x =
map pr (x ‚äó (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c3"><span class="nb">unfold</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map ev (map ev (pure pair ‚äó traverse f l) ‚äó f a) ‚äó x =
map pr
  (x
   ‚äó map ev (map ev (pure pair ‚äó traverse f l) ‚äó f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c4">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))))
  (x ‚äó traverse f l ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c5"><span class="nb">rewrite</span> (appcenter_left (traverse f l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair))))
  (map pr (traverse f l ‚äó x) ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c6">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (traverse f l ‚äó f a ‚äó x) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair)))
   ‚àò map_fst pr) (traverse f l ‚äó x ‚äó f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c7">assoc_right.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (map associator_inv (traverse f l ‚äó (f a ‚äó x))) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair)))
   ‚àò map_fst pr)
  (map associator_inv (traverse f l ‚äó (x ‚äó f a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c8"><span class="nb">rewrite</span> (appcenter_left (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)))
  (map associator_inv (traverse f l ‚äó (f a ‚äó x))) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair)))
   ‚àò map_fst pr)
  (map associator_inv
     (traverse f l ‚äó map pr (f a ‚äó x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2c9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2c9">normalize.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (map_fst ev ‚àò map_fst (map_fst ev)
   ‚àò map_fst (map_fst (pair pair)) ‚àò associator_inv
   ‚àò associator) (traverse f l ‚äó f a ‚äó x) =
map
  (pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
   ‚àò map_fst associator
   ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair)))
   ‚àò map_fst pr ‚àò associator_inv ‚àò map_snd pr
   ‚àò associator) (traverse f l ‚äó f a ‚äó x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ca" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ca">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_fst ev ‚àò map_fst (map_fst ev)
‚àò map_fst (map_fst (pair pair)) ‚àò associator_inv
‚àò associator =
pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
‚àò map_fst associator
‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair)))
‚àò map_fst pr ‚àò associator_inv ‚àò map_snd pr
‚àò associator</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2cb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2cb">ext [[? ?] ?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G B0</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map_fst ev ‚àò map_fst (map_fst ev)
 ‚àò map_fst (map_fst (pair pair)) ‚àò associator_inv
 ‚àò associator) (l0, b, b0) =
(pr ‚àò map_snd ev ‚àò map_snd (map_fst ev) ‚àò associator
 ‚àò map_fst associator
 ‚àò map_fst (map_fst (<span class="kr">fun</span> <span class="nv">b</span> : B0 =&gt; (b, pair)))
 ‚àò map_fst pr ‚àò associator_inv ‚àò map_snd pr
 ‚àò associator) (l0, b, b0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2cc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2cc"><span class="kn">Theorem</span> <span class="nf">cojoin_commute</span>:
    map (cojoin (W := Z)) ‚àò traverse (T := Z) f =
      traverse (T := Z) (traverse (T := Z) f) ‚àò cojoin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map cojoin ‚àò traverse f =
traverse (traverse f) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2cd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2cd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map cojoin ‚àò traverse f =
traverse (traverse f) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ce" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ce"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map cojoin ‚àò traverse f =
traverse (traverse f) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2cf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2cf">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map cojoin ‚àò traverse f) (l, a) =
(traverse (traverse f) ‚àò cojoin) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d0"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map cojoin (traverse f (l, a)) =
traverse (traverse f) (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d1"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map cojoin (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a) =
pure pair &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d2"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cojoin &lt;‚ãÜ&gt; (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a) =
pure pair &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d3"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure cojoin &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l) &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d4"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; (pure compose &lt;‚ãÜ&gt; pure cojoin) &lt;‚ãÜ&gt;
pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure cojoin &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d6"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt;
traverse (traverse f) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d7"><span class="nb">change</span> ((traverse (traverse f)) (decorate_prefix_list l))
      <span class="kr">with</span> ((traverse (traverse f) ‚àò decorate_prefix_list) l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt;
(traverse (traverse f) ‚àò decorate_prefix_list) l &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d8"><span class="nb">rewrite</span> &lt;- decorate_commute.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt;
(map decorate_prefix_list ‚àò traverse f) l &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2d9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2d9"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt; map decorate_prefix_list (traverse f l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2da" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2da"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
map (precompose decorate_prefix_list) (pure pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2db" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2db"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; (pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2dc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2dc"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt;
(pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
 traverse f l) &lt;‚ãÜ&gt; (pure pair &lt;‚ãÜ&gt; traverse f l) &lt;‚ãÜ&gt;
f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2dd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2dd"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt;
 (pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
  traverse f l)) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt;
f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2de" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2de"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
 traverse f l) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; 
f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2df" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2df"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose) &lt;‚ãÜ&gt;
pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e0"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; pure compose) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e1"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; (pure compose &lt;‚ãÜ&gt; pure compose) &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e2"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt;
pure (precompose decorate_prefix_list pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e3"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure
  ((compose ‚àò compose) compose compose compose compose
     (precompose decorate_prefix_list pair)) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e4"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure (evalAt pair) &lt;‚ãÜ&gt;
(pure
   ((compose ‚àò compose) compose compose compose
      compose (precompose decorate_prefix_list pair)) &lt;‚ãÜ&gt;
 traverse f l) &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure compose &lt;‚ãÜ&gt; pure (evalAt pair) &lt;‚ãÜ&gt;
pure
  ((compose ‚àò compose) compose compose compose compose
     (precompose decorate_prefix_list pair)) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e6"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure
  (evalAt pair
   ‚àò (compose ‚àò compose) compose compose compose
       compose (precompose decorate_prefix_list pair)) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e7"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
map double_input
  (pure
     (evalAt pair
      ‚àò (compose ‚àò compose) compose compose compose
          compose
          (precompose decorate_prefix_list pair))) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e8"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hci</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ((compose ‚àò compose) cojoin pair) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a =
pure
  (double_input
     (evalAt pair
      ‚àò (compose ‚àò compose) compose compose compose
          compose
          (precompose decorate_prefix_list pair))) &lt;‚ãÜ&gt;
traverse f l &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">commute_law</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Mapdt for &lt;&lt;list&gt;&gt; and &lt;&lt;Z&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Recursive inlined version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">mapdt_list_prefix_</span>
  {<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G} `{Pure G} `{Mult G}
  {A B: <span class="kt">Type</span>} (f: list A * A -&gt; G B) (l: list A)
: G (list B) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; pure (@nil B)
  | x :: xs =&gt;
      pure (@List.cons B) &lt;‚ãÜ&gt; f (nil, x) &lt;‚ãÜ&gt;
        mapdt_list_prefix_ (f ‚¶ø [x]) xs
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decomposed Version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mapdt_list_prefix</span>
  `{G: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G} `{Pure G} `{Mult G}
  {A B: <span class="kt">Type</span>} (f: list A * A -&gt; G B): list A -&gt; G (list B) :=
  traverse (T := list) (G := G) f ‚àò decorate_prefix_list.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapdt_CommIdem_list_prefix</span>:
  Mapdt_CommIdem Z list := @mapdt_list_prefix.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2e9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2e9">#[export] <span class="kn">Instance</span> <span class="nf">Mapdt_CommIdem_Z</span>: Mapdt_CommIdem Z Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Mapdt_CommIdem Z Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ea" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ea"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Mapdt_CommIdem Z Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2eb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2eb"><span class="nb">intros</span> G Gmap Gpure Gmult A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Gmap</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Gpure</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Gmult</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z A -&gt; G (Z B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (traverse (T := Z) f ‚àò cojoin (W := Z)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ec" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ec"><span class="kn">Lemma</span> <span class="nf">mapdt_list_prefix_decorate</span>:
  <span class="kr">forall</span> `{G: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
    `{Map G} `{Pure G} `{Mult G} `{! Applicative G}
    {A B: <span class="kt">Type</span>} (f: Z (Z A) -&gt; G B),
    mapdt_list_prefix f ‚àò decorate_prefix_list =
      mapdt_list_prefix (f ‚àò cojoin (W := Z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z (Z A) -&gt; G B),
mapdt_list_prefix f ‚àò decorate_prefix_list =
mapdt_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ed" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ed"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G) (<span class="nv">H0</span> : Pure G)
  (<span class="nv">H1</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z (Z A) -&gt; G B),
mapdt_list_prefix f ‚àò decorate_prefix_list =
mapdt_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ee" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ee"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f ‚àò decorate_prefix_list =
mapdt_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ef" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ef"><span class="nb">unfold</span> mapdt_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚àò decorate_prefix_list
‚àò decorate_prefix_list =
traverse (f ‚àò cojoin) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f0">reassociate -&gt; on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f
‚àò (decorate_prefix_list ‚àò decorate_prefix_list) =
traverse (f ‚àò cojoin) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f1"><span class="nb">rewrite</span> &lt;- decorate_prefix_list_cojoin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚àò (map cojoin ‚àò decorate_prefix_list) =
traverse (f ‚àò cojoin) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f2">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f ‚àò map cojoin ‚àò decorate_prefix_list =
traverse (f ‚àò cojoin) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f3"><span class="nb">rewrite</span> (traverse_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f ‚àò cojoin) ‚àò decorate_prefix_list =
traverse (f ‚àò cojoin) ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalence of the Definitions  *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f4"><span class="kn">Lemma</span> <span class="nf">mapdt_list_prefix_spec</span>
  {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}
  `{G: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G} `{Mult G} `{Pure G} `{! Applicative G}
  (f: list A * A -&gt; G B) (l: list A):
  mapdt_list_prefix f l = mapdt_list_prefix_ f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f l = mapdt_list_prefix_ f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f l = mapdt_list_prefix_ f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f6"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; G B,
mapdt_list_prefix f l = mapdt_list_prefix_ f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f7"><span class="nb">unfold</span> mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; G B,
mapdt_list_prefix f l = mapdt_list_prefix_ f l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2f8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2f8"><span class="nb">induction</span> l; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f [] = mapdt_list_prefix_ f []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk2f9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; G B,
mapdt_list_prefix f l = mapdt_list_prefix_ f l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk2f9"><hr></label><div class="goal-conclusion">mapdt_list_prefix f (a :: l) =
mapdt_list_prefix_ f (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2fa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2fa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f [] = mapdt_list_prefix_ f []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2fb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2fb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; G B,
mapdt_list_prefix f l = mapdt_list_prefix_ f l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f (a :: l) =
mapdt_list_prefix_ f (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2fc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2fc"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; G B,
mapdt_list_prefix f l = mapdt_list_prefix_ f l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse f (map (incr [a]) (decorate_prefix_list l)) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix_ (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2fd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2fd"><span class="nb">specialize</span> (IHl (f ‚¶ø [a])).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix (f ‚¶ø [a]) l =
mapdt_list_prefix_ (f ‚¶ø [a]) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse f (map (incr [a]) (decorate_prefix_list l)) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix_ (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2fe" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2fe">compose near (decorate_prefix_list l) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix (f ‚¶ø [a]) l =
mapdt_list_prefix_ (f ‚¶ø [a]) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
(traverse f ‚àò map (incr [a])) (decorate_prefix_list l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix_ (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk2ff" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk2ff"><span class="nb">rewrite</span> traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix (f ‚¶ø [a]) l =
mapdt_list_prefix_ (f ‚¶ø [a]) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse (f ‚àò incr [a]) (decorate_prefix_list l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix_ (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk300" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk300"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix (f ‚¶ø [a]) l =
mapdt_list_prefix_ (f ‚¶ø [a]) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse (f ‚àò incr [a]) (decorate_prefix_list l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk301" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk301"><span class="nb">unfold</span> preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix (f ‚¶ø [a]) l =
mapdt_list_prefix_ (f ‚¶ø [a]) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse (f ‚àò incr [a]) (decorate_prefix_list l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚àò incr [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk302" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk302"><span class="nb">unfold</span> incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix (f ‚¶ø [a]) l =
mapdt_list_prefix_ (f ‚¶ø [a]) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse (f ‚àò (<span class="kr">fun</span> &#39;(w1, a0) =&gt; ([a] ‚óè w1, a0)))
  (decorate_prefix_list l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix
  (f ‚àò (<span class="kr">fun</span> &#39;(w1, a0) =&gt; ([a] ‚óè w1, a0))) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting Laws *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">mapdt_list_prefix_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
    `{Map G} `{Pure G} `{Mult G}
    `{! Applicative G}
    {A B: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk303" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk303"><span class="kn">Lemma</span> <span class="nf">mapdt_list_prefix_rw_nil</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: list A * A -&gt; G B),
      mapdt_list_prefix f nil = pure nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; G B,
mapdt_list_prefix f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk304" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk304"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; G B,
mapdt_list_prefix f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk305" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk305"><span class="kn">Lemma</span> <span class="nf">mapdt_list_prefix_rw_cons</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: list A * A -&gt; G B) (<span class="nv">a</span>: A) (<span class="nv">l</span>: list A),
      mapdt_list_prefix f (a :: l) =
        pure (@List.cons B)
          &lt;‚ãÜ&gt; f (nil, a)
          &lt;‚ãÜ&gt; mapdt_list_prefix (f ‚¶ø [a]) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : list A * A -&gt; G B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
mapdt_list_prefix f (a :: l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk306" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk306"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : list A * A -&gt; G B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
mapdt_list_prefix f (a :: l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk307" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk307"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f (a :: l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk308" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk308"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse f (map (incr [a]) (decorate_prefix_list l)) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk309" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk309">compose near (decorate_prefix_list l) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
(traverse f ‚àò map (incr [a])) (decorate_prefix_list l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk30a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk30a"><span class="nb">rewrite</span> traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
traverse (f ‚àò incr [a]) (decorate_prefix_list l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk30b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk30b"><span class="kn">Lemma</span> <span class="nf">mapdt_list_prefix_rw_app</span>:
    <span class="kr">forall</span> (<span class="nv">g</span>: list A * A -&gt; G B) (<span class="nv">l</span> <span class="nv">l&#39;</span>: list A),
      mapdt_list_prefix g (l ++ l&#39;) =
        pure (@app B)
          &lt;‚ãÜ&gt; mapdt_list_prefix g l
          &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø l) l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk30c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk30c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk30d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk30d"><span class="nb">intros</span> g l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A,
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk30e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk30e"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk30f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk30f"><span class="nb">induction</span> l; <span class="nb">intros</span> g l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix g ([] ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g [] &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø []) l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk310" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk310"><hr></label><div class="goal-conclusion">mapdt_list_prefix g ((a :: l) ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g (a :: l) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk311" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk311">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix g ([] ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g [] &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø []) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk312" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk312"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse g (decorate_prefix_list l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; pure [] &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø []) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk313" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk313"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse g (decorate_prefix_list l&#39;) =
pure (app []) &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø []) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk314" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk314"><span class="nb">change</span> (app []) <span class="kr">with</span> (@id (list B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse g (decorate_prefix_list l&#39;) =
pure id &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø []) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk315" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk315"><span class="nb">rewrite</span> ap1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse g (decorate_prefix_list l&#39;) =
mapdt_list_prefix (g ‚¶ø []) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk316" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk316"><span class="nb">change</span> (g ‚¶ø []) <span class="kr">with</span> (g ‚¶ø ∆µ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse g (decorate_prefix_list l&#39;) =
mapdt_list_prefix (g ‚¶ø ∆µ) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk317" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk317"><span class="nb">rewrite</span> preincr_zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse g (decorate_prefix_list l&#39;) =
mapdt_list_prefix g l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk318" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk318">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix g ((a :: l) ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g (a :: l) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk319" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk319"><span class="nb">rewrite</span> &lt;- List.app_comm_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix g (a :: l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g (a :: l) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk31a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk31a"><span class="nb">rewrite</span> mapdt_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø [a]) (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g (a :: l) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk31b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk31b"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø [a]) l &lt;‚ãÜ&gt;
 mapdt_list_prefix ((g ‚¶ø [a]) ‚¶ø l) l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g (a :: l) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk31c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk31c"><span class="nb">rewrite</span> mapdt_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø [a]) l &lt;‚ãÜ&gt;
 mapdt_list_prefix ((g ‚¶ø [a]) ‚¶ø l) l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
 mapdt_list_prefix (g ‚¶ø [a]) l) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk31d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk31d"><span class="nb">rewrite</span> preincr_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø [a]) l &lt;‚ãÜ&gt;
 mapdt_list_prefix (g ‚¶ø ([a] ‚óè l)) l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
 mapdt_list_prefix (g ‚¶ø [a]) l) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk31e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk31e"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø [a]) l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø ([a] ‚óè l)) l&#39; =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø [a]) l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø (a :: l)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk31f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk31f">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚¶ø [a]) l =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk320" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk320">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
pure (app (A:=B)) =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk321" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk321"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; (pure cons &lt;‚ãÜ&gt; g ([], a))) &lt;‚ãÜ&gt;
pure (app (A:=B)) =
pure compose &lt;‚ãÜ&gt; pure (app (A:=B)) &lt;‚ãÜ&gt;
(pure cons &lt;‚ãÜ&gt; g ([], a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk322" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk322"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
pure (app (A:=B)) =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk323" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk323"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((compose ‚àò compose) compose compose compose compose
     cons) &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt; pure (app (A:=B)) =
pure ((compose ‚àò compose) (app (A:=B)) cons) &lt;‚ãÜ&gt;
g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk324" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk324"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a) &lt;‚ãÜ&gt;
pure (app (A:=B)) =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk325" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk325"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt (app (A:=B))) &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
 pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
 pure compose &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a)) =
pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt; pure cons &lt;‚ãÜ&gt; g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk326" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk326"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt (app (A:=B))) &lt;‚ãÜ&gt;
(pure
   ((compose ‚àò compose) compose compose compose
      compose cons) &lt;‚ãÜ&gt; g ([], a)) =
pure ((compose ‚àò compose) (app (A:=B)) cons) &lt;‚ãÜ&gt;
g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk327" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk327"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (evalAt (app (A:=B))) &lt;‚ãÜ&gt;
pure
  ((compose ‚àò compose) compose compose compose compose
     cons) &lt;‚ãÜ&gt; g ([], a) =
pure ((compose ‚àò compose) (app (A:=B)) cons) &lt;‚ãÜ&gt;
g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk328" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk328"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; G B) (<span class="nv">l&#39;</span> : list A),
mapdt_list_prefix g (l ++ l&#39;) =
pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (evalAt (app (A:=B))
   ‚àò (compose ‚àò compose) compose compose compose
       compose cons) &lt;‚ãÜ&gt; g ([], a) =
pure ((compose ‚àò compose) (app (A:=B)) cons) &lt;‚ãÜ&gt;
g ([], a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">mapdt_list_prefix_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Rewriting Laws for &lt;&lt;Z&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">mapdt_Z_Z_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
    `{Map G} `{Pure G} `{Mult G}
    `{! Applicative G}
    {A B: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk329" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk329"><span class="kn">Lemma</span> <span class="nf">mapdt_Z_Z_rw</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: Z A -&gt; G B) (<span class="nv">l</span>: list A) (<span class="nv">a</span>: A),
      mapdt_ci (W := Z) (T := Z) f (l, a) =
        pure (@pair (list B) B) &lt;‚ãÜ&gt; mapdt_ci (W := Z) (T := list) f l &lt;‚ãÜ&gt; (f (l, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : Z A -&gt; G B) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
mapdt_ci f (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk32a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk32a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : Z A -&gt; G B) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
mapdt_ci f (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk32b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk32b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci f (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">mapdt_Z_Z_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">



<span class="c">(*</span>
<span class="c">  Lemma mapdt_list_prefix_preincr</span>
<span class="c">  {A B: Type}</span>
<span class="c">  `{G: Type -&gt; Type} `{Map G} `{Mult G} `{Pure G} `{! ApplicativeCommutativeIdempotent G}</span>
<span class="c">  (f: list A * A -&gt; G B) (ctx: list A) (l: list A):</span>
<span class="c">  l &lt;&gt; nil -&gt;</span>
<span class="c">  mapdt_list_prefix (f ‚¶ø ctx) l = mapdt_list_prefix f l.</span>
<span class="c">  Proof.</span>
<span class="c">  introv Hneq.</span>
<span class="c">  induction l.</span>
<span class="c">  - contradiction.</span>
<span class="c">  - rewrite mapdt_list_prefix_spec.</span>
<span class="c">  rewrite mapdt_list_prefix_rw_cons.</span>
<span class="c">  unfold mapdt_list_prefix.</span>
<span class="c">  Search traverse preincr.</span>
<span class="c">  destruct (dec l).</span>
<span class="c">  generalize dependent f.</span>
<span class="c"> *)</span>

<span class="c">(*</span>
<span class="c">  #[local] Generalizable Variable  G.</span>

<span class="c">  Lemma mapdt_list_prefix_rw_preincr {A B} `{Applicative G}:</span>
<span class="c">  forall (g: list A * A -&gt; G B) ctx l,</span>
<span class="c">  l &lt;&gt; nil -&gt;</span>
<span class="c">  mapdt_list_prefix (g ‚¶ø ctx) l =</span>
<span class="c">  pure (@app B) &lt;‚ãÜ&gt; mapdt_list_prefix g ctx &lt;‚ãÜ&gt; mapdt_list_prefix g l.</span>
<span class="c">  Proof.</span>
<span class="c">  intros.</span>
<span class="c">  rewrite mapdt_list_prefix_spec.</span>
<span class="c">  rewrite mapdt_list_prefix_spec2.</span>
<span class="c">  destruct l as [| a l].</span>
<span class="c">  - contradiction.</span>
<span class="c">  - rewrite decorate_prefix_list_rw_cons.</span>
<span class="c">  rewrite traverse_list_cons.</span>
<span class="c">  (* LHS *)</span>
<span class="c">  unfold preincr at 1.</span>
<span class="c">  unfold compose at 1.</span>
<span class="c">  unfold incr at 1.</span>
<span class="c">  change (@nil A) with (∆µ: list A) at 1.</span>
<span class="c">  rewrite monoid_id_l.</span>
<span class="c">  compose near (dec l) on left.</span>
<span class="c">  rewrite traverse_map.</span>
<span class="c">  replace (g ‚¶ø ctx ‚àò incr [a]) with (g ‚¶ø (ctx ++ [a])).</span>
<span class="c">  2:{ unfold preincr, incr, compose.</span>
<span class="c">  ext [pl pa].</span>
<span class="c">  unfold_ops @Monoid_op_list.</span>
<span class="c">  now rewrite List.app_assoc. }</span>
<span class="c">  (* RHS *)</span>
<span class="c">  cbn.</span>
<span class="c">  Abort.</span>
<span class="c"> *)</span>

<span class="sd">(** ** Kleisli composition *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compose_arrows_manual</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
  `{G1: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G1} `{Mult G1} `{Pure G1}
  `{G2: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G2} `{Mult G2} `{Pure G2}
  (g: list B * B -&gt; G2 C) (f: list A * A -&gt; G1 B)
: list A * A -&gt; G1 (G2 C) :=
  map g ‚àò traverse (T := Z) f ‚àò cojoin (W := Z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Inlined version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compose_arrows2</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
  `{G1: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G1} `{Mult G1} `{Pure G1}
  `{G2: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G2} `{Mult G2} `{Pure G2}
  (g: list B * B -&gt; G2 C) (f: list A * A -&gt; G1 B)
: list A * A -&gt; G1 (G2 C) :=
  <span class="kr">fun</span> &#39;(l, a) =&gt;
    map (F := G1) g
      (pure (@pair (list B) B) &lt;‚ãÜ&gt; mapdt_list_prefix f l &lt;‚ãÜ&gt; (f (l, a): G1 B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Another version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compose_arrows3</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
  `{G1: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G1} `{Mult G1} `{Pure G1}
  `{G2: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G2} `{Mult G2} `{Pure G2}
  (g: list B * B -&gt; G2 C) (f: list A * A -&gt; G1 B)
: list A * A -&gt; G1 (G2 C) :=
  map (F := G1) g ‚àò mapdt_ci (T := Z) (W := Z) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Equivalence *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk32c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk32c"><span class="kn">Lemma</span> <span class="nf">compose_arrows_equiv</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
  `{G1: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G1} `{Mult G1} `{Pure G1} `{! Applicative G1}
  `{G2: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G2} `{Mult G2} `{Pure G2}
  (g: list B * B -&gt; G2 C) (f: list A * A -&gt; G1 B):
  g ‚ãÜ<span class="mi">3_</span>ci f = compose_arrows2 g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ‚ãÜ<span class="mi">3_</span>ci f = compose_arrows2 g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk32d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk32d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ‚ãÜ<span class="mi">3_</span>ci f = compose_arrows2 g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk32e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk32e">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a) = compose_arrows2 g f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk32f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk32f"><span class="nb">unfold</span> kc3_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò mapdt_ci f) (l, a) =
compose_arrows2 g f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk330" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk330"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g (mapdt_ci f (l, a)) = compose_arrows2 g f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk331" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk331"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (pure pair &lt;‚ãÜ&gt; traverse f (decorate_prefix_list l) &lt;‚ãÜ&gt;
   f (l, a)) =
map g
  (pure pair &lt;‚ãÜ&gt; mapdt_list_prefix f l &lt;‚ãÜ&gt; f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk332" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk332"><span class="kn">Lemma</span> <span class="nf">compose_arrows_equiv2</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
  `{G1: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G1} `{Mult G1} `{Pure G1} `{! Applicative G1}
  `{G2: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G2} `{Mult G2} `{Pure G2}
  (g: list B * B -&gt; G2 C) (f: list A * A -&gt; G1 B):
  g ‚ãÜ<span class="mi">3_</span>ci f = compose_arrows3 g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ‚ãÜ<span class="mi">3_</span>ci f = compose_arrows3 g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk333" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk333"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ‚ãÜ<span class="mi">3_</span>ci f = compose_arrows3 g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Preincrement (2025 VERSION!) *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">preincrement_kc</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
    `{G1: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G1} `{Mult G1} `{Pure G1} `{! Applicative G1}
    `{G2: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G2} `{Mult G2} `{Pure G2}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk334" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk334"><span class="kn">Lemma</span> <span class="nf">kc_preincr</span>
    (<span class="nv">g</span>: list B * B -&gt; G2 C)
    (<span class="nv">f</span>: list A * A -&gt; G1 B)
    (<span class="nv">ctx</span>: list A):
    (kc3_ci (G1 := G1) (G2 := G2) g f ‚¶ø ctx) =
      ap (A := Z B) G1 (map (preincr g) (traverse f (decorate_prefix_list ctx))) ‚àò
        mapdt_ci (T := Z) (W := Z) (f ‚¶ø ctx).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚¶ø ctx)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk335" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk335"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚¶ø ctx)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk336" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk336"><span class="nb">unfold</span> kc3_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò mapdt_ci f) ‚¶ø ctx =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚¶ø ctx)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk337" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk337">unfold_ops @Mapdt_CommIdem_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò (traverse f ‚àò cojoin)) ‚¶ø ctx =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò (traverse (f ‚¶ø ctx) ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk338" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk338">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò traverse f ‚àò cojoin) ‚¶ø ctx =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò (traverse (f ‚¶ø ctx) ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk339" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk339"><span class="nb">rewrite</span> (preincr_assoc (map g ‚àò traverse f) (cojoin (W := Z))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g ‚àò traverse f ‚àò cojoin ‚¶ø ctx =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò (traverse (f ‚¶ø ctx) ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk33a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk33a">fold_Z; <span class="nb">change</span> (Z (Z <span class="nl">?A</span>)) <span class="kr">with</span> ((Z ‚àò Z) A);
      <span class="nb">rewrite</span> (cojoin_Z_rw_preincr_pf ctx).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g ‚àò traverse f
‚àò (map_pair
     (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
     (incr ctx) ‚àò cojoin) =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò (traverse (f ‚¶ø ctx) ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk33b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk33b">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g ‚àò traverse f
‚àò map_pair
    (app (decorate_prefix_list ctx) ‚àò map (incr ctx))
    (incr ctx) ‚àò cojoin =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò (traverse (f ‚¶ø ctx) ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk33c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk33c"><span class="nb">change</span> (map g ‚àò traverse f ‚àò <span class="nl">?x</span> ‚àò <span class="nl">?y</span>)
      <span class="kr">with</span> (map g ‚àò (traverse f ‚àò x) ‚àò y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
‚àò (traverse f
   ‚àò map_pair
       (app (decorate_prefix_list ctx)
        ‚àò map (incr ctx)) (incr ctx)) ‚àò cojoin =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò (traverse (f ‚¶ø ctx) ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk33d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk33d"><span class="nb">rewrite</span> traverse_Z_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
‚àò traverse_pair
    (traverse f
     ‚àò (app (decorate_prefix_list ctx)
        ‚àò map (incr ctx))) (f ‚àò incr ctx) ‚àò cojoin =
ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò (traverse (f ‚¶ø ctx) ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk33e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk33e">ext [l a]; <span class="nb">unfold</span> compose; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (pure pair &lt;‚ãÜ&gt;
   traverse f
     (decorate_prefix_list ctx ++
      map (incr ctx) (decorate_prefix_list l)) &lt;‚ãÜ&gt;
   f (ctx ‚óè l, a)) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk33f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk33f"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose g)
  (pure pair &lt;‚ãÜ&gt;
   traverse f
     (decorate_prefix_list ctx ++
      map (incr ctx) (decorate_prefix_list l))) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk340" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk340"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose g)) (pure pair) &lt;‚ãÜ&gt;
traverse f
  (decorate_prefix_list ctx ++
   map (incr ctx) (decorate_prefix_list l)) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk341" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk341"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
traverse f
  (decorate_prefix_list ctx ++
   map (incr ctx) (decorate_prefix_list l)) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk342" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk342"><span class="nb">rewrite</span> (traverse_list_app G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
 traverse f (map (incr ctx) (decorate_prefix_list l))) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk343" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk343">compose near (decorate_prefix_list l) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
 (traverse f ‚àò map (incr ctx))
   (decorate_prefix_list l)) &lt;‚ãÜ&gt; f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk344" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk344"><span class="nb">rewrite</span> traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
 traverse (f ‚àò incr ctx) (decorate_prefix_list l)) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk345" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk345"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk346" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk346"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair)) &lt;‚ãÜ&gt;
(pure (app (A:=B)) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk347" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk347"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;‚ãÜ&gt; pure (compose (compose g ‚àò pair)) &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk348" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk348"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (compose g ‚àò pair))) &lt;‚ãÜ&gt;
pure (app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk349" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk349"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
 (f ‚¶ø ctx) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk34a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk34a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure compose &lt;‚ãÜ&gt;
map (preincr g)
  (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l)) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk34b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk34b"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
map (precompose (preincr g)) (pure compose) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l)) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk34c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk34c"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure (precompose (preincr g) compose) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt;
 traverse (f ‚¶ø ctx) (decorate_prefix_list l)) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk34d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk34d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure compose &lt;‚ãÜ&gt;
(pure (precompose (preincr g) compose) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk34e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk34e"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure (evalAt pair) &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt;
 (pure (precompose (preincr g) compose) &lt;‚ãÜ&gt;
  traverse f (decorate_prefix_list ctx))) &lt;‚ãÜ&gt;
traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk34f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk34f"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure compose &lt;‚ãÜ&gt; pure (evalAt pair) &lt;‚ãÜ&gt; pure compose &lt;‚ãÜ&gt;
(pure (precompose (preincr g) compose) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk350" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk350"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure (evalAt pair ‚àò compose) &lt;‚ãÜ&gt;
(pure (precompose (preincr g) compose) &lt;‚ãÜ&gt;
 traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk351" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk351"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure compose &lt;‚ãÜ&gt; pure (evalAt pair ‚àò compose) &lt;‚ãÜ&gt;
pure (precompose (preincr g) compose) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk352" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk352"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure (compose (evalAt pair ‚àò compose)) &lt;‚ãÜ&gt;
pure (precompose (preincr g) compose) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk353" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk353"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose g ‚àò pair) ‚àò app (A:=B)) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚àò incr ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
f (ctx ‚óè l, a) =
pure
  (evalAt pair ‚àò compose
   ‚àò precompose (preincr g) compose) &lt;‚ãÜ&gt;
traverse f (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
traverse (f ‚¶ø ctx) (decorate_prefix_list l) &lt;‚ãÜ&gt;
(f ‚¶ø ctx) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk354" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk354"><span class="kn">Lemma</span> <span class="nf">ap_spec</span> {<span class="nv">G</span>}: <span class="kr">forall</span> `{Applicative G} (g: G (A -&gt; B)),
      ap G g = map (F := G) applyFn ‚àò mult ‚àò pair g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Map_G</span> : Map G) (<span class="nv">Pure_G</span> : Pure G)
  (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">g</span> : G (A -&gt; B),
ap G g = map applyFn ‚àò mult ‚àò pair g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk355" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk355"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Map_G</span> : Map G) (<span class="nv">Pure_G</span> : Pure G)
  (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">g</span> : G (A -&gt; B),
ap G g = map applyFn ‚àò mult ‚àò pair g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk356" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk356"><span class="kn">Lemma</span> <span class="nf">mult_pair_spec</span> {<span class="nv">G</span>}: <span class="kr">forall</span> `{Applicative G} (g: G A),
      mult (F := G) ‚àò pair g (B := G B) =
        mult (F := G) ‚àò pair g (B := G B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Map_G</span> : Map G) (<span class="nv">Pure_G</span> : Pure G)
  (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">g</span> : G A, mult ‚àò pair g = mult ‚àò pair g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk357" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk357"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Map_G</span> : Map G) (<span class="nv">Pure_G</span> : Pure G)
  (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> <span class="nv">g</span> : G A, mult ‚àò pair g = mult ‚àò pair g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk358" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk358"><span class="kn">Lemma</span> <span class="nf">kc_preincr2</span>
    (<span class="nv">g</span>: list B * B -&gt; G2 C)
    (<span class="nv">f</span>: list A * A -&gt; G1 B)
    (<span class="nv">ctx</span>: list A):
    (g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx =
      map (F := G1) g ‚àò
        ap G1 (map incr (traverse f (decorate_prefix_list ctx))) ‚àò
        traverse (f ‚¶ø ctx) ‚àò cojoin (W := Z) (A := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚¶ø ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk359" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk359"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚¶ø ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk35a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk35a"><span class="nb">rewrite</span> kc_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap G1
  (map (preincr g)
     (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚¶ø ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚¶ø ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk35b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk35b"><span class="nb">unfold</span> preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap G1
  (map (compose g ‚óã incr)
     (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚àò incr ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚àò incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk35c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk35c"><span class="nb">change</span> (<span class="nl">?x</span> ‚óã <span class="nl">?y</span>) <span class="kr">with</span> (x ‚àò y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap G1
  (map (compose g ‚àò incr)
     (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚àò incr ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚àò incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk35d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk35d"><span class="nb">rewrite</span> &lt;- fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap G1
  ((map (compose g) ‚àò map incr)
     (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚àò incr ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚àò incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk35e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk35e"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap G1
  (map (compose g)
     (map incr (traverse f (decorate_prefix_list ctx))))
‚àò mapdt_ci (f ‚àò incr ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚àò incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk35f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk35f"><span class="nb">change</span> (ap G1 (map (compose g)
                     (map incr (traverse f (decorate_prefix_list ctx))))) <span class="kr">with</span>
      ((ap G1 ‚àò map (compose g))
         (map incr (traverse f (decorate_prefix_list ctx)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap G1 ‚àò map (compose g))
  (map incr (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚àò incr ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚àò incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk360" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk360"><span class="nb">rewrite</span> &lt;- map_ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(compose (map g) ‚àò ap G1)
  (map incr (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚àò incr ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚àò incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk361" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk361"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò mapdt_ci (f ‚àò incr ctx) =
map g
‚àò ap G1
    (map incr (traverse f (decorate_prefix_list ctx)))
‚àò traverse (f ‚àò incr ctx) ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">preincrement_kc</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** *** Kleisli composition with preincrement *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk362" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk362"><span class="kn">Lemma</span> <span class="nf">kc_preincr1</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>}
  `{G1: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G1} `{Mult G1} `{Pure G1} `{! Applicative G1}
  `{G2: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G2} `{Mult G2} `{Pure G2}
  (g: list B * B -&gt; G2 C) (f: list A * A -&gt; G1 B)
  (ctx: list A): <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">a</span>,
    ((kc3_ci (G1 := G1) (G2 := G2) g f) ‚¶ø ctx) (l, a) =
      map g (map incr (traverse f (decorate_prefix_list ctx))
               &lt;‚ãÜ&gt; traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
((g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk363" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk363"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
((g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk364" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk364"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((g ‚ãÜ<span class="mi">3_</span>ci f) ‚¶ø ctx) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk365" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk365"><span class="nb">unfold</span> kc3_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((map g ‚àò mapdt_ci f) ‚¶ø ctx) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk366" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk366"><span class="nb">rewrite</span> (preincr_assoc
             (map (F := G1) (A := Z B) g)
             (mapdt_ci f (W := Z))
             ctx).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò mapdt_ci f ‚¶ø ctx) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk367" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk367"><span class="nb">unfold</span> mapdt_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò Mapdt_CommIdem_Z G1 H H1 H0 A B f ‚¶ø ctx)
  (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk368" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk368"><span class="nb">unfold</span> Mapdt_CommIdem_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò (traverse f ‚àò cojoin) ‚¶ø ctx) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk369" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk369">unfold_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò (traverse f ‚àò cojoin) ‚¶ø ctx) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk36a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk36a"><span class="nb">rewrite</span> preincr_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g ‚àò (traverse f ‚àò cojoin ‚¶ø ctx)) (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk36b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk36b">fold_Z; <span class="nb">change</span> (Z (Z <span class="nl">?A</span>)) <span class="kr">with</span> ((Z ‚àò Z) A);
    <span class="nb">rewrite</span> (cojoin_Z_rw_preincr_pf (A := A) ctx).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map g
 ‚àò (traverse f
    ‚àò (map_pair
         (app (decorate_prefix_list ctx)
          ‚àò map (incr ctx)) (incr ctx) ‚àò cojoin)))
  (l, a) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk36c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk36c"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (traverse f
     (map_pair
        (app (decorate_prefix_list ctx)
         ‚àò map (incr ctx)) (incr ctx) (cojoin (l, a)))) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk36d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk36d">unfold_ops @Cojoin_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (traverse f
     (map_pair
        (app (decorate_prefix_list ctx)
         ‚àò map (incr ctx)) (incr ctx)
        (decorate_prefix_list l, (l, a)))) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk36e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk36e">compose near (decorate_prefix_list l, (l, a)) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  ((traverse f
    ‚àò map_pair
        (app (decorate_prefix_list ctx)
         ‚àò map (incr ctx)) (incr ctx))
     (decorate_prefix_list l, (l, a))) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk36f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk36f"><span class="nb">rewrite</span> (traverse_Z_incr3 f ctx (decorate_prefix_list l) l a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; G1 B</span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a))) =
map g
  (map incr (traverse f (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
   traverse (f ‚¶ø ctx) (decorate_prefix_list l, (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(*</span>
<span class="c">  Context</span>
<span class="c">  {E A B C: Type}</span>
<span class="c">  {G1 G2: Type -&gt; Type}</span>
<span class="c">  `{Map G1} `{Pure G1} `{Mult G1}</span>
<span class="c">  `{Map G2} `{Pure G2} `{Mult G2}.</span>

<span class="c">  Section Traverse_Reader.</span>

<span class="c">  Context {E: Type}.</span>

<span class="c">  (*</span>
<span class="c">  #[export] Instance Dist_Reader: Mult (prod E) :=</span>
<span class="c">  strength.</span>
<span class="c"> *)</span>

<span class="c"> #[export] Instance Traverse_Reader: Traverse (prod E).</span>
<span class="c"> Proof.</span>
<span class="c"> intros G Gmap Gpure Gmult A B f.</span>
<span class="c"> exact (strength ‚àò map (F := prod E) f).</span>
<span class="c"> Defined.</span>

<span class="c"> #[export] Instance Mapdt_Reader: Mapdt E (prod E).</span>
<span class="c"> Proof.</span>
<span class="c"> intros G Gmap Gpure Gmult A B f.</span>
<span class="c"> exact (strength ‚àò cobind f).</span>
<span class="c"> Defined.</span>

<span class="c"> End Traverse_Reader.</span>

<span class="c"> Definition test</span>
<span class="c"> (g: E * B -&gt; G2 C)</span>
<span class="c"> (f: E * A -&gt; G1 B):</span>
<span class="c"> (E * A -&gt; G1 (G2 C)) :=</span>
<span class="c"> map g ‚àò mapdt f.</span>

<span class="c"> Goal test = kc3.</span>
<span class="c"> ext g f.</span>
<span class="c"> unfold kc3.</span>
<span class="c"> unfold test.</span>
<span class="c"> unfold mapdt.</span>
<span class="c"> unfold Mapdt_Reader.</span>
<span class="c"> unfold test.</span>
<span class="c"> reflexivity.</span>
<span class="c"> Qed.</span>
<span class="c"> *)</span>

<span class="sd">(** * Decorate traversable functor instance *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Unit law *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk370" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk370"><span class="kn">Lemma</span> <span class="nf">kdtfci_mapdt1_list_prefix</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
    mapdt_list_prefix (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) extract = @id (list A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt_list_prefix extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk371" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk371"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt_list_prefix extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk372" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk372"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk373" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk373">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix extract l = id l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk374" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk374"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix extract [] = id []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk375" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix extract l = id l</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk375"><hr></label><div class="goal-conclusion">mapdt_list_prefix extract (a :: l) = id (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk376" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk376">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix extract [] = id []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk377" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk377"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] = id []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk378" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk378">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix extract (a :: l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk379" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk379"><span class="nb">rewrite</span> mapdt_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; extract ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (extract ‚¶ø [a]) l = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk37a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk37a"><span class="nb">rewrite</span> extract_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; extract ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix extract l = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk37b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk37b"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; extract ([], a) &lt;‚ãÜ&gt; id l = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Composition law (Indirect proof) *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk37c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk37c"><span class="kn">Lemma</span> <span class="nf">kdtfci_mapdt2_list_prefix</span>:
  <span class="kr">forall</span> `{ApplicativeCommutativeIdempotent G1}
    `{ApplicativeCommutativeIdempotent G2}
    {A B C: <span class="kt">Type</span>} (g: Z B -&gt; G2 C) (f: Z A -&gt; G1 B),
    map (mapdt_list_prefix g) ‚àò mapdt_list_prefix f =
      mapdt_list_prefix (G := G1 ‚àò G2) (g ‚ãÜ<span class="mi">3_</span>ci f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G1)
  (<span class="nv">pureG</span> : Pure G1) (<span class="nv">multG</span> : Mult G1),
ApplicativeCommutativeIdempotent G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG0</span> : Map G2)
  (<span class="nv">pureG0</span> : Pure G2) (<span class="nv">multG0</span> : Mult G2),
ApplicativeCommutativeIdempotent G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; G2 C)
  (<span class="nv">f</span> : Z A -&gt; G1 B),
map (mapdt_list_prefix g) ‚àò mapdt_list_prefix f =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk37d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk37d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G1)
  (<span class="nv">pureG</span> : Pure G1) (<span class="nv">multG</span> : Mult G1),
ApplicativeCommutativeIdempotent G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG0</span> : Map G2)
  (<span class="nv">pureG0</span> : Pure G2) (<span class="nv">multG0</span> : Mult G2),
ApplicativeCommutativeIdempotent G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; G2 C)
  (<span class="nv">f</span> : Z A -&gt; G1 B),
map (mapdt_list_prefix g) ‚àò mapdt_list_prefix f =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk37e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk37e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt_list_prefix g) ‚àò mapdt_list_prefix f =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk37f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk37f"><span class="nb">unfold</span> mapdt_list_prefix <span class="nb">at</span> <span class="mi">1</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g ‚àò decorate_prefix_list)
‚àò (traverse f ‚àò decorate_prefix_list) =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk380" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk380"><span class="nb">rewrite</span> &lt;- fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g) ‚àò map decorate_prefix_list
‚àò (traverse f ‚àò decorate_prefix_list) =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk381" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk381">reassociate -&gt; on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g)
‚àò (map decorate_prefix_list
   ‚àò (traverse f ‚àò decorate_prefix_list)) =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk382" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk382">reassociate &lt;- near (map decorate_prefix_list).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g)
‚àò (map decorate_prefix_list ‚àò traverse f
   ‚àò decorate_prefix_list) =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk383" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk383"><span class="nb">rewrite</span> decorate_commute.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g)
‚àò (traverse (traverse f) ‚àò decorate_prefix_list
   ‚àò decorate_prefix_list) =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk384" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk384"><span class="kp">do</span> <span class="mi">2</span> reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g) ‚àò traverse (traverse f)
‚àò decorate_prefix_list ‚àò decorate_prefix_list =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk385" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk385"><span class="nb">rewrite</span> (trf_traverse_traverse).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (kc2 g (traverse f)) ‚àò decorate_prefix_list
‚àò decorate_prefix_list = mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk386" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk386"><span class="nb">change</span> (traverse (T := list) <span class="nl">?f</span> ‚àò decorate_prefix_list)
    <span class="kr">with</span>  (mapdt_list_prefix f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix (kc2 g (traverse f))
‚àò decorate_prefix_list = mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk387" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk387"><span class="nb">rewrite</span> (mapdt_list_prefix_decorate
             (A := A) (B := C) (G := G1 ‚àò G2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix (kc2 g (traverse f) ‚àò cojoin) =
mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">(** ** Composition law (Direct Proof!) *)</span>
<span class="c">(**********************************************************************)</span>
<span class="c">Lemma kdtfci_mapdt2_list_prefix2_lemma1 {G1 G2}:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">    `{ApplicativeCommutativeIdempotent G2}</span>
<span class="c">    {A B C: Type} (g: Z B -&gt; G2 C) (f: Z A -&gt; G1 B) (ctx: list A),</span>
<span class="c">    mapdt_list_prefix (G := G1 ‚àò G2) ((g ‚ãÜ3_ci f) ‚¶ø ctx) =</span>
<span class="c">      mapdt_list_prefix (G := G1 ‚àò G2) (g ‚ãÜ3_ci (f ‚¶ø ctx)).</span>
<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  rewrite kc_preincr2.</span>
<span class="c">  change (map _ g ‚àò ?x ‚àò ?y ‚àò ?z) with (g ‚ãÜ2 (x ‚àò y ‚àò z)).</span>
<span class="c">  unfold mapdt_list_prefix at 1.</span>
<span class="c">Abort.</span>

<span class="c">Lemma kdtfci_mapdt2_list_prefix_direct_lemma2:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">    `{ApplicativeCommutativeIdempotent G2}</span>
<span class="c">    {A B: Type} (f: Z A -&gt; G1 B),</span>
<span class="c">  forall (ctx: list A),</span>
<span class="c">    ap G1 (map (F := G1) incr</span>
<span class="c">             (traverse (T := list) f (decorate_prefix_list ctx)))</span>
<span class="c">      ‚àò traverse (T := Z) (f ‚¶ø ctx) =</span>
<span class="c">      traverse_pair (ap G1 (pure (app (A:=B))</span>
<span class="c">                              &lt;‚ãÜ&gt; traverse (T := list) f (decorate_prefix_list ctx))</span>
<span class="c">                       ‚àò traverse (T := list) (f ‚¶ø ctx))</span>
<span class="c">        (f ‚¶ø ctx).</span>
<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  ext [binders leaf].</span>
<span class="c">  unfold compose at 1.</span>
<span class="c">  rewrite traverse_Z_spec.</span>
<span class="c">  unfold traverse_pair.</span>
<span class="c">  rewrite map_to_ap.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap3.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  (* RHS *)</span>
<span class="c">  unfold compose at 6.</span>
<span class="c">  try rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  reflexivity.</span>
<span class="c">Qed.</span>


<span class="c">Lemma kdtfci_mapdt2_list_prefix_direct_lemma3:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">    `{ApplicativeCommutativeIdempotent G2}</span>
<span class="c">    {A B: Type} (f: Z A -&gt; G1 B),</span>
<span class="c">  forall (ctx: list A),</span>
<span class="c">    traverse (T := Z) f ‚àò cojoin (W := Z) ‚àò incr ctx =</span>
<span class="c">      ap G1 (map (F := G1) incr (traverse (T := list) f (decorate_prefix_list ctx)))</span>
<span class="c">        ‚àò traverse (T := Z) (f ‚¶ø ctx) ‚àò cojoin.</span>

<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  symmetry.</span>
<span class="c">  ext [binders leaf].</span>
<span class="c">  unfold compose at 1 2.</span>
<span class="c">  rewrite map_to_ap.</span>
<span class="c">  cbn.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  repeat rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap3.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  change (?l ‚óè ?r) with (l ++ r).</span>
<span class="c">  rewrite decorate_prefix_list_rw_app.</span>
<span class="c">  rewrite (traverse_list_app G1).</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  compose near (decorate_prefix_list binders) on right.</span>
<span class="c">  rewrite traverse_map.</span>
<span class="c">  reflexivity.</span>
<span class="c">Qed.</span>

<span class="c">(*</span>
<span class="c">  Lemma kdtfci_mapdt2_list_prefix_direct_lemma4:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">  {A B: Type} (f: Z A -&gt; G1 B) (ctx: list A),</span>
<span class="c">  ap G1 (pure (app (A:=B))</span>
<span class="c">  &lt;‚ãÜ&gt; traverse list f (decorate_prefix_list ctx))</span>
<span class="c">  ‚àò traverse list (f ‚¶ø ctx)</span>
<span class="c">  = traverse list f ‚àò app (decorate_prefix_list ctx).</span>
<span class="c">  Proof.</span>
<span class="c">  intros.</span>
<span class="c">  ext lz.</span>
<span class="c">  unfold compose.</span>
<span class="c">  generalize dependent f.</span>
<span class="c">  induction lz; intros f.</span>
<span class="c">  - cbn.</span>
<span class="c">  rewrite (traverse_list_app G1).</span>
<span class="c">  cbn.</span>
<span class="c">  reflexivity.</span>
<span class="c">  - rewrite traverse_list_cons.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite ap3.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>

<span class="c">  rewrite (traverse_list_app G1).</span>
<span class="c">  rewrite (traverse_list_cons).</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  rewrite ap3.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  Abort.</span>



<span class="c">  Lemma kdtfci_mapdt2_list_prefix_direct_lemma5:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">  {A B: Type} (f: Z A -&gt; G1 B) (ctx: A) (l: list A),</span>
<span class="c">  traverse list</span>
<span class="c">  (traverse_pair (traverse list f ‚àò (app (decorate_prefix_list [ctx]) ‚àò map list (incr [ctx])))</span>
<span class="c">  (f ‚¶ø [ctx]) ‚àò cojoin) (decorate_prefix_list l)</span>
<span class="c">  =</span>
<span class="c">  map G1 (map list ‚àò incr (A := B)) (traverse list f (decorate_prefix_list [ctx]))</span>
<span class="c">  &lt;‚ãÜ&gt;</span>
<span class="c">  (traverse list</span>
<span class="c">  (traverse_pair (traverse list f ‚àò map list (incr [ctx]))</span>
<span class="c">  (f ‚¶ø [ctx]) ‚àò cojoin) (decorate_prefix_list l)).</span>
<span class="c">  Proof.</span>
<span class="c">  intros.</span>
<span class="c">  induction l as [| a as&#39; IHas].</span>
<span class="c">  - unfold compose. cbn.</span>
<span class="c">  Abort.</span>

<span class="c">  Lemma kdtfci_mapdt2_list_prefix_direct_lemma6:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">  {A B: Type} (f: Z A -&gt; G1 B),</span>
<span class="c">  traverse list (traverse Z f ‚àò cojoin) ‚àò decorate_prefix_list =</span>
<span class="c">  map G1 decorate_prefix_list ‚àò traverse list f ‚àò decorate_prefix_list.</span>
<span class="c">  Proof.</span>
<span class="c">  intros.</span>
<span class="c">  ext l.</span>
<span class="c">  unfold compose at 1 3 4.</span>
<span class="c">  generalize dependent f.</span>
<span class="c">  induction l as [| a as&#39; IHas]; intro f.</span>
<span class="c">  - cbn.</span>
<span class="c">  rewrite app_pure_natural.</span>
<span class="c">  reflexivity.</span>
<span class="c">  - remember (map G1 decorate_prefix_list (traverse list f (decorate_prefix_list (a :: as&#39;)))) as rhs.</span>
<span class="c">  (* LHS *)</span>
<span class="c">  rewrite decorate_prefix_list_rw_cons.</span>
<span class="c">  rewrite traverse_list_cons.</span>
<span class="c">  unfold compose at 1.</span>
<span class="c">  cbn.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite &lt;- ap4; repeat rewrite ap2.</span>
<span class="c">  compose near (decorate_prefix_list as&#39;) on left.</span>
<span class="c">  rewrite traverse_map.</span>
<span class="c">  reassociate -&gt; on left.</span>
<span class="c">  change (?x ‚àò incr ?y) with (x ‚¶ø y).</span>
<span class="c">  rewrite cojoin_Z_rw_preincr_pf.</span>
<span class="c">  reassociate &lt;- on left.</span>
<span class="c">  rewrite traverse_Z_map.</span>

<span class="c">  (* RHS *)</span>
<span class="c">  rewrite Heqrhs.</span>
<span class="c">  rewrite (decorate_prefix_list_rw_cons a as&#39;).</span>
<span class="c">  rewrite traverse_list_cons.</span>
<span class="c">  rewrite map_ap.</span>
<span class="c">  rewrite map_ap.</span>
<span class="c">  rewrite app_pure_natural.</span>
<span class="c">  destruct as&#39;.</span>
<span class="c">  + cbn. admit.</span>
<span class="c">  + cbn.</span>
<span class="c">  Abort.</span>

<span class="c">  Lemma kdtfci_mapdt2_list_prefix_direct_lemma:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">  `{ApplicativeCommutativeIdempotent G2}</span>
<span class="c">  {A B C: Type} (g: Z B -&gt; G2 C) (f: Z A -&gt; G1 B) (ctx: list A),</span>
<span class="c">  map G1 (mapdt_list_prefix g) ‚àò (fun l =&gt; pure (@app B) &lt;‚ãÜ&gt; mapdt_list_prefix f ctx &lt;‚ãÜ&gt; mapdt_list_prefix (f ‚¶ø ctx) l) =</span>
<span class="c">  mapdt_list_prefix (G := G1 ‚àò G2) (g ‚ãÜ3_ci f) ‚àò app ctx.</span>
<span class="c">  Proof.</span>
<span class="c">  intros.</span>
<span class="c">  ext l.</span>
<span class="c">  (* LHS *)</span>
<span class="c">  unfold compose at 1.</span>
<span class="c">  rewrite map_ap.</span>
<span class="c">  rewrite map_ap.</span>
<span class="c">  rewrite app_pure_natural.</span>

<span class="c">  (* RHS *)</span>
<span class="c">  unfold compose at 3.</span>
<span class="c">  rewrite mapdt_list_prefix_rw_app.</span>
<span class="c">  unfold pure at 2; unfold Pure_compose.</span>
<span class="c">  rewrite (ap_compose2 G2 G1).</span>
<span class="c">  rewrite (ap_compose2 G2 G1).</span>
<span class="c">  rewrite map_ap.</span>
<span class="c">  rewrite app_pure_natural.</span>
<span class="c">  rewrite app_pure_natural.</span>
<span class="c">  generalize dependent f.</span>
<span class="c">  induction l as [| a as&#39; IHas ]; intro f.</span>
<span class="c">  - cbn.</span>
<span class="c">  rewrite ap3.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  unfold pure at 6.</span>
<span class="c">  rewrite ap3.</span>
<span class="c">  rewrite &lt;- ap4.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  rewrite ap2.</span>
<span class="c">  Abort.</span>

<span class="c">  Lemma kdtfci_mapdt2_list_prefix_direct:</span>
<span class="c">  forall `{ApplicativeCommutativeIdempotent G1}</span>
<span class="c">  `{ApplicativeCommutativeIdempotent G2}</span>
<span class="c">  {A B C: Type} (g: Z B -&gt; G2 C) (f: Z A -&gt; G1 B),</span>
<span class="c">  map G1 (mapdt_list_prefix g) ‚àò mapdt_list_prefix f =</span>
<span class="c">  mapdt_list_prefix (G := G1 ‚àò G2) (g ‚ãÜ3_ci f).</span>
<span class="c">  Proof.</span>
<span class="c">  intros.</span>
<span class="c">  ext l.</span>
<span class="c">  unfold compose at 1.</span>
<span class="c">  generalize dependent f.</span>
<span class="c">  induction l as [| a as&#39; IHas ]; intro f.</span>
<span class="c">  -  cbn.</span>
<span class="c">  rewrite app_pure_natural.</span>
<span class="c">  reflexivity.</span>
<span class="c">  -  (*</span>
<span class="c">  remember (map G1 (mapdt_list_prefix g) (mapdt_list_prefix f (a :: as&#39;)))</span>
<span class="c">  as lhs.</span>
<span class="c"> *)</span>
<span class="c"> (* LHS *)</span>
<span class="c"> rewrite mapdt_list_prefix_rw_cons.</span>
<span class="c"> rewrite map_ap.</span>
<span class="c"> rewrite map_ap.</span>
<span class="c"> rewrite app_pure_natural.</span>

<span class="c"> (* RHS *)</span>
<span class="c"> rewrite mapdt_list_prefix_rw_cons.</span>

<span class="c"> (* Unroll applicative composition *)</span>
<span class="c"> unfold_ops @Pure_compose.</span>
<span class="c"> rewrite (ap_compose2 G2 G1).</span>
<span class="c"> rewrite (ap_compose2 G2 G1).</span>
<span class="c"> rewrite app_pure_natural.</span>
<span class="c"> rewrite map_ap.</span>
<span class="c"> rewrite app_pure_natural.</span>

<span class="c"> (* inner *)</span>
<span class="c"> unfold kc3_ci at 1.</span>
<span class="c"> unfold compose at 4 5.</span>
<span class="c"> rewrite &lt;- ap_map.</span>
<span class="c"> rewrite app_pure_natural.</span>
<span class="c"> rewrite &lt;- ap4.</span>
<span class="c"> rewrite ap2.</span>
<span class="c"> rewrite ap2.</span>
<span class="c"> rewrite ap2.</span>

<span class="c"> (* outer *)</span>
<span class="c"> rewrite kc_preincr2.</span>
<span class="c"> unfold mapdt_list_prefix at 3.</span>
<span class="c"> change (map _ g ‚àò ?x ‚àò ?y ‚àò ?z) with (g ‚ãÜ2 (x ‚àò y ‚àò z)).</span>
<span class="c"> rewrite &lt;- trf_traverse_traverse.</span>
<span class="c"> rewrite &lt;- traverse_map.</span>
<span class="c"> Abort.</span>
<span class="c"> *)</span>
<span class="c">*)</span>

<span class="sd">(** ** Homomorphism law *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk388" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk388"><span class="kn">Lemma</span> <span class="nf">kdtfci_morph_list_prefix</span>:
  <span class="kr">forall</span> `{ApplicativeMorphism G1 G2 œï}
    {A B: <span class="kt">Type</span>} (f: Z A -&gt; G1 B),
    mapdt_ci (œï B ‚àò f) =
      œï (list B) ‚àò mapdt_ci (W := Z) (T := list) (A := A) (B := B) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z A -&gt; G1 B),
mapdt_ci (œï B ‚àò f) = œï (list B) ‚àò mapdt_ci f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk389" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk389"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z A -&gt; G1 B),
mapdt_ci (œï B ‚àò f) = œï (list B) ‚àò mapdt_ci f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk38a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk38a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) = œï (list B) ‚àò mapdt_ci f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk38b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk38b">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) l = (œï (list B) ‚àò mapdt_ci f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk38c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk38c"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) l = (œï (list B) ‚àò mapdt_ci f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk38d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk38d"><span class="nb">induction</span> l <span class="kr">as</span> [| b bs IHbs ]; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) [] = (œï (list B) ‚àò mapdt_ci f) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk38e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk38e"><hr></label><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) (b :: bs) =
(œï (list B) ‚àò mapdt_ci f) (b :: bs)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk38f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk38f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) [] = (œï (list B) ‚àò mapdt_ci f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk390" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk390"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚óã f) [] = œï (list B) (mapdt_ci f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk391" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk391"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] = œï (list B) (pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> appmor_pure.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk392" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk392">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) (b :: bs) =
(œï (list B) ‚àò mapdt_ci f) (b :: bs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk393" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk393"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò f)
  (map (incr [b]) (decorate_prefix_list bs)) =
(œï (list B) ‚àò mapdt_ci f) (b :: bs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk394" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk394"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò f)
  (map (incr [b]) (decorate_prefix_list bs)) =
œï (list B) (mapdt_ci f (b :: bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk395" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk395"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò f)
  (map (incr [b]) (decorate_prefix_list bs)) =
œï (list B)
  (pure cons &lt;‚ãÜ&gt; f ([], b) &lt;‚ãÜ&gt;
   traverse f
     (map (incr [b]) (decorate_prefix_list bs)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk396" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk396"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò f)
  (map (incr [b]) (decorate_prefix_list bs)) =
œï (list B -&gt; list B) (pure cons &lt;‚ãÜ&gt; f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  (traverse f
     (map (incr [b]) (decorate_prefix_list bs)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk397" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk397"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò f)
  (map (incr [b]) (decorate_prefix_list bs)) =
œï (B -&gt; list B -&gt; list B) (pure cons) &lt;‚ãÜ&gt;
œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  (traverse f
     (map (incr [b]) (decorate_prefix_list bs)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk398" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk398"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò f)
  (map (incr [b]) (decorate_prefix_list bs)) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  (traverse f
     (map (incr [b]) (decorate_prefix_list bs)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk399" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk399">compose near (decorate_prefix_list bs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
(traverse (œï B ‚àò f) ‚àò map (incr [b]))
  (decorate_prefix_list bs) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  ((traverse f ‚àò map (incr [b]))
     (decorate_prefix_list bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk39a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk39a"><span class="nb">assert</span> (Applicative G2) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> H5.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
(traverse (œï B ‚àò f) ‚àò map (incr [b]))
  (decorate_prefix_list bs) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  ((traverse f ‚àò map (incr [b]))
     (decorate_prefix_list bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk39b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk39b"><span class="nb">rewrite</span> (traverse_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò f ‚àò incr [b])
  (decorate_prefix_list bs) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  ((traverse f ‚àò map (incr [b]))
     (decorate_prefix_list bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk39c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk39c">reassociate -&gt; near (incr [b]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
traverse (œï B ‚àò (f ‚àò incr [b]))
  (decorate_prefix_list bs) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  ((traverse f ‚àò map (incr [b]))
     (decorate_prefix_list bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk39d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk39d"><span class="nb">rewrite</span> &lt;- trf_traverse_morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
(œï (list B) ‚àò traverse (f ‚àò incr [b]))
  (decorate_prefix_list bs) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  ((traverse f ‚àò map (incr [b]))
     (decorate_prefix_list bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk39e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk39e"><span class="nb">assert</span> (Applicative G1) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">inversion</span> H5.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
(œï (list B) ‚àò traverse (f ‚àò incr [b]))
  (decorate_prefix_list bs) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  ((traverse f ‚àò map (incr [b]))
     (decorate_prefix_list bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk39f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk39f"><span class="nb">rewrite</span> (traverse_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bs</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHbs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; G1 B,
mapdt_ci (œï B ‚àò f) bs =
(œï (list B) ‚àò mapdt_ci f) bs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; (œï B ‚àò f) ([], b) &lt;‚ãÜ&gt;
(œï (list B) ‚àò traverse (f ‚àò incr [b]))
  (decorate_prefix_list bs) =
pure cons &lt;‚ãÜ&gt; œï B (f ([], b)) &lt;‚ãÜ&gt;
œï (list B)
  (traverse (f ‚àò incr [b]) (decorate_prefix_list bs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Typeclass Instance *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedTraversableCommIdemFunctor_list_prefix</span>:
  DecoratedTraversableCommIdemFunctor Z list :=
  { kdtfci_mapdt1 := kdtfci_mapdt1_list_prefix;
    kdtfci_mapdt2 := @kdtfci_mapdt2_list_prefix;
    kdtfci_morph  := @kdtfci_morph_list_prefix
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a0">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedTraversableCommIdemFunctor_Z_Z</span>:
  DecoratedTraversableCommIdemFunctor Z Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableCommIdemFunctor Z Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableCommIdemFunctor Z Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a2"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt_ci extract = id</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G1)
  (<span class="nv">pureG</span> : Pure G1) (<span class="nv">multG</span> : Mult G1),
ApplicativeCommutativeIdempotent G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG0</span> : Map G2)
  (<span class="nv">pureG0</span> : Pure G2) (<span class="nv">multG0</span> : Mult G2),
ApplicativeCommutativeIdempotent G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; G2 C)
  (<span class="nv">f</span> : Z A -&gt; G1 B),
map (mapdt_ci g) ‚àò mapdt_ci f = mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z A -&gt; G1 B),
mapdt_ci (œï B ‚àò f) = œï (Z B) ‚àò mapdt_ci f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt_ci extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a5">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci extract (l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a6"><span class="nb">rewrite</span> mapdt_Z_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; mapdt_ci extract l &lt;‚ãÜ&gt; extract (l, a) =
id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a7">unfold_ops @Pure_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id pair (mapdt_ci extract l) (extract (l, a)) =
id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a8"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapdt_ci extract l, extract (l, a)) = (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3a9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3a9"><span class="nb">rewrite</span> kdtfci_mapdt1_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id l, extract (l, a)) = (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3aa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3aa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G1)
  (<span class="nv">pureG</span> : Pure G1) (<span class="nv">multG</span> : Mult G1),
ApplicativeCommutativeIdempotent G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG0</span> : Map G2)
  (<span class="nv">pureG0</span> : Pure G2) (<span class="nv">multG0</span> : Mult G2),
ApplicativeCommutativeIdempotent G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; G2 C)
  (<span class="nv">f</span> : Z A -&gt; G1 B),
map (mapdt_ci g) ‚àò mapdt_ci f = mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ab" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ab"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt_ci g) ‚àò mapdt_ci f = mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ac" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ac">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt_ci g) ‚àò mapdt_ci f) (l, a) =
mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ad" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ad"><span class="nb">rewrite</span> mapdt_Z_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt_ci g) ‚àò mapdt_ci f) (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ae" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ae"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt_ci g) (mapdt_ci f (l, a)) =
pure pair &lt;‚ãÜ&gt; mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3af" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3af"><span class="nb">rewrite</span> mapdt_Z_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt_ci g)
  (pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)) =
pure pair &lt;‚ãÜ&gt; mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b0"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g))
  (pure pair &lt;‚ãÜ&gt; mapdt_ci f l) &lt;‚ãÜ&gt; f (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b1"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (mapdt_ci g))) (pure pair) &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b2"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_ci (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b3"><span class="nb">unfold</span> mapdt_ci <span class="nb">at</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure pair &lt;‚ãÜ&gt;
Mapdt_CommIdem_list_prefix (G1 ‚àò G2)
  (Map_compose G1 G2) (Pure_compose G1 G2)
  (Mult_compose G1 G2) A C (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b4"><span class="nb">unfold</span> Mapdt_CommIdem_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure pair &lt;‚ãÜ&gt; mapdt_list_prefix (g ‚ãÜ<span class="mi">3_</span>ci f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b5"><span class="nb">rewrite</span> &lt;- kdtfci_mapdt2_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure pair &lt;‚ãÜ&gt;
(map (mapdt_list_prefix g) ‚àò mapdt_list_prefix f) l &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b6"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">6</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure pair &lt;‚ãÜ&gt;
map (mapdt_list_prefix g) (mapdt_list_prefix f l) &lt;‚ãÜ&gt;
(g ‚ãÜ<span class="mi">3_</span>ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b7"><span class="nb">unfold</span> kc3_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure pair &lt;‚ãÜ&gt;
map (mapdt_list_prefix g) (mapdt_list_prefix f l) &lt;‚ãÜ&gt;
(map g ‚àò mapdt_ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b8"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">6</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure pair &lt;‚ãÜ&gt;
map (mapdt_list_prefix g) (mapdt_list_prefix f l) &lt;‚ãÜ&gt;
map g (mapdt_ci f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3b9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3b9"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (ap G2)
  (pure pair &lt;‚ãÜ&gt;
   map (mapdt_list_prefix g) (mapdt_list_prefix f l)) &lt;‚ãÜ&gt;
map g (mapdt_ci f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ba" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ba"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (ap G2)
  (map (ap G2) (pure pair) &lt;‚ãÜ&gt;
   map (mapdt_list_prefix g) (mapdt_list_prefix f l)) &lt;‚ãÜ&gt;
map g (mapdt_ci f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3bb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3bb">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (ap G2)
  (map (ap G2) (pure (pure pair)) &lt;‚ãÜ&gt;
   map (mapdt_list_prefix g) (mapdt_list_prefix f l)) &lt;‚ãÜ&gt;
map g (mapdt_ci f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3bc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3bc"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (ap G2)
  (pure (ap G2 (pure pair)) &lt;‚ãÜ&gt;
   map (mapdt_list_prefix g) (mapdt_list_prefix f l)) &lt;‚ãÜ&gt;
map g (mapdt_ci f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3bd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3bd"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (precompose g)
  (map (ap G2)
     (pure (ap G2 (pure pair)) &lt;‚ãÜ&gt;
      map (mapdt_list_prefix g)
        (mapdt_list_prefix f l))) &lt;‚ãÜ&gt;
mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3be" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3be"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (precompose g)
  (map (compose (ap G2)) (pure (ap G2 (pure pair))) &lt;‚ãÜ&gt;
   map (mapdt_list_prefix g) (mapdt_list_prefix f l)) &lt;‚ãÜ&gt;
mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3bf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3bf"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (compose (precompose g))
  (map (compose (ap G2)) (pure (ap G2 (pure pair)))) &lt;‚ãÜ&gt;
map (mapdt_list_prefix g) (mapdt_list_prefix f l) &lt;‚ãÜ&gt;
mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c0"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (compose (precompose g))
  (pure (ap G2 ‚àò ap G2 (pure pair))) &lt;‚ãÜ&gt;
map (mapdt_list_prefix g) (mapdt_list_prefix f l) &lt;‚ãÜ&gt;
mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c1"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair))) &lt;‚ãÜ&gt;
map (mapdt_list_prefix g) (mapdt_list_prefix f l) &lt;‚ãÜ&gt;
mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c2"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
map (precompose (mapdt_list_prefix g))
  (pure (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
mapdt_list_prefix f l &lt;‚ãÜ&gt; mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c3"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure
  (precompose (mapdt_list_prefix g)
     (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
mapdt_list_prefix f l &lt;‚ãÜ&gt; mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c4"><span class="nb">rewrite</span> mapdt_Z_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure
  (precompose (mapdt_list_prefix g)
     (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
mapdt_list_prefix f l &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure compose &lt;‚ãÜ&gt;
(pure
   (precompose (mapdt_list_prefix g)
      (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
 mapdt_list_prefix f l) &lt;‚ãÜ&gt;
(pure pair &lt;‚ãÜ&gt; mapdt_ci f l) &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c6"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt_ci g) ‚àò pair) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a) =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt;
 (pure
    (precompose (mapdt_list_prefix g)
       (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
  mapdt_list_prefix f l)) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c7"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
pure compose &lt;‚ãÜ&gt;
(pure compose &lt;‚ãÜ&gt;
 (pure
    (precompose (mapdt_list_prefix g)
       (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
  mapdt_list_prefix f l)) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c8"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map compose
  (pure compose &lt;‚ãÜ&gt;
   (pure
      (precompose (mapdt_list_prefix g)
         (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
    mapdt_list_prefix f l)) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3c9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3c9"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map compose
  (map compose
     (pure
        (precompose (mapdt_list_prefix g)
           (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))) &lt;‚ãÜ&gt;
      mapdt_list_prefix f l)) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ca" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ca"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map compose
  (map (compose compose)
     (pure
        (precompose (mapdt_list_prefix g)
           (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair))))) &lt;‚ãÜ&gt;
   mapdt_list_prefix f l) &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3cb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3cb"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map (compose compose)
  (map (compose compose)
     (pure
        (precompose (mapdt_list_prefix g)
           (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair)))))) &lt;‚ãÜ&gt;
mapdt_list_prefix f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3cc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3cc"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map (compose compose)
  (pure
     (compose
      ‚àò precompose (mapdt_list_prefix g)
          (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair))))) &lt;‚ãÜ&gt;
mapdt_list_prefix f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3cd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3cd"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
pure
  (compose
   ‚àò (compose
      ‚àò precompose (mapdt_list_prefix g)
          (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair))))) &lt;‚ãÜ&gt;
mapdt_list_prefix f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ce" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ce"><span class="nb">change</span> (mapdt_list_prefix f l) <span class="kr">with</span> (mapdt_ci f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
pure
  (compose
   ‚àò (compose
      ‚àò precompose (mapdt_list_prefix g)
          (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair))))) &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt;
f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3cf" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3cf"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
pure (evalAt pair) &lt;‚ãÜ&gt;
(pure
   (compose
    ‚àò (compose
       ‚àò precompose (mapdt_list_prefix g)
           (precompose g ‚àò (ap G2 ‚àò ap G2 (pure pair))))) &lt;‚ãÜ&gt;
 mapdt_ci f l) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d0"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map (evalAt pair)
  (pure
     (compose
      ‚àò (compose
         ‚àò precompose (mapdt_list_prefix g)
             (precompose g
              ‚àò (ap G2 ‚àò ap G2 (pure pair))))) &lt;‚ãÜ&gt;
   mapdt_ci f l) &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d1"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map (compose (evalAt pair))
  (pure
     (compose
      ‚àò (compose
         ‚àò precompose (mapdt_list_prefix g)
             (precompose g
              ‚àò (ap G2 ‚àò ap G2 (pure pair)))))) &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d2"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
pure
  (evalAt pair
   ‚àò (compose
      ‚àò (compose
         ‚àò precompose (mapdt_list_prefix g)
             (precompose g
              ‚àò (ap G2 ‚àò ap G2 (pure pair)))))) &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d3"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map double_input
  (pure
     (evalAt pair
      ‚àò (compose
         ‚àò (compose
            ‚àò precompose (mapdt_list_prefix g)
                (precompose g
                 ‚àò (ap G2 ‚àò ap G2 (pure pair))))))) &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d4"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
pure
  (double_input
     (evalAt pair
      ‚àò (compose
         ‚àò (compose
            ‚àò precompose (mapdt_list_prefix g)
                (precompose g
                 ‚àò (ap G2 ‚àò ap G2 (pure pair))))))) &lt;‚ãÜ&gt;
mapdt_ci f l &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d5"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>pureG0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>multG0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (mapdt_ci g) ‚àò pair) (mapdt_ci f l) &lt;‚ãÜ&gt;
f (l, a) =
map
  (double_input
     (evalAt pair
      ‚àò (compose
         ‚àò (compose
            ‚àò precompose (mapdt_list_prefix g)
                (precompose g
                 ‚àò (ap G2 ‚àò ap G2 (pure pair)))))))
  (mapdt_ci f l) &lt;‚ãÜ&gt; f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z A -&gt; G1 B),
mapdt_ci (œï B ‚àò f) = œï (Z B) ‚àò mapdt_ci f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) = œï (Z B) ‚àò mapdt_ci f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d8">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) (l, a) =
(œï (Z B) ‚àò mapdt_ci f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3d9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3d9"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_ci (œï B ‚àò f) (l, a) =
œï (Z B) (mapdt_ci f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3da" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3da"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> mapdt_Z_Z_rw.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; mapdt_ci (œï B ‚àò f) l &lt;‚ãÜ&gt;
(œï B ‚àò f) (l, a) =
œï (Z B) (pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3db" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3db"><span class="nb">rewrite</span> kdtfci_morph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; (œï (list B) ‚àò mapdt_ci f) l &lt;‚ãÜ&gt;
(œï B ‚àò f) (l, a) =
œï (Z B) (pure pair &lt;‚ãÜ&gt; mapdt_ci f l &lt;‚ãÜ&gt; f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3dc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3dc"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; (œï (list B) ‚àò mapdt_ci f) l &lt;‚ãÜ&gt;
(œï B ‚àò f) (l, a) =
œï (list B -&gt; B -&gt; Z B) (pure pair) &lt;‚ãÜ&gt;
œï (list B) (mapdt_ci f l) &lt;‚ãÜ&gt; œï B (f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3dd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3dd"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; (œï (list B) ‚àò mapdt_ci f) l &lt;‚ãÜ&gt;
(œï B ‚àò f) (l, a) =
pure pair &lt;‚ãÜ&gt; œï (list B) (mapdt_ci f l) &lt;‚ãÜ&gt;
œï B (f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">  (** * Proof that decoration is SSR *)</span>
<span class="c">  From Tealeaves Require Import</span>
<span class="c">  Classes.Categorical.ContainerFunctor</span>
<span class="c">  Classes.Kleisli.Theory.TraversableFunctor.</span>

<span class="c">  Import ContainerFunctor.Notations.</span>

<span class="c">  #[export] Instance ToSubset_Z: ToSubset Z := ToSubset_Traverse.</span>

<span class="c">  #[export] Instance ToSubset_LZ: ToSubset (list ‚àò Z) := ToSubset_Traverse.</span>

<span class="c">  Import Subset.Notations.</span>

<span class="c">  Lemma decoration_is_SSR1: forall (A: Type) (l: list A),</span>
<span class="c">  forall (a: A), a ‚àà l -&gt; tosubset (F := list ‚àò Z) (dec l) a.</span>
<span class="c">  Proof.</span>
<span class="c">  introv Hin.</span>
<span class="c">  induction l.</span>
<span class="c">  - inversion Hin.</span>
<span class="c">  - inversion Hin.</span>
<span class="c">  + subst.</span>
<span class="c">  rewrite decorate_prefix_list_rw_cons.</span>
<span class="c">  unfold_ops @ToSubset_LZ.</span>
<span class="c">  unfold_ops @ToSubset_Traverse.</span>
<span class="c">  unfold foldMap.</span>
<span class="c">  unfold_ops @Traverse_LZ.</span>
<span class="c">  rewrite traverse_list_cons.</span>
<span class="c">  unfold ap at 1 2.</span>
<span class="c">  unfold_ops @Mult_const.</span>
<span class="c">  unfold_ops @Monoid_op_subset.</span>
<span class="c">  unfold_ops @Pure_const.</span>
<span class="c">  left.</span>
<span class="c">  right. cbn. right. easy.</span>
<span class="c">  + clear Hin. specialize (IHl H).</span>
<span class="c">  clear H.</span>
<span class="c">  rewrite decorate_prefix_list_rw_cons.</span>
<span class="c">  right.</span>
<span class="c">  Abort.</span>
<span class="c"> *)</span>




<span class="sd">(** * Mapd for &lt;&lt;list&gt;&gt;  *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Recursive inlined version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">mapd_list_prefix</span>
  {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: list A * A -&gt; B) (<span class="nv">l</span>: list A): list B :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; @nil B
  | x :: xs =&gt; f (nil, x) :: mapd_list_prefix (f ‚¶ø [x]) xs
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decomposed Version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3de" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3de"><span class="kn">Definition</span> <span class="nf">mapd_list_prefix_spec</span>
  {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: list A * A -&gt; B):
  mapd_list_prefix f = map f ‚àò decorate_prefix_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f = map f ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3df" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3df"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f = map f ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f = map f ‚àò decorate_prefix_list</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e1" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e1">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f l =
(map f ‚àò decorate_prefix_list) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e2"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l =
(map f ‚àò decorate_prefix_list) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e3"><span class="nb">induction</span> l; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f [] =
(map f ‚àò decorate_prefix_list) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk3e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = (map f ‚àò decorate_prefix_list) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk3e4"><hr></label><div class="goal-conclusion">mapd_list_prefix f (a :: l) =
(map f ‚àò decorate_prefix_list) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f [] =
(map f ‚àò decorate_prefix_list) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = (map f ‚àò decorate_prefix_list) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f (a :: l) =
(map f ‚àò decorate_prefix_list) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e7"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = (map f ‚àò decorate_prefix_list) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ([], a) :: mapd_list_prefix (f ‚¶ø [a]) l =
f ([], a)
:: map f (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e8">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = (map f ‚àò decorate_prefix_list) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix (f ‚¶ø [a]) l =
map f (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3e9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3e9"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = (map f ‚àò decorate_prefix_list) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (f ‚¶ø [a]) ‚àò decorate_prefix_list) l =
map f (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ea" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ea"><span class="nb">unfold</span> preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = (map f ‚àò decorate_prefix_list) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (f ‚àò incr [a]) ‚àò decorate_prefix_list) l =
map f (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3eb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3eb"><span class="nb">rewrite</span> &lt;- fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = (map f ‚àò decorate_prefix_list) l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map f ‚àò map (incr [a]) ‚àò decorate_prefix_list) l =
map f (map (incr [a]) (decorate_prefix_list l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  CategoricalToKleisli.DecoratedFunctor
  CategoricalToKleisli.Comonad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ec" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ec"><span class="kn">Definition</span> <span class="nf">mapd_list_prefix_spec_mapdt</span>
  {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: list A * A -&gt; B):
  mapd_list_prefix f = mapdt_list_prefix (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f = mapdt_list_prefix f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ed" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ed"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f = mapdt_list_prefix f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ee" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ee">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f l = mapdt_list_prefix f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ef" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ef"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f l = mapdt_list_prefix f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f0" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f0"><span class="nb">induction</span> l; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f [] = mapdt_list_prefix f []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk3f1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B, mapd_list_prefix f l = mapdt_list_prefix f l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk3f1"><hr></label><div class="goal-conclusion">mapd_list_prefix f (a :: l) =
mapdt_list_prefix f (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f2" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f2"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B, mapd_list_prefix f l = mapdt_list_prefix f l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f (a :: l) =
mapdt_list_prefix f (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f3" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f3"><span class="nb">rewrite</span> mapdt_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B, mapd_list_prefix f l = mapdt_list_prefix f l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f (a :: l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapdt_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f4" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f4"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B, mapd_list_prefix f l = mapdt_list_prefix f l</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f (a :: l) =
pure cons &lt;‚ãÜ&gt; f ([], a) &lt;‚ãÜ&gt;
mapd_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f5" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f5"><span class="kn">Lemma</span> <span class="nf">mapd_list_prefix_decorate</span>:
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: Z (Z A) -&gt; B),
    mapd_list_prefix f ‚àò decorate_prefix_list =
      mapd_list_prefix (f ‚àò cojoin (W := Z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z (Z A) -&gt; B),
mapd_list_prefix f ‚àò decorate_prefix_list =
mapd_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f6" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z (Z A) -&gt; B),
mapd_list_prefix f ‚àò decorate_prefix_list =
mapd_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f7" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f ‚àò decorate_prefix_list =
mapd_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f8" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f8"><span class="nb">rewrite</span> mapd_list_prefix_spec_mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f ‚àò decorate_prefix_list =
mapd_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3f9" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3f9"><span class="nb">rewrite</span> mapd_list_prefix_spec_mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix f ‚àò decorate_prefix_list =
mapdt_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3fa" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3fa"><span class="nb">rewrite</span> (mapdt_list_prefix_decorate (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix (f ‚àò cojoin) =
mapdt_list_prefix (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting Laws *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">mapd_list_prefix_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3fb" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3fb"><span class="kn">Lemma</span> <span class="nf">mapd_list_prefix_rw_nil</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: list A * A -&gt; B),
      mapd_list_prefix f nil = pure nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3fc" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3fc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : list A * A -&gt; B,
mapd_list_prefix f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3fd" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3fd"><span class="kn">Lemma</span> <span class="nf">mapd_list_prefix_rw_cons</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: list A * A -&gt; B) (<span class="nv">a</span>: A) (<span class="nv">l</span>: list A),
      mapd_list_prefix f (a :: l) =
        f ([], a) :: mapd_list_prefix (f ‚¶ø [a]) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : list A * A -&gt; B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
mapd_list_prefix f (a :: l) =
f ([], a) :: mapd_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3fe" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3fe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : list A * A -&gt; B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
mapd_list_prefix f (a :: l) =
f ([], a) :: mapd_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk3ff" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk3ff"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix f (a :: l) =
f ([], a) :: mapd_list_prefix (f ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk400" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk400"><span class="kn">Lemma</span> <span class="nf">mapd_list_prefix_rw_app</span>:
    <span class="kr">forall</span> (<span class="nv">g</span>: list A * A -&gt; B) (<span class="nv">l</span> <span class="nv">l&#39;</span>: list A),
      mapd_list_prefix g (l ++ l&#39;) =
        mapd_list_prefix g l ++ mapd_list_prefix (g ‚¶ø l) l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; B) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A),
mapd_list_prefix g (l ++ l&#39;) =
mapd_list_prefix g l ++ mapd_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk401" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk401"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : list A * A -&gt; B) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A),
mapd_list_prefix g (l ++ l&#39;) =
mapd_list_prefix g l ++ mapd_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk402" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk402"><span class="nb">intros</span> g l l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g (l ++ l&#39;) =
mapd_list_prefix g l ++ mapd_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk403" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk403"><span class="nb">rewrite</span> mapd_list_prefix_spec_mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix g (l ++ l&#39;) =
mapdt_list_prefix g l ++ mapd_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk404" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk404"><span class="nb">rewrite</span> mapd_list_prefix_spec_mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt_list_prefix g (l ++ l&#39;) =
mapdt_list_prefix g l ++ mapdt_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk405" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk405"><span class="nb">rewrite</span> mapdt_list_prefix_rw_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list A * A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (app (A:=B)) &lt;‚ãÜ&gt; mapdt_list_prefix g l &lt;‚ãÜ&gt;
mapdt_list_prefix (g ‚¶ø l) l&#39; =
mapdt_list_prefix g l ++ mapdt_list_prefix (g ‚¶ø l) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">mapd_list_prefix_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** * Mapd for &lt;&lt;Z&gt;&gt;  *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Recursive inlined version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mapd_Z</span>
  {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: Z A -&gt; B) (<span class="nv">p</span>: Z A): list B * B :=
  <span class="kr">match</span> p <span class="kr">with</span>
  | (l, a) =&gt; (mapd_list_prefix f l, f (l, a))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Cobind_Z</span>: Cobind Z := @mapd_Z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decomposed Version *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk406" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk406"><span class="kn">Definition</span> <span class="nf">cobind_Z_spec</span>
  {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: Z A -&gt; B):
  cobind (W := Z) f = map (F := Z) f ‚àò cojoin (W := Z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f = map f ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk407" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk407"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f = map f ‚àò cojoin</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk408" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk408">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Z A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f l = (map f ‚àò cojoin) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk409" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk409"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Z A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f l = map f (cojoin l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk40a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk40a"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Z A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; B, cobind f l = map f (cojoin l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk40b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk40b"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Z A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f l = map f (cojoin l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk40c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk40c"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f (l, a) = map f (cojoin (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk40d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk40d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix f l, f (l, a)) =
(id (map f (decorate_prefix_list l)), f (id (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk40e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk40e"><span class="nb">rewrite</span> mapd_list_prefix_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((map f ‚àò decorate_prefix_list) l, f (l, a)) =
(id (map f (decorate_prefix_list l)), f (id (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk40f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk40f"><span class="kn">Definition</span> <span class="nf">cobind_Z_spec_mapdt</span>
  {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: Z A -&gt; B):
  cobind (W := Z) f = mapdt_ci (W := Z) (T := Z) (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f = mapdt_ci f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk410" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk410"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f = mapdt_ci f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk411" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk411">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f (l, a) = mapdt_ci f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk412" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk412"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix f l, f (l, a)) =
pure pair (traverse f (decorate_prefix_list l))
  (f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk413" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk413"><span class="nb">rewrite</span> mapd_list_prefix_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((map f ‚àò decorate_prefix_list) l, f (l, a)) =
pure pair (traverse f (decorate_prefix_list l))
  (f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk414" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk414"><span class="nb">rewrite</span> map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((traverse f ‚àò decorate_prefix_list) l, f (l, a)) =
pure pair (traverse f (decorate_prefix_list l))
  (f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk415" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk415"><span class="kn">Lemma</span> <span class="nf">cobind_Z_cojoin</span>:
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: Z (Z A) -&gt; B),
    cobind (W := Z) f ‚àò cojoin (W := Z) =
      cobind (W := Z) (f ‚àò cojoin (W := Z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z (Z A) -&gt; B),
cobind f ‚àò cojoin = cobind (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk416" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk416"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z (Z A) -&gt; B),
cobind f ‚àò cojoin = cobind (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk417" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk417"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind f ‚àò cojoin = cobind (f ‚àò cojoin)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk418" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk418">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cobind f ‚àò cojoin) (l, a) =
cobind (f ‚àò cojoin) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk419" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk419"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix f (decorate_prefix_list l),
 f (decorate_prefix_list l, (l, a))) =
(mapd_list_prefix (f ‚àò cojoin) l, (f ‚àò cojoin) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk41a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk41a">compose near l on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((mapd_list_prefix f ‚àò decorate_prefix_list) l,
 f ((pair ‚àò decorate_prefix_list) l (l, a))) =
(mapd_list_prefix (f ‚àò cojoin) l, (f ‚àò cojoin) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk41b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk41b"><span class="nb">rewrite</span> mapd_list_prefix_decorate.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix (f ‚àò cojoin) l,
 f ((pair ‚àò decorate_prefix_list) l (l, a))) =
(mapd_list_prefix (f ‚àò cojoin) l, (f ‚àò cojoin) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk41c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk41c"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z (Z A) -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix (f ‚óã cojoin) l,
 f (decorate_prefix_list l, (l, a))) =
(mapd_list_prefix (f ‚óã cojoin) l, f (cojoin (l, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting Laws *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">cobind_Z_prefix_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk41d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk41d"><span class="kn">Lemma</span> <span class="nf">cobind_Z_rw</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: Z A -&gt; B) (<span class="nv">ctx</span>: list A) (<span class="nv">a</span>: A),
      cobind (W := Z) f (ctx, a) =
        (mapd_list_prefix f ctx, f (ctx, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : Z A -&gt; B) (<span class="nv">ctx</span> : list A) (<span class="nv">a</span> : A),
cobind f (ctx, a) =
(mapd_list_prefix f ctx, f (ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk41e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk41e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : Z A -&gt; B) (<span class="nv">ctx</span> : list A) (<span class="nv">a</span> : A),
cobind f (ctx, a) =
(mapd_list_prefix f ctx, f (ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">cobind_Z_prefix_rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Decorated Functor Instance for List *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Unit law *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk41f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk41f"><span class="kn">Lemma</span> <span class="nf">kdfun_mapd1_list_prefix</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
    mapd_list_prefix extract = @id (list A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapd_list_prefix extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk420" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk420"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapd_list_prefix extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk421" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk421"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk422" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk422">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix extract l = id l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk423" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk423"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix extract [] = id []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk424" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapd_list_prefix extract l = id l</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk424"><hr></label><div class="goal-conclusion">mapd_list_prefix extract (a :: l) = id (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk425" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk425">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix extract [] = id []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk426" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk426"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = id []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk427" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk427">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapd_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix extract (a :: l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk428" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk428"><span class="nb">rewrite</span> mapd_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapd_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ([], a) :: mapd_list_prefix (extract ‚¶ø [a]) l =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk429" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk429"><span class="nb">rewrite</span> extract_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapd_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ([], a) :: mapd_list_prefix extract l =
id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk42a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk42a"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapd_list_prefix extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ([], a) :: id l = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Composition law *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk42b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk42b"><span class="kn">Lemma</span> <span class="nf">kdfun_mapd2_list_prefix</span>:
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>} (<span class="nv">g</span>: Z B -&gt; C) (<span class="nv">f</span>: Z A -&gt; B),
    mapd_list_prefix g ‚àò mapd_list_prefix f =
      mapd_list_prefix (g ‚àò cobind (W := Z) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g ‚àò mapd_list_prefix f =
mapd_list_prefix (g ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk42c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk42c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g ‚àò mapd_list_prefix f =
mapd_list_prefix (g ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk42d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk42d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g ‚àò mapd_list_prefix f =
mapd_list_prefix (g ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk42e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk42e"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g ‚óã mapd_list_prefix f =
mapd_list_prefix (g ‚óã cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk42f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk42f">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g (mapd_list_prefix f l) =
mapd_list_prefix (g ‚óã cobind f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk430" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk430"><span class="nb">generalize dependent</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : Z A -&gt; B,
mapd_list_prefix g (mapd_list_prefix f l) =
mapd_list_prefix (g ‚óã cobind f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk431" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk431"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) =
mapd_list_prefix (g ‚óã cobind f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk432" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk432"><span class="nb">induction</span> l; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g (mapd_list_prefix f []) =
mapd_list_prefix (g ‚óã cobind f) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk433" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk433"><hr></label><div class="goal-conclusion">mapd_list_prefix g (mapd_list_prefix f (a :: l)) =
mapd_list_prefix (g ‚óã cobind f) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk434" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk434">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g (mapd_list_prefix f []) =
mapd_list_prefix (g ‚óã cobind f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk435" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk435">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g (mapd_list_prefix f (a :: l)) =
mapd_list_prefix (g ‚óã cobind f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk436" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk436"><span class="nb">rewrite</span> mapd_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g
  (f ([], a) :: mapd_list_prefix (f ‚¶ø [a]) l) =
mapd_list_prefix (g ‚óã cobind f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk437" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk437"><span class="nb">rewrite</span> mapd_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ([], f ([], a))
:: mapd_list_prefix (g ‚¶ø [f ([], a)])
     (mapd_list_prefix (f ‚¶ø [a]) l) =
mapd_list_prefix (g ‚óã cobind f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk438" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk438"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ([], f ([], a))
:: mapd_list_prefix
     (g ‚¶ø [f ([], a)] ‚óã cobind (f ‚¶ø [a])) l =
mapd_list_prefix (g ‚óã cobind f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk439" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk439"><span class="nb">rewrite</span> mapd_list_prefix_rw_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ([], f ([], a))
:: mapd_list_prefix
     (g ‚¶ø [f ([], a)] ‚óã cobind (f ‚¶ø [a])) l =
g (cobind f ([], a))
:: mapd_list_prefix ((g ‚óã cobind f) ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk43a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk43a">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix (g ‚¶ø [f ([], a)] ‚óã cobind (f ‚¶ø [a]))
  l = mapd_list_prefix ((g ‚óã cobind f) ‚¶ø [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk43b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk43b"><span class="nb">unfold</span> preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix
  (g ‚àò incr [f ([], a)] ‚óã cobind (f ‚àò incr [a])) l =
mapd_list_prefix (g ‚óã cobind f ‚àò incr [a]) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk43c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk43c"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix
  (<span class="kr">fun</span> <span class="nv">a0</span> : Z A =&gt;
   g (incr [f ([], a)] (cobind (f ‚óã incr [a]) a0))) l =
mapd_list_prefix
  (<span class="kr">fun</span> <span class="nv">a0</span> : list A * A =&gt; g (cobind f (incr [a] a0)))
  l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk43d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk43d">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a0</span> : Z A =&gt;
 g (incr [f ([], a)] (cobind (f ‚óã incr [a]) a0))) =
(<span class="kr">fun</span> <span class="nv">a0</span> : list A * A =&gt; g (cobind f (incr [a] a0)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk43e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk43e">ext [l&#39; a&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (incr [f ([], a)] (cobind (f ‚óã incr [a]) (l&#39;, a&#39;))) =
g (cobind f (incr [a] (l&#39;, a&#39;)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk43f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk43f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
mapd_list_prefix g (mapd_list_prefix f l) = mapd_list_prefix (g ‚óã cobind f) l</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g
  (f ([], a) :: mapd_list_prefix (f ‚óã incr [a]) l&#39;,
   f (a :: l&#39;, a&#39;)) =
g
  (f ([], a) :: mapd_list_prefix (f ‚¶ø [a]) l&#39;,
   f (a :: l&#39;, a&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Comonad instance on &lt;&lt;Z&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk440" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk440">#[export] <span class="kn">Instance</span> <span class="nf">KleisliComonad_Z</span>: Kleisli.Comonad.Comonad Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Comonad.Comonad Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk441" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk441"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Comonad.Comonad Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk442" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk442"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z A -&gt; B),
extract ‚àò cobind f = f</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, cobind extract = id</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
cobind g ‚àò cobind f = cobind (kc1 g f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk443" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk443">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Z A -&gt; B),
extract ‚àò cobind f = f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk444" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk444"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extract ‚àò cobind f = f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk445" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk445">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(extract ‚àò cobind f) (l, a) = f (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk446" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk446">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, cobind extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk447" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk447"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk448" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk448"><span class="nb">unfold</span> cobind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cobind_Z A A extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk449" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk449">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cobind_Z A A extract (l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk44a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk44a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix extract l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk44b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk44b"><span class="nb">rewrite</span> kdfun_mapd1_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id l, a) = id (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk44c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk44c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : Z B -&gt; C) (<span class="nv">f</span> : Z A -&gt; B),
cobind g ‚àò cobind f = cobind (kc1 g f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk44d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk44d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind g ‚àò cobind f = cobind (kc1 g f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk44e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk44e"><span class="nb">unfold</span> compose, kc1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind g ‚óã cobind f = cobind (g ‚àò cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk44f" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk44f">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cobind g (cobind f (l, a)) =
cobind (g ‚àò cobind f) (l, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk450" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk450"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix g (mapd_list_prefix f l),
 g (mapd_list_prefix f l, f (l, a))) =
(mapd_list_prefix (g ‚àò cobind f) l,
 (g ‚àò cobind f) (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk451" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk451">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g (mapd_list_prefix f l) =
mapd_list_prefix (g ‚àò cobind f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk452" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk452">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix g (mapd_list_prefix f l) =
mapd_list_prefix (g ‚àò cobind f) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk453" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk453">compose near l on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(mapd_list_prefix g ‚àò mapd_list_prefix f) l =
mapd_list_prefix (g ‚àò cobind f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk454" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk454"><span class="nb">rewrite</span> kdfun_mapd2_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Z B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Z A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd_list_prefix (g ‚àò cobind f) l =
mapd_list_prefix (g ‚àò cobind f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * &lt;&lt;Dist&gt;&gt; instance on &lt;&lt;Z&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span> Classes.Categorical.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dist_Z</span>
  {<span class="nv">B1</span> <span class="nv">V1</span>: <span class="kt">Type</span>} {<span class="nv">G</span>}
  `{Map G} `{Mult G} `{Pure G}:
  list (G B1) * G V1 -&gt; G (list B1 * V1) :=
  <span class="kr">fun</span> &#39;(x, y) =&gt; pure (@pair (list B1) V1) &lt;‚ãÜ&gt; dist list G x &lt;‚ãÜ&gt; y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk455" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk455">#[export] <span class="kn">Instance</span> <span class="nf">Dist_Z</span>: ApplicativeDist Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeDist Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk456" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk456"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">ApplicativeDist Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk457" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk457"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Map G -&gt;
Pure G -&gt;
Mult G -&gt; <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, Z (G A) -&gt; G (Z A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk458" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk458"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>Z (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G (Z A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (dist_Z X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk459" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk459"><span class="kn">Lemma</span> <span class="nf">traverse_dist_list</span> `{Applicative G}:
  <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; G B),
    traverse (T := list) f = dist list G ‚àò map f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = Œ¥ list G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk45a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk45a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = Œ¥ list G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk45b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk45b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = Œ¥ list G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk45c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk45c"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = Œ¥ list G ‚óã map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk45d" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk45d">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f l = Œ¥ list G (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk45e" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk45e"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f [] = Œ¥ list G (map f [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="list-telescoping-general-v-chk45f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = Œ¥ list G (map f l)</span></span></span><br></div><label class="goal-separator" for="list-telescoping-general-v-chk45f"><hr></label><div class="goal-conclusion">traverse f (a :: l) = Œ¥ list G (map f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk460" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk460">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f [] = Œ¥ list G (map f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk461" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk461">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = Œ¥ list G (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: l) = Œ¥ list G (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk462" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk462"><span class="nb">rewrite</span> map_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = Œ¥ list G (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: l) = Œ¥ list G (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk463" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk463"><span class="nb">rewrite</span> dist_list_cons_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = Œ¥ list G (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: l) =
pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; Œ¥ list G (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk464" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk464"><span class="nb">rewrite</span> traverse_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = Œ¥ list G (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; traverse f l =
pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; Œ¥ list G (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk465" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk465"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = Œ¥ list G (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; Œ¥ list G (map f l) =
pure cons &lt;‚ãÜ&gt; f a &lt;‚ãÜ&gt; Œ¥ list G (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk466" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk466"><span class="kn">Lemma</span> <span class="nf">traverse_dist_Z</span> `{Applicative G}:
  <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; G B),
    traverse (T := Z) f = dist Z G ‚àò map f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = Œ¥ Z G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk467" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk467"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = Œ¥ Z G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk468" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk468"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = Œ¥ Z G ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk469" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk469"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = Œ¥ Z G ‚óã map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk46a" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk46a">ext [l a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (l, a) = Œ¥ Z G (map f (l, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk46b" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk46b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; traverse f l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt; Œ¥ list G (id (map f l)) &lt;‚ãÜ&gt; f (id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="list-telescoping-general-v-chk46c" style="display: none" type="checkbox"><label class="alectryon-input" for="list-telescoping-general-v-chk46c"><span class="nb">rewrite</span> traverse_dist_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure pair &lt;‚ãÜ&gt; (Œ¥ list G ‚àò map f) l &lt;‚ãÜ&gt; f a =
pure pair &lt;‚ãÜ&gt; Œ¥ list G (id (map f l)) &lt;‚ãÜ&gt; f (id a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre>
</div>
</div></body>
</html>
