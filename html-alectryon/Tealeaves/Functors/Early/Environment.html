<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Environment.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Categorical.Monad
  Classes.Categorical.DecoratedMonad (shift)
  Classes.Kleisli.DecoratedTraversableFunctor
  Classes.Kleisli.DecoratedTraversableMonad
  Functors.Early.Subset
  Functors.Early.Ctxset
  Functors.Early.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DecoratedTraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Functor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Product.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Subset.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Strength.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">W</span> M A B G Ï•.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">env</span> (<span class="nv">E</span>: <span class="kt">Type</span>) (<span class="nv">A</span>: <span class="kt">Type</span>) := list (E * A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Decorated Traversable Functor Instance (Kleisli)] *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">env</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">E</span>: <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Operation &lt;&lt;mapdt&gt;&gt; and Derived Operations *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">mapdt_env</span> (<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G}
    `(f: E * A -&gt; G B) (Î“: env E A): G (env E B) :=
    <span class="kr">match</span> Î“ <span class="kr">with</span>
    | nil =&gt; pure (@nil (E * B))
    | (e, a) :: rest =&gt;
        pure (@List.cons (E * B))
          &lt;â‹†&gt; Ïƒ (e, f (e, a))
          &lt;â‹†&gt; mapdt_env G f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">traverse_env</span> (<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G}
    `(f: A -&gt; G B) (l: env E A): G (env E B) :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | nil =&gt; pure (@nil (E * B))
    | (e, a) :: xs =&gt;
        pure (@List.cons (E * B))
          &lt;â‹†&gt; Ïƒ (e, f a)
          &lt;â‹†&gt; traverse_env G f xs
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">mapd_env</span> `(f: E * A -&gt; B) (Î“: env E A): env E B :=
    <span class="kr">match</span> Î“ <span class="kr">with</span>
    | nil =&gt; @nil (E * B)
    | (e, a) :: rest =&gt;
        (e, f (e, a)) :: mapd_env f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map_env</span> `(f: A -&gt; B) (Î“: env E A): env E B :=
    <span class="kr">match</span> Î“ <span class="kr">with</span>
    | nil =&gt; @nil (E * B)
    | (e, a) :: rest =&gt;
        (e, f a) :: map_env f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapdt_env</span>: Mapdt E (env E) := @mapdt_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Traverse_env</span>: Traverse (env E) := @traverse_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapd_env</span>: Mapd E (env E) := @mapd_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Map_env</span>: Map (env E) := @map_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">env</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">simple_env_tactic</span> :=
  <span class="nb">intros</span>;
  <span class="kr">let</span> <span class="nv">l</span> := <span class="kp">fresh</span> <span class="s2">&quot;l&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">e</span> := <span class="kp">fresh</span> <span class="s2">&quot;e&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">a</span> := <span class="kp">fresh</span> <span class="s2">&quot;a&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">rest</span> := <span class="kp">fresh</span> <span class="s2">&quot;rest&quot;</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">IHrest</span> := <span class="kp">fresh</span> <span class="s2">&quot;IHrest&quot;</span> <span class="kr">in</span>
  ext l;
  ( <span class="nb">induction</span> l <span class="kr">as</span> [|[e a] rest IHrest] ||
  <span class="nb">induction</span> l <span class="kr">as</span> [|a rest IHrest] );
  [ <span class="bp">reflexivity</span> |
    <span class="kp">try</span> (<span class="nb">cbn</span>; <span class="bp">now</span> <span class="nb">rewrite</span> IHrest)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting Laws for &lt;&lt;mapdt&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">mapdt_rewriting_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Applicative G}
    (E A B: <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk0"><span class="kn">Lemma</span> <span class="nf">mapdt_env_nil</span>: <span class="kr">forall</span> `(f: E * A -&gt; G B),
      mapdt f (@nil (E * A)) = pure nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : E * A -&gt; G B, mapdt f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : E * A -&gt; G B, mapdt f [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2"><span class="kn">Lemma</span> <span class="nf">mapdt_env_one</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: E * A -&gt; G B) (<span class="nv">e</span>: E) (<span class="nv">a</span>: A),
      mapdt f (ret (T := list) (e, a)) =
        map (ret (T := list) âˆ˜ pair e) (f (e, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A),
mapdt f (ret (e, a)) = map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A),
mapdt f (ret (e, a)) = map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f (ret (e, a)) = map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt; pure [] =
map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; (pure (pair e) &lt;â‹†&gt; f (e, a)) &lt;â‹†&gt; pure [] =
map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure cons &lt;â‹†&gt; pure (pair e) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; pure [] = map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose cons) &lt;â‹†&gt; pure (pair e) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
pure [] = map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk9"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (cons âˆ˜ pair e) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt; pure [] =
map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chka"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt []) &lt;â‹†&gt;
(pure (cons âˆ˜ pair e) &lt;â‹†&gt; f (e, a)) =
map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkb"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt []) &lt;â‹†&gt;
pure (cons âˆ˜ pair e) &lt;â‹†&gt; f (e, a) =
map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkc"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt [])) &lt;â‹†&gt; pure (cons âˆ˜ pair e) &lt;â‹†&gt;
f (e, a) = map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkd"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt; f (e, a) =
map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chke"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (evalAt [] âˆ˜ (cons âˆ˜ pair e)) (f (e, a)) =
map (ret âˆ˜ pair e) (f (e, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chkf"><span class="kn">Lemma</span> <span class="nf">mapdt_env_cons</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: E * A -&gt; G B) (<span class="nv">e</span>: E) (<span class="nv">a</span>: A) (<span class="nv">l</span>: env E A),
      mapdt f ((e, a) :: l) =
        pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a)) &lt;â‹†&gt; mapdt f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A)
  (<span class="nv">l</span> : env E A),
mapdt f ((e, a) :: l) =
pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a)) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">e</span> : E) (<span class="nv">a</span> : A)
  (<span class="nv">l</span> : env E A),
mapdt f ((e, a) :: l) =
pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a)) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk11"><span class="kn">Lemma</span> <span class="nf">mapdt_env_app</span>:
    <span class="kr">forall</span> (<span class="nv">f</span>: E * A -&gt; G B) (<span class="nv">l1</span> <span class="nv">l2</span>: env E A),
      mapdt f (l1 ++ l2) =
        pure (@app (E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">l1</span> <span class="nv">l2</span> : env E A),
mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : E * A -&gt; G B) (<span class="nv">l1</span> <span class="nv">l2</span> : env E A),
mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk13"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk14"><span class="nb">induction</span> l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f ([] ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f [] &lt;â‹†&gt; mapdt f l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><label class="goal-separator" for="environment-v-chk15"><hr></label><div class="goal-conclusion">mapdt f ((a :: l1) ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f (a :: l1) &lt;â‹†&gt;
mapdt f l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f ([] ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f [] &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk17"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l2 =
pure (app (A:=E * B)) &lt;â‹†&gt; pure [] &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk18"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l2 = pure (app []) &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk19"><span class="nb">rewrite</span> ap1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l2 = mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f ((a :: l1) ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f (a :: l1) &lt;â‹†&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1b"><span class="nb">destruct</span> a  <span class="kr">as</span> (e, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f (((e, a) :: l1) ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f ((e, a) :: l1) &lt;â‹†&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt;
mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1) &lt;â‹†&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1d"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt;
(pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2) =
pure (app (A:=E * B)) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1) &lt;â‹†&gt;
mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1e"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
pure compose &lt;â‹†&gt; pure cons &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt;
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2 =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
pure (app (A:=E * B)) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk1f"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((compose âˆ˜ compose) compose compose compose compose
     cons) &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt;
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2 =
pure ((compose âˆ˜ compose) (app (A:=E * B)) cons) &lt;â‹†&gt;
map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk20"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt (app (A:=E * B))) &lt;â‹†&gt;
(pure
   ((compose âˆ˜ compose) compose compose compose
      compose cons) &lt;â‹†&gt; map (pair e) (f (e, a))) &lt;â‹†&gt;
mapdt f l1 &lt;â‹†&gt; mapdt f l2 =
pure ((compose âˆ˜ compose) (app (A:=E * B)) cons) &lt;â‹†&gt;
map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk21"><span class="kp">repeat</span> <span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt (app (A:=E * B))) &lt;â‹†&gt;
pure
  ((compose âˆ˜ compose) compose compose compose compose
     cons) &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2 =
pure ((compose âˆ˜ compose) (app (A:=E * B)) cons) &lt;â‹†&gt;
map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk22"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mapdt f (l1 ++ l2) =
pure (app (A:=E * B)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt;
mapdt f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (evalAt (app (A:=E * B))
   âˆ˜ (compose âˆ˜ compose) compose compose compose
       compose cons) &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt;
mapdt f l1 &lt;â‹†&gt; mapdt f l2 =
pure ((compose âˆ˜ compose) (app (A:=E * B)) cons) &lt;â‹†&gt;
map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l1 &lt;â‹†&gt; mapdt f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">mapdt_rewriting_lemmas</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Rewrite</span>
  mapdt_env_nil @mapdt_env_cons mapdt_env_one mapdt_env_app:
  tea_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Compatibility Typeclass Instances *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk23"><span class="kn">Lemma</span> <span class="nf">env_traverse_compat</span>:
  <span class="kr">forall</span> (<span class="nv">E</span>: <span class="kt">Type</span>) `{Applicative G} (A B: <span class="kt">Type</span>) (f: A -&gt; G B),
    traverse f = mapdt (E := E) (f âˆ˜ extract).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = mapdt (f âˆ˜ extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
traverse f = mapdt (f âˆ˜ extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk25"><span class="kn">Lemma</span> <span class="nf">env_mapd_compat</span>: <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: E * A -&gt; B),
    mapd (T := env E) f = mapdt (E := E) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = mapdt f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk27"><span class="kn">Lemma</span> <span class="nf">env_map_compat</span>: <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; B),
    map (F := env E) f = mapdt (E := E) (f âˆ˜ extract (W := (E Ã—))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = mapdt (f âˆ˜ extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = mapdt (f âˆ˜ extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk29">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Traverse_Mapdt_env</span> {<span class="nv">E</span>: <span class="kt">Type</span>}:
  Compat_Traverse_Mapdt E (env E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt E (env E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Traverse_Mapdt E (env E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2b"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Traverse_env E = DerivedOperations.Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Traverse_env E = DerivedOperations.Traverse_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2d">ext G MapG PureG MultG.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Traverse_env E G MapG PureG MultG =
DerivedOperations.Traverse_Mapdt G MapG PureG MultG</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2e">ext A B f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Traverse_env E G MapG PureG MultG A B f l =
DerivedOperations.Traverse_Mapdt G MapG PureG MultG A
  B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk2f"><span class="nb">unfold</span> Traverse_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse_env E G f l =
DerivedOperations.Traverse_Mapdt G MapG PureG MultG A
  B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk30">change_left (traverse f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f l =
DerivedOperations.Traverse_Mapdt G MapG PureG MultG A
  B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk31">change_right (mapdt (T := env E) (f âˆ˜ extract (W := (E Ã—))) l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f l = mapdt (f âˆ˜ extract) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk32"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f [] = mapdt (f âˆ˜ extract) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = mapdt (f âˆ˜ extract) l</span></span></span><br></div><label class="goal-separator" for="environment-v-chk33"><hr></label><div class="goal-conclusion">traverse f (a :: l) = mapdt (f âˆ˜ extract) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk34">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f [] = mapdt (f âˆ˜ extract) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = mapdt (f âˆ˜ extract) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (a :: l) = mapdt (f âˆ˜ extract) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk36"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = mapdt (f âˆ˜ extract) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">e</span>, a) := a <span class="kr">in</span>
 pure cons &lt;â‹†&gt; map (pair e) (f a) &lt;â‹†&gt; traverse f l) =
(<span class="kr">let</span> (<span class="nv">e</span>, a) := a <span class="kr">in</span>
 pure cons &lt;â‹†&gt; map (pair e) ((f âˆ˜ extract) (e, a)) &lt;â‹†&gt;
 mapdt (f âˆ˜ extract) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk37"><span class="nb">destruct</span> a <span class="kr">as</span> [e a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = mapdt (f âˆ˜ extract) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; map (pair e) (f a) &lt;â‹†&gt; traverse f l =
pure cons &lt;â‹†&gt; map (pair e) ((f âˆ˜ extract) (e, a)) &lt;â‹†&gt;
mapdt (f âˆ˜ extract) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk38"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>MapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>PureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>MultG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>traverse f l = mapdt (f âˆ˜ extract) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; map (pair e) (f a) &lt;â‹†&gt;
mapdt (f âˆ˜ extract) l =
pure cons &lt;â‹†&gt; map (pair e) ((f âˆ˜ extract) (e, a)) &lt;â‹†&gt;
mapdt (f âˆ˜ extract) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk39">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Map_Mapdt_env</span> {<span class="nv">E</span>: <span class="kt">Type</span>}:
  Compat_Map_Mapdt E (env E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt E (env E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Map_Mapdt E (env E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3b"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Map_env E = DerivedOperations.Map_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3c">ext A B f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Map_env E A B f l =
DerivedOperations.Map_Mapdt A B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3d">change_left (map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f l = DerivedOperations.Map_Mapdt A B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3e"><span class="nb">rewrite</span> env_map_compat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt (f âˆ˜ extract) l =
DerivedOperations.Map_Mapdt A B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk3f">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Mapd_Mapdt_env</span> {<span class="nv">E</span>: <span class="kt">Type</span>}:
  Compat_Mapd_Mapdt E (env E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Mapd_Mapdt E (env E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_Mapd_Mapdt E (env E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk41"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mapd_env E = DerivedOperations.Mapd_Mapdt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk42">ext A B f l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Mapd_env E A B f l =
DerivedOperations.Mapd_Mapdt A B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk43">change_left (mapd f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd f l = DerivedOperations.Mapd_Mapdt A B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk44"><span class="nb">rewrite</span> env_mapd_compat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f l = DerivedOperations.Mapd_Mapdt A B f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decorated Traversable Functor Laws *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">env_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    (<span class="nv">E</span>: <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk45"><span class="kn">Lemma</span> <span class="nf">env_mapdt1</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
      mapdt (extract (W := (E Ã—))) = @id (env E A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk47"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk48">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract l = id l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk49"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract [] = id []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><label class="goal-separator" for="environment-v-chk4a"><hr></label><div class="goal-conclusion">mapdt extract (a :: l) = id (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract [] = id []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract (a :: l) = id (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4d"><span class="nb">destruct</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract ((e, a) :: l) = id ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4e"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; Ïƒ (e, extract (e, a)) &lt;â‹†&gt;
mapdt extract l = id ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk4f"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>mapdt extract l = id l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; Ïƒ (e, extract (e, a)) &lt;â‹†&gt; id l =
id ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk50"><span class="kn">Lemma</span> <span class="nf">env_mapdt2</span>
    `{Applicative G1}
    `{Applicative G2}:
    <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>)
      (<span class="nv">g</span>: E * B -&gt; G2 C)
      (<span class="nv">f</span>: E * A -&gt; G1 B),
      map (mapdt g) âˆ˜ mapdt f =
        mapdt (G := G1 âˆ˜ G2) (g â‹†<span class="mi">3</span> f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : E * B -&gt; G2 C)
  (<span class="nv">f</span> : E * A -&gt; G1 B),
map (mapdt g) âˆ˜ mapdt f = mapdt (g â‹†<span class="mi">3</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : E * B -&gt; G2 C)
  (<span class="nv">f</span> : E * A -&gt; G1 B),
map (mapdt g) âˆ˜ mapdt f = mapdt (g â‹†<span class="mi">3</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk52"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) âˆ˜ mapdt f = mapdt (g â‹†<span class="mi">3</span> f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk53">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) âˆ˜ mapdt f) l = mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk54"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) âˆ˜ mapdt f) [] = mapdt (g â‹†<span class="mi">3</span> f) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(map (mapdt g) âˆ˜ mapdt f) l = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><label class="goal-separator" for="environment-v-chk55"><hr></label><div class="goal-conclusion">(map (mapdt g) âˆ˜ mapdt f) (a :: l) =
mapdt (g â‹†<span class="mi">3</span> f) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) âˆ˜ mapdt f) [] = mapdt (g â‹†<span class="mi">3</span> f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk57"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f []) = mapdt (g â‹†<span class="mi">3</span> f) []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk58"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (pure []) = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk59">compose near (@nil (E * B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) âˆ˜ pure) [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5a"><span class="nb">rewrite</span> (natural (Ï• := @pure G1 _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure âˆ˜ map (mapdt g)) [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(map (mapdt g) âˆ˜ mapdt f) l = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (mapdt g) âˆ˜ mapdt f) (a :: l) =
mapdt (g â‹†<span class="mi">3</span> f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5c"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(map (mapdt g) âˆ˜ mapdt f) l = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f (a :: l)) =
mapdt (g â‹†<span class="mi">3</span> f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5d"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span> <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f (a :: l)) =
mapdt (g â‹†<span class="mi">3</span> f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5e"><span class="nb">destruct</span> a <span class="kr">as</span> [e a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) (mapdt f ((e, a) :: l)) =
mapdt (g â‹†<span class="mi">3</span> f) ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk5f"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a)) &lt;â‹†&gt; mapdt f l) =
pure cons &lt;â‹†&gt; Ïƒ (e, (g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk60"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure cons &lt;â‹†&gt; map (pair e) (f (e, a)) &lt;â‹†&gt; mapdt f l) =
pure cons &lt;â‹†&gt; map (pair e) ((g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk61"><span class="nb">rewrite</span> (map_to_ap (A := B) (G := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure cons &lt;â‹†&gt; (pure (pair e) &lt;â‹†&gt; f (e, a)) &lt;â‹†&gt;
   mapdt f l) =
pure cons &lt;â‹†&gt; map (pair e) ((g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk62"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g)
  (pure (cons âˆ˜ pair e) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt; mapdt f l) =
pure cons &lt;â‹†&gt; map (pair e) ((g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk63"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (mapdt g) &lt;â‹†&gt;
(pure (cons âˆ˜ pair e) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt; mapdt f l) =
pure cons &lt;â‹†&gt; map (pair e) ((g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk64"><span class="nb">rewrite</span> &lt;- ap4; <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g)) &lt;â‹†&gt;
(pure (cons âˆ˜ pair e) &lt;â‹†&gt; f (e, a)) &lt;â‹†&gt; mapdt f l =
pure cons &lt;â‹†&gt; map (pair e) ((g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk65"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure cons &lt;â‹†&gt; map (pair e) ((g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk66"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure cons &lt;â‹†&gt; (pure (pair e) &lt;â‹†&gt; (g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk67"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (cons âˆ˜ pair e) &lt;â‹†&gt; (g â‹†<span class="mi">3</span> f) (e, a) &lt;â‹†&gt;
mapdt (g â‹†<span class="mi">3</span> f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk68"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (cons âˆ˜ pair e) &lt;â‹†&gt; (g â‹†<span class="mi">3</span> f) (e, a) &lt;â‹†&gt;
map (mapdt g) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk69"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (cons âˆ˜ pair e) &lt;â‹†&gt; (g â‹†<span class="mi">3</span> f) (e, a) &lt;â‹†&gt;
(pure (mapdt g) &lt;â‹†&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6a"><span class="nb">rewrite</span> (ap_compose1 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (ap G2) &lt;â‹†&gt;
(pure (cons âˆ˜ pair e) &lt;â‹†&gt; (g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt;
(pure (mapdt g) &lt;â‹†&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6b"><span class="nb">rewrite</span> (ap_compose1 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (ap G2) &lt;â‹†&gt;
(pure (ap G2) &lt;â‹†&gt; pure (cons âˆ˜ pair e) &lt;â‹†&gt;
 (g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt; (pure (mapdt g) &lt;â‹†&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6c">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (ap G2) &lt;â‹†&gt;
(pure (ap G2) &lt;â‹†&gt; pure (pure (cons âˆ˜ pair e)) &lt;â‹†&gt;
 (g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt; (pure (mapdt g) &lt;â‹†&gt; mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure compose &lt;â‹†&gt;
(pure (ap G2) &lt;â‹†&gt;
 (pure (ap G2) &lt;â‹†&gt; pure (pure (cons âˆ˜ pair e)) &lt;â‹†&gt;
  (g â‹†<span class="mi">3</span> f) (e, a))) &lt;â‹†&gt; pure (mapdt g) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6e"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">3</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (compose âˆ˜ ap G2) &lt;â‹†&gt;
(pure (ap G2 (pure (cons âˆ˜ pair e))) &lt;â‹†&gt;
 (g â‹†<span class="mi">3</span> f) (e, a)) &lt;â‹†&gt; pure (mapdt g) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk6f"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (mapdt g) âˆ˜ (cons âˆ˜ pair e)) &lt;â‹†&gt;
f (e, a) &lt;â‹†&gt; mapdt f l =
pure (compose âˆ˜ ap G2 âˆ˜ ap G2 (pure (cons âˆ˜ pair e))) &lt;â‹†&gt;
(g â‹†<span class="mi">3</span> f) (e, a) &lt;â‹†&gt; pure (mapdt g) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk70"><span class="nb">unfold</span> kc3, compose, strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
mapdt f l =
pure
  (<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
   =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) &lt;â‹†&gt;
map g
  (<span class="kr">let</span> &#39;(a, t) := cobind f (e, a) <span class="kr">in</span> map (pair a) t) &lt;â‹†&gt;
pure (mapdt g) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk71"><span class="nb">change</span> (cobind f (e, a)) <span class="kr">with</span> (e, f (e, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
mapdt f l =
pure
  (<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
   =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) &lt;â‹†&gt;
map g (<span class="kr">let</span> &#39;(a, t) := (e, f (e, a)) <span class="kr">in</span> map (pair a) t) &lt;â‹†&gt;
pure (mapdt g) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk72"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
mapdt f l =
pure
  (<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
   =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) &lt;â‹†&gt;
(pure g &lt;â‹†&gt; (pure (pair e) &lt;â‹†&gt; f (e, a))) &lt;â‹†&gt;
pure (mapdt g) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk73"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
mapdt f l =
pure
  ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
    =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) âˆ˜ g) &lt;â‹†&gt;
(pure (pair e) &lt;â‹†&gt; f (e, a)) &lt;â‹†&gt; pure (mapdt g) &lt;â‹†&gt;
mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk74"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
mapdt f l =
pure
  ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
    =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) âˆ˜ g
   âˆ˜ pair e) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt; pure (mapdt g) &lt;â‹†&gt;
mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk75"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
mapdt f l =
pure (evalAt (mapdt g)) &lt;â‹†&gt;
(pure
   ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
     =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) âˆ˜ g
    âˆ˜ pair e) &lt;â‹†&gt; f (e, a)) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk76"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt;
mapdt f l =
pure
  (evalAt (mapdt g)
   âˆ˜ ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C)
         (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C))) =&gt;
       ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) âˆ˜ g
      âˆ˜ pair e)) &lt;â‹†&gt; f (e, a) &lt;â‹†&gt; mapdt f l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk77"><span class="kp">repeat</span> fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; mapdt g â—‹ cons (e, a)) =
evalAt (mapdt g)
âˆ˜ ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
    =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) âˆ˜ g
   âˆ˜ pair e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk78">ext b l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt g ((e, b) :: l&#39;) =
(evalAt (mapdt g)
 âˆ˜ ((<span class="kr">fun</span> (<span class="nv">a</span> : G2 C) (<span class="nv">f</span> : env E B -&gt; G2 (list (E * C)))
     =&gt; ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; a) â—‹ f) âˆ˜ g
    âˆ˜ pair e)) b l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk79"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt g ((e, b) :: l&#39;) =
evalAt (mapdt g)
  (<span class="kr">fun</span> <span class="nv">f</span> : env E B -&gt; G2 (list (E * C)) =&gt;
   ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; g (e, b)) â—‹ f) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7a"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; Ïƒ (e, g (e, b)) &lt;â‹†&gt; mapdt g l&#39; =
evalAt (mapdt g)
  (<span class="kr">fun</span> <span class="nv">f</span> : env E B -&gt; G2 (list (E * C)) =&gt;
   ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; g (e, b)) â—‹ f) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7b"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; map (pair e) (g (e, b)) &lt;â‹†&gt; mapdt g l&#39; =
evalAt (mapdt g)
  (<span class="kr">fun</span> <span class="nv">f</span> : env E B -&gt; G2 (list (E * C)) =&gt;
   ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; g (e, b)) â—‹ f) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7c"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; (pure (pair e) &lt;â‹†&gt; g (e, b)) &lt;â‹†&gt;
mapdt g l&#39; =
evalAt (mapdt g)
  (<span class="kr">fun</span> <span class="nv">f</span> : env E B -&gt; G2 (list (E * C)) =&gt;
   ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; g (e, b)) â—‹ f) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7d"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E * B -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (mapdt g) (mapdt f l) = mapdt (g â‹†<span class="mi">3</span> f) l</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list (E * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (cons âˆ˜ pair e) &lt;â‹†&gt; g (e, b) &lt;â‹†&gt; mapdt g l&#39; =
evalAt (mapdt g)
  (<span class="kr">fun</span> <span class="nv">f</span> : env E B -&gt; G2 (list (E * C)) =&gt;
   ap G2 (pure (cons â—‹ pair e) &lt;â‹†&gt; g (e, b)) â—‹ f) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7e"><span class="kn">Lemma</span> <span class="nf">env_mapdt_morph</span>
    `{ApplicativeMorphism G1 G2 Ï•}:
      <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: E * A -&gt; G1 B),
          Ï• (env E B) âˆ˜ mapdt (T := env E) f =
            mapdt (T := env E) (Ï• B âˆ˜ f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; G1 B),
Ï• (env E B) âˆ˜ mapdt f = mapdt (Ï• B âˆ˜ f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; G1 B),
Ï• (env E B) âˆ˜ mapdt f = mapdt (Ï• B âˆ˜ f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk80"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (env E B) âˆ˜ mapdt f = mapdt (Ï• B âˆ˜ f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk81">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>env E A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk82"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï• (env E B) âˆ˜ mapdt f) [] = mapdt (Ï• B âˆ˜ f) []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="environment-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><label class="goal-separator" for="environment-v-chk83"><hr></label><div class="goal-conclusion">(Ï• (env E B) âˆ˜ mapdt f) (a :: l) =
mapdt (Ï• B âˆ˜ f) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk84">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï• (env E B) âˆ˜ mapdt f) [] = mapdt (Ï• B âˆ˜ f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk85"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (env E B) (mapdt f []) = mapdt (Ï• B â—‹ f) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk86"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (env E B) (pure []) = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk87"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure [] = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk88">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E * A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï• (env E B) âˆ˜ mapdt f) (a :: l) =
mapdt (Ï• B âˆ˜ f) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk89"><span class="nb">destruct</span> a <span class="kr">as</span> (e, a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Ï• (env E B) âˆ˜ mapdt f) ((e, a) :: l) =
mapdt (Ï• B âˆ˜ f) ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8a"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (env E B) (mapdt f ((e, a) :: l)) =
mapdt (Ï• B âˆ˜ f) ((e, a) :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8b"><span class="nb">autorewrite with</span> tea_env.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (env E B)
  (pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a)) &lt;â‹†&gt; mapdt f l) =
pure cons &lt;â‹†&gt; Ïƒ (e, (Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
mapdt (Ï• B âˆ˜ f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8c"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (env E B)
  (pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a)) &lt;â‹†&gt; mapdt f l) =
pure cons &lt;â‹†&gt; Ïƒ (e, (Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
(Ï• (env E B) âˆ˜ mapdt f) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8d"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (env E B)
  (pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a)) &lt;â‹†&gt; mapdt f l) =
pure cons &lt;â‹†&gt; Ïƒ (e, (Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
Ï• (env E B) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8e"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (list (E * B) -&gt; env E B)
  (pure cons &lt;â‹†&gt; Ïƒ (e, f (e, a))) &lt;â‹†&gt;
Ï• (list (E * B)) (mapdt f l) =
pure cons &lt;â‹†&gt; Ïƒ (e, (Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
Ï• (env E B) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk8f"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï• (E * B -&gt; list (E * B) -&gt; env E B) (pure cons) &lt;â‹†&gt;
Ï• (E * B) (Ïƒ (e, f (e, a))) &lt;â‹†&gt;
Ï• (list (E * B)) (mapdt f l) =
pure cons &lt;â‹†&gt; Ïƒ (e, (Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
Ï• (env E B) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk90"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; Ï• (E * B) (Ïƒ (e, f (e, a))) &lt;â‹†&gt;
Ï• (list (E * B)) (mapdt f l) =
pure cons &lt;â‹†&gt; Ïƒ (e, (Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
Ï• (env E B) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk91"><span class="nb">unfold</span> strength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; Ï• (E * B) (map (pair e) (f (e, a))) &lt;â‹†&gt;
Ï• (list (E * B)) (mapdt f l) =
pure cons &lt;â‹†&gt; map (pair e) ((Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
Ï• (env E B) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk92"><span class="nb">rewrite</span> appmor_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span>G1 â‡’ G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>E * A -&gt; G1 B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (E * A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(Ï• (env E B) âˆ˜ mapdt f) l = mapdt (Ï• B âˆ˜ f) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; map (pair e) (Ï• B (f (e, a))) &lt;â‹†&gt;
Ï• (list (E * B)) (mapdt f l) =
pure cons &lt;â‹†&gt; map (pair e) ((Ï• B âˆ˜ f) (e, a)) &lt;â‹†&gt;
Ï• (env E B) (mapdt f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">env_laws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Typeclass Instance *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedTraversableFunctor_env</span> (<span class="nv">E</span>: <span class="kt">Type</span>):
  DecoratedTraversableFunctor E (env E) :=
  {| kdtf_mapdt1 := env_mapdt1 E;
     kdtf_mapdt2 := @env_mapdt2 E;
     kdtf_morph := @env_mapdt_morph E;
  |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Functor_env</span> (<span class="nv">E</span>: <span class="kt">Type</span>): Functor (env E) :=
  DerivedInstances.Functor_DecoratedTraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedFunctor_env</span> (<span class="nv">E</span>: <span class="kt">Type</span>):
  DecoratedFunctor E (env E) :=
  DerivedInstances.DecoratedFunctor_DecoratedTraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">TraversableFunctor_env</span> (<span class="nv">E</span>: <span class="kt">Type</span>):
  TraversableFunctor (env E) :=
  DerivedInstances.TraversableFunctor_DecoratedTraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Alternative Specifications for &lt;&lt;mapd&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk93"><span class="kn">Lemma</span> <span class="nf">env_mapd_spec</span>: <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: E * A -&gt; B),
    mapd (T := env E) f = map (F := list) (cobind (W := (E Ã—)) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = map (cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : E * A -&gt; B),
mapd f = map (cobind f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk95"><span class="kn">Lemma</span> <span class="nf">env_map_spec</span>:
  <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; B),
    map (F := env E) f = map (F := list) (map (F := (E Ã—)) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f = map (map f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_env_tactic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk97"><span class="kn">Lemma</span> <span class="nf">env_map_spec2</span>: <span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; B),
    map (F := env E) f = map (Map := Map_compose list (E Ã—)) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B), map f = map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk98"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">E</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B), map f = map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="environment-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="environment-v-chk99"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>E, A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f = map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> env_map_spec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Decorated Traversable Monad Instance (Kleisli) *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">env</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Monoid W}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Return_env</span>: Return (env W) :=
    <span class="kr">fun</span> <span class="nv">A</span> =&gt; ret (T := list) âˆ˜ ret (T := (W Ã—)) (A := A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">binddt_env</span> (<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) `{Map G} `{Pure G} `{Mult G}
    `(f: W * A -&gt; G (env W B)) (Î“: env W A): G (env W B) :=
    <span class="kr">match</span> Î“ <span class="kr">with</span>
    | nil =&gt; pure (@nil (W * B))
    | (w, a) :: rest =&gt;
        pure (@List.app (W * B))
          &lt;â‹†&gt; map (F := G) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; shift list (w, x)) (f (w, a))
          &lt;â‹†&gt; binddt_env G f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bindd_env</span> `(f: W * A -&gt; env W B) (Î“: env W A): env W B :=
    <span class="kr">match</span> Î“ <span class="kr">with</span>
    | nil =&gt; @nil (W * B)
    | (w, a) :: rest =&gt;
        shift list (w, f (w, a)) ++ bindd_env f rest
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bind_env</span> `(f: A -&gt; env W B) (l: env W A): env W B :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | nil =&gt; pure (@nil (W * B))
    | (w, a) :: xs =&gt;
        pure (@List.app (W * B))
          &lt;â‹†&gt; shift list (w, f a)
          &lt;â‹†&gt; bind_env f xs
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Binddt_env</span>: Binddt W (env W) (env W) := @binddt_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Bindd_env</span>: Bindd W (env W) (env W) := @bindd_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Bind_env</span>: Bind (env W) (env W) := @bind_env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">env</span>.</span></span></pre>
</div>
</div></body>
</html>
