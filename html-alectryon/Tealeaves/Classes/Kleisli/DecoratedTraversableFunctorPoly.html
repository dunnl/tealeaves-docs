<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>DecoratedTraversableFunctorPoly.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Kleisli.DecoratedTraversableMonad
  Classes.Kleisli.DecoratedTraversableCommIdemFunctor
  Classes.Kleisli.TraversableFunctor2
  Classes.Kleisli.Theory.TraversableFunctor
  Functors.List
  Functors.List_Telescoping_General
  Functors.Z2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Product.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monad.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Comonad.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DecoratedTraversableCommIdemFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">œï</span> G T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Polymorphically Decorated Traversable Functors *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** Operation &lt;&lt;mapdtp&gt;&gt; *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">MapdtPoly</span> (<span class="nv">T</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) :=
    mapdtp:
      <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">B2</span> <span class="nv">A1</span> <span class="nv">A2</span>: <span class="kt">Type</span>)
        (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
        `{Gmap: Map G} `{Gpure: Pure G} `{Gmult: Mult G},
        (list B1 * B1 -&gt; G B2) -&gt;
        (list B1 * A1 -&gt; G A2) -&gt;
        T B1 A1 -&gt;
        G (T B2 A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> mapdtp {T}%function_scope {MapdtPoly} {B1 B2 A1 A2}%type_scope
  {G}%function_scope {Gmap Gpure Gmult} (_ _)%function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Kleisli Composition *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">kc_dtfp</span> {<span class="nv">T</span>}
  `{MapdtPoly T}
  {G1 : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
  `{map_G1: Map G1} `{pure_G1: Pure G1} `{mult_G1: Mult G1}
  {G2 : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
  `{map_G2: Map G2} `{pure_G2: Pure G2} `{mult_G2: Mult G2}
  {B1 A1 B2 A2 A3: <span class="kt">Type</span>}
  (œÉ2: list B2 * A2 -&gt; G2 A3) <span class="c">(* second op to rename variables *)</span>
  (œÅ1: list B1 * B1 -&gt; G1 B2) <span class="c">(* first op to rename binders *)</span>
  (œÉ1: list B1 * A1 -&gt; G1 A2) <span class="c">(* first op to rename variables *)</span>
  : list B1 * A1 -&gt; (G1 ‚àò G2) A3 :=
  <span class="kr">fun</span> &#39;(ctx, a) =&gt;
    map (F := G1) œÉ2 (pure pair
                        &lt;‚ãÜ&gt; mapdt_ci (W := Z) œÅ1 ctx
                        &lt;‚ãÜ&gt; œÉ1 (ctx, a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Typeclass *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">DecoratedTraversableFunctorPoly</span>
    (<span class="nv">T</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{MapdtPoly T} :=
  { kdtfp_mapdtp1:
    <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">A</span>: <span class="kt">Type</span>),
      mapdtp (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)
        (extract (W := (list B √ó)))
        (extract (W := (list B √ó)))
      = @id (T B A);
    kdtfp_mapdtp2:
    <span class="kr">forall</span> {<span class="nv">B1</span> <span class="nv">B2</span> <span class="nv">B3</span>: <span class="kt">Type</span>}
      {<span class="nv">A1</span> <span class="nv">A2</span> <span class="nv">A3</span>: <span class="kt">Type</span>}
      `{Applicative G1}
      `{Applicative G2}
      (œÅ1: list B1 * B1 -&gt; G1 B2)
      (œÅ2: list B2 * B2 -&gt; G2 B3)
      (œÉ1: list B1 * A1 -&gt; G1 A2)
      (œÉ2: list B2 * A2 -&gt; G2 A3),
      (<span class="kr">forall</span> <span class="nv">p</span>: list B1 * B1, IdempotentCenter G1 B2 (œÅ1 p)) -&gt;
      map (F := G1) (mapdtp (G := G2) œÅ2 œÉ2) ‚àò
        mapdtp (G := G1) (T := T) œÅ1 œÉ1 =
        mapdtp (T := T) (G := G1 ‚àò G2)
          (œÅ2 ‚ãÜ<span class="mi">3_</span>ci œÅ1) (kc_dtfp œÉ2 œÅ1 œÉ1);
    kdtfp_morphism:
    <span class="kr">forall</span> {<span class="nv">B1</span> <span class="nv">A1</span> <span class="nv">B2</span> <span class="nv">A2</span>: <span class="kt">Type</span>} {<span class="nv">G1</span> <span class="nv">G2</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
      `{morph: ApplicativeMorphism G1 G2 œï}
      (œÅ: list B1 * B1 -&gt; G1 B2)
      (œÉ: list B1 * A1 -&gt; G1 A2),
      œï (T B2 A2) ‚àò mapdtp œÅ œÉ =
        mapdtp (œï B2 ‚àò œÅ) (œï A2 ‚àò œÉ);
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Derived Monomorphic Instances *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(** ** Derived Monomorphic Operations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DerivedOperations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">decorated_traversable_functor_derived_operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{DecoratedTraversableFunctorPoly T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">B</span>: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Mapdt_Mapdtp</span>: Mapdt (list B) (T B) :=
      <span class="kr">fun</span> <span class="nv">G</span> <span class="nv">MapG</span> <span class="nv">PureG</span> <span class="nv">MultG</span> <span class="nv">A1</span> <span class="nv">A2</span> <span class="nv">f</span> =&gt;
        mapdtp (T := T) (G := G)
          (pure (F := G) ‚àò extract) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Traversep_Mapdtp</span>: TraversePoly T :=
      <span class="kr">fun</span> <span class="nv">A1</span> <span class="nv">A2</span> <span class="nv">B1</span> <span class="nv">B2</span> <span class="nv">G</span> <span class="nv">MapG</span> <span class="nv">PureG</span> <span class="nv">MultG</span> <span class="nv">g</span> <span class="nv">f</span> =&gt;
        mapdtp (T := T) (G := G)
          (g ‚àò extract) (f ‚àò extract).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">decorated_traversable_functor_derived_operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DerivedOperations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Derived Typeclass Instances *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DerivedInstances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">decorated_traversable_functor_derived_instances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
      `{DecoratedTraversableFunctorPoly T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">B</span>: <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk0">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedTraversableFunctor_DTFP</span>:
      DecoratedTraversableFunctor (list B) (T B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor (list B) (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor (list B) (T B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk2"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt extract = id</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="decoratedtraversablefunctorpoly-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="decoratedtraversablefunctorpoly-v-chk3"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G1)
  (<span class="nv">Pure_G</span> : Pure G1) (<span class="nv">Mult_G</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G0</span> : Map G2)
  (<span class="nv">Pure_G0</span> : Pure G2) (<span class="nv">Mult_G0</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B0</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : list B * B0 -&gt; G2 C)
  (<span class="nv">f</span> : list B * A -&gt; G1 B0),
map (mapdt g) ‚àò mapdt f = mapdt (kc3 g f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="decoratedtraversablefunctorpoly-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="decoratedtraversablefunctorpoly-v-chk4"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H0</span> : Map G1)
  (<span class="nv">H1</span> : Mult G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Map G2)
  (<span class="nv">H4</span> : Mult G2) (<span class="nv">H5</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : list B * A -&gt; G1 B0),
œï (T B B0) ‚àò mapdt f = mapdt (œï B0 ‚àò f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk6"><span class="nb">intro</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk7">unfold_ops @Mapdt_Mapdtp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract) extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk8">unfold_ops @Pure_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (id ‚àò extract) extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk9"><span class="nb">change</span> (id ‚àò <span class="nl">?x</span>) <span class="kr">with</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp extract extract = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chka"><span class="nb">rewrite</span> kdtfp_mapdtp1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G1)
  (<span class="nv">Pure_G</span> : Pure G1) (<span class="nv">Mult_G</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G0</span> : Map G2)
  (<span class="nv">Pure_G0</span> : Pure G2) (<span class="nv">Mult_G0</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B0</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : list B * B0 -&gt; G2 C)
  (<span class="nv">f</span> : list B * A -&gt; G1 B0),
map (mapdt g) ‚àò mapdt f = mapdt (kc3 g f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chkc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdt g) ‚àò mapdt f = mapdt (kc3 g f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chkd">unfold_ops @Mapdt_Mapdtp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdtp (pure ‚àò extract) g)
‚àò mapdtp (pure ‚àò extract) f =
mapdtp (pure ‚àò extract) (kc3 g f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chke"><span class="nb">rewrite</span> kdtfp_mapdtp2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract)
  (kc_dtfp g (pure ‚àò extract) f) =
mapdtp (pure ‚àò extract) (kc3 g f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="decoratedtraversablefunctorpoly-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><label class="goal-separator" for="decoratedtraversablefunctorpoly-v-chkf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : list B * B,
IdempotentCenter G1 B ((pure ‚àò extract) p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk10"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : list B * B,
IdempotentCenter G1 B ((pure ‚àò extract) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk11">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract)
  (kc_dtfp g (pure ‚àò extract) f) =
mapdtp (pure ‚àò extract) (kc3 g f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk12">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract = pure ‚àò extract</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="decoratedtraversablefunctorpoly-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><label class="goal-separator" for="decoratedtraversablefunctorpoly-v-chk13"><hr></label><div class="goal-conclusion">kc_dtfp g (pure ‚àò extract) f = kc3 g f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk14">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract = pure ‚àò extract</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk15"><span class="nb">unfold</span> kc3_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pure ‚àò extract) ‚àò mapdt_ci (pure ‚àò extract) =
pure ‚àò extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk16">ext [w b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (pure ‚àò extract) ‚àò mapdt_ci (pure ‚àò extract))
  (w, b) = (pure ‚àò extract) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk17"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pure ‚óã extract)
  (mapdt_ci (pure ‚óã extract) (w, b)) =
pure (extract (w, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk18"><span class="nb">unfold</span> mapdt_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pure ‚óã extract)
  (Mapdt_CommIdem_Z G1 Map_G Pure_G Mult_G B B
     (pure ‚óã extract) (w, b)) = pure (extract (w, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk19"><span class="nb">unfold</span> Mapdt_CommIdem_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pure ‚óã extract)
  ((traverse (pure ‚óã extract) ‚àò Comonad.cojoin) (w, b)) =
pure (extract (w, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk1a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pure ‚óã extract)
  (pure pair &lt;‚ãÜ&gt;
   traverse (pure ‚óã extract) (decorate_prefix_list w) &lt;‚ãÜ&gt;
   pure b) = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk1b"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (pure ‚óã extract))
  (pure pair &lt;‚ãÜ&gt;
   traverse (pure ‚óã extract) (decorate_prefix_list w)) &lt;‚ãÜ&gt;
pure b = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk1c"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (pure ‚óã extract))) (pure pair) &lt;‚ãÜ&gt;
traverse (pure ‚óã extract) (decorate_prefix_list w) &lt;‚ãÜ&gt;
pure b = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk1d"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (pure ‚óã extract) ‚àò pair) &lt;‚ãÜ&gt;
traverse (pure ‚óã extract) (decorate_prefix_list w) &lt;‚ãÜ&gt;
pure b = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk1e"><span class="nb">change</span> (pure (F := G1) ‚óã extract)
            <span class="kr">with</span> (pure (F := G1) ‚àò extract (W := prod (list B)) (A := B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (pure ‚óã extract) ‚àò pair) &lt;‚ãÜ&gt;
traverse (pure ‚àò extract) (decorate_prefix_list w) &lt;‚ãÜ&gt;
pure b = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk1f"><span class="nb">rewrite</span> &lt;- traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (pure ‚óã extract) ‚àò pair) &lt;‚ãÜ&gt;
(traverse pure ‚àò map extract) (decorate_prefix_list w) &lt;‚ãÜ&gt;
pure b = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk20"><span class="nb">rewrite</span> (traverse_purity1 (T := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (pure ‚óã extract) ‚àò pair) &lt;‚ãÜ&gt;
(pure ‚àò map extract) (decorate_prefix_list w) &lt;‚ãÜ&gt;
pure b = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk21"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (<span class="kr">fun</span> (<span class="nv">a</span> : list B) (<span class="nv">a0</span> : B) =&gt; pure (extract (a, a0))) &lt;‚ãÜ&gt;
pure (map extract (decorate_prefix_list w)) &lt;‚ãÜ&gt; pure b =
pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk22"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt;
   pure
     (extract
        (map extract (decorate_prefix_list w), a))) &lt;‚ãÜ&gt;
pure b = pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk23"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (pure
     (extract
        (map extract (decorate_prefix_list w), b))) =
pure b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk24">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kc_dtfp g (pure ‚àò extract) f = kc3 g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk25">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">kc_dtfp g (pure ‚àò extract) f = kc3 g f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk26"><span class="nb">unfold</span> kc_dtfp, kc3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> &#39;(ctx, a) =&gt;
 map g
   (pure pair &lt;‚ãÜ&gt; mapdt_ci (pure ‚àò extract) ctx &lt;‚ãÜ&gt;
    f (ctx, a))) = map g ‚àò strength ‚àò cobind f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk27">ext [ctx a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (pure pair &lt;‚ãÜ&gt; mapdt_ci (pure ‚àò extract) ctx &lt;‚ãÜ&gt;
   f (ctx, a)) =
(map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk28"><span class="nb">unfold</span> mapdt_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (pure pair &lt;‚ãÜ&gt;
   Mapdt_CommIdem_list_prefix G1 Map_G Pure_G Mult_G B
     B (pure ‚àò extract) ctx &lt;‚ãÜ&gt; f (ctx, a)) =
(map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk29"><span class="nb">unfold</span> Mapdt_CommIdem_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map g
  (pure pair &lt;‚ãÜ&gt;
   mapdt_list_prefix (pure ‚àò extract) ctx &lt;‚ãÜ&gt;
   f (ctx, a)) =
(map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk2a"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose g)
  (pure pair &lt;‚ãÜ&gt;
   mapdt_list_prefix (pure ‚àò extract) ctx) &lt;‚ãÜ&gt;
f (ctx, a) = (map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk2b"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose g)) (pure pair) &lt;‚ãÜ&gt;
mapdt_list_prefix (pure ‚àò extract) ctx &lt;‚ãÜ&gt; f (ctx, a) =
(map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk2c"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
mapdt_list_prefix (pure ‚àò extract) ctx &lt;‚ãÜ&gt; f (ctx, a) =
(map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk2d"><span class="nb">unfold</span> mapdt_list_prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
(traverse (pure ‚àò extract) ‚àò decorate_prefix_list) ctx &lt;‚ãÜ&gt;
f (ctx, a) = (map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk2e"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
traverse (pure ‚àò extract) (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
f (ctx, a) = (map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk2f"><span class="nb">rewrite</span> &lt;- traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
(traverse pure ‚àò map extract)
  (decorate_prefix_list ctx) &lt;‚ãÜ&gt; f (ctx, a) =
(map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk30"><span class="nb">rewrite</span> (traverse_purity1 (T := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
(pure ‚àò map extract) (decorate_prefix_list ctx) &lt;‚ãÜ&gt;
f (ctx, a) = (map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk31"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose g ‚àò pair) &lt;‚ãÜ&gt;
pure (map extract (decorate_prefix_list ctx)) &lt;‚ãÜ&gt;
f (ctx, a) = (map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk32"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  ((compose g ‚àò pair)
     (map extract (decorate_prefix_list ctx))) &lt;‚ãÜ&gt;
f (ctx, a) = (map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk33"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  ((compose g ‚àò pair)
     (map extract (decorate_prefix_list ctx)))
  (f (ctx, a)) =
(map g ‚àò strength ‚àò cobind f) (ctx, a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk34"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (g ‚óã pair (map extract (decorate_prefix_list ctx)))
  (f (ctx, a)) = map g (strength (cobind f (ctx, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk35"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (g ‚óã pair (map extract (decorate_prefix_list ctx)))
  (f (ctx, a)) = map g (map (pair ctx) (f (ctx, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk36">compose near (f (ctx, a)) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (g ‚óã pair (map extract (decorate_prefix_list ctx)))
  (f (ctx, a)) = (map g ‚àò map (pair ctx)) (f (ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk37"><span class="nb">rewrite</span> (fun_map_map (F := G1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map
  (g ‚óã pair (map extract (decorate_prefix_list ctx)))
  (f (ctx, a)) = map (g ‚àò pair ctx) (f (ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk38">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ‚óã pair (map extract (decorate_prefix_list ctx)) =
g ‚àò pair ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk39">ext b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (map extract (decorate_prefix_list ctx), b) =
(g ‚àò pair ctx) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk3a"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (map extract (decorate_prefix_list ctx), b) =
g (ctx, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk3b">compose near ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g ((map extract ‚àò decorate_prefix_list) ctx, b) =
g (ctx, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk3c"><span class="nb">rewrite</span> decorate_prefix_list_extract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B0, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B * B0 -&gt; G2 C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (id ctx, b) = g (ctx, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H0</span> : Map G1)
  (<span class="nv">H1</span> : Mult G1) (<span class="nv">H2</span> : Pure G1) (<span class="nv">H3</span> : Map G2)
  (<span class="nv">H4</span> : Mult G2) (<span class="nv">H5</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : list B * A -&gt; G1 B0),
œï (T B B0) ‚àò mapdt f = mapdt (œï B0 ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk3e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T B B0) ‚àò mapdt f = mapdt (œï B0 ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk3f">unfold_ops @Mapdt_Mapdtp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï (T B B0) ‚àò mapdtp (pure ‚àò extract) f =
mapdtp (pure ‚àò extract) (œï B0 ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk40"><span class="nb">rewrite</span> kdtfp_morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (œï B ‚àò (pure ‚àò extract)) (œï B0 ‚àò f) =
mapdtp (pure ‚àò extract) (œï B0 ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk41">reassociate &lt;- on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (œï B ‚àò pure ‚àò extract) (œï B0 ‚àò f) =
mapdtp (pure ‚àò extract) (œï B0 ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk42"><span class="nb">rewrite</span> appmor_pure_pf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 œï</span></span></span><br><span><var>A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B * A -&gt; G1 B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract) (œï B0 ‚àò f) =
mapdtp (pure ‚àò extract) (œï B0 ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">decorated_traversable_functor_derived_instances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Kleisli.DecoratedTraversableFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Kleisli.DecoratedTraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DerivedInstances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Relating Polymorphic and Monomorphic Operations *)</span>
<span class="sd">(******************************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">decorated_traversable_functor_polymorphic_monomorphic</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{DecoratedTraversableFunctorPoly T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">monomorphic_binders</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rename_variables</span> {<span class="nv">B</span> <span class="nv">A1</span> <span class="nv">A2</span>}:
      (list B * A1 -&gt; A2) -&gt; T B A1 -&gt; T B A2 :=
      <span class="kr">fun</span> <span class="nv">f</span> =&gt; mapd (T := T B) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rename_binders</span> {<span class="nv">A</span> <span class="nv">B1</span> <span class="nv">B2</span>}:
      (list B1 * B1 -&gt; B2) -&gt; T B1 A -&gt; T B2 A :=
      <span class="kr">fun</span> <span class="nv">f</span> =&gt; mapdtp (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) f (extract).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A1</span> <span class="nv">A2</span> <span class="nv">B1</span> <span class="nv">B2</span>}
      (<span class="nv">g</span>: list B1 * B1 -&gt; B2)
      (<span class="nv">f</span>: list B2 * A1 -&gt; A2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk43"><span class="kn">Lemma</span> <span class="nf">rename_binders_variables_commute</span>:
      rename_variables f ‚àò rename_binders g =
        rename_binders g ‚àò rename_variables
          (<span class="kr">fun</span> &#39;(ctx, a) =&gt;
             f (mapdt_ci (W := Z) (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) g ctx, a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename_variables f ‚àò rename_binders g =
rename_binders g
‚àò rename_variables
    (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename_variables f ‚àò rename_binders g =
rename_binders g
‚àò rename_variables
    (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk45"><span class="nb">unfold</span> rename_variables, rename_binders.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapd f ‚àò mapdtp g extract =
mapdtp g extract
‚àò mapd (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk46">unfold_ops @Mapd_Mapdt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdt f ‚àò mapdtp g extract =
mapdtp g extract
‚àò mapdt (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk47">unfold_ops @Mapdt_Mapdtp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract) f ‚àò mapdtp g extract =
mapdtp g extract
‚àò mapdtp (pure ‚àò extract)
    (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk48"><span class="nb">change</span> (mapdtp (T := T) (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) <span class="nl">?g</span> f) <span class="kr">with</span>
        (map (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (mapdtp (T := T) g f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (mapdtp (pure ‚àò extract) f) ‚àò mapdtp g extract =
mapdtp g extract
‚àò mapdtp (pure ‚àò extract)
    (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk49"><span class="nb">rewrite</span> (kdtfp_mapdtp2 (G1 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (G2 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci g) (kc_dtfp f g extract) =
mapdtp g extract
‚àò mapdtp (pure ‚àò extract)
    (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="decoratedtraversablefunctorpoly-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><label class="goal-separator" for="decoratedtraversablefunctorpoly-v-chk4a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : list B1 * B1,
IdempotentCenter (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) B2 (g p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk4b"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : list B1 * B1,
IdempotentCenter (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) B2 (g p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk4c"><span class="nb">intros</span> [ctx b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IdempotentCenter (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) B2 (g (ctx, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">constructor</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk4d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci g) (kc_dtfp f g extract) =
mapdtp g extract
‚àò mapdtp (pure ‚àò extract)
    (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk4e"><span class="nb">change</span> (mapdtp (T := T) (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)
                g <span class="nl">?ext</span>)
        <span class="kr">with</span>
        (map (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)
           (mapdtp (T := T) (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)
              g ext)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci g) (kc_dtfp f g extract) =
map (mapdtp g extract)
‚àò mapdtp (pure ‚àò extract)
    (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk4f"><span class="nb">rewrite</span> (kdtfp_mapdtp2 (G1 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (G2 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci g) (kc_dtfp f g extract) =
mapdtp (g ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract)
  (kc_dtfp extract (pure ‚àò extract)
     (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="decoratedtraversablefunctorpoly-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><label class="goal-separator" for="decoratedtraversablefunctorpoly-v-chk50"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : list B1 * B1,
IdempotentCenter (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) B1
  ((pure ‚àò extract) p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk51"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : list B1 * B1,
IdempotentCenter (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) B1
  ((pure ‚àò extract) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk52"><span class="nb">intros</span> [ctx b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IdempotentCenter (<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; A) B1
  ((pure ‚àò extract) (ctx, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">constructor</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk53">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapdtp (pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci g) (kc_dtfp f g extract) =
mapdtp (g ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract)
  (kc_dtfp extract (pure ‚àò extract)
     (<span class="kr">fun</span> &#39;(ctx, a) =&gt; f (mapdt_ci g ctx, a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk54">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci g = g ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk55">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò extract ‚ãÜ<span class="mi">3_</span>ci g = g ‚ãÜ<span class="mi">3_</span>ci pure ‚àò extract</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk56"><span class="nb">unfold</span> kc3_ci.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (pure ‚àò extract) ‚àò mapdt_ci g =
map g ‚àò mapdt_ci (pure ‚àò extract)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk57">ext [w b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (pure ‚àò extract) ‚àò mapdt_ci g) (w, b) =
(map g ‚àò mapdt_ci (pure ‚àò extract)) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk58">unfold_ops @Map_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure ‚àò extract ‚àò mapdt_ci g) (w, b) =
(g ‚àò mapdt_ci (pure ‚àò extract)) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk59">unfold_ops @Mapdt_CommIdem_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure ‚àò extract ‚àò (traverse g ‚àò Comonad.cojoin))
  (w, b) =
(g ‚àò (traverse (pure ‚àò extract) ‚àò Comonad.cojoin))
  (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk5a"><span class="kp">repeat</span> reassociate &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure ‚àò extract ‚àò traverse g ‚àò Comonad.cojoin) (w, b) =
(g ‚àò traverse (pure ‚àò extract) ‚àò Comonad.cojoin)
  (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk5b"><span class="nb">rewrite</span> &lt;- (traverse_map (G2 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (T := Z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure ‚àò extract ‚àò traverse g ‚àò Comonad.cojoin) (w, b) =
(g ‚àò (traverse pure ‚àò map extract) ‚àò Comonad.cojoin)
  (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk5c"><span class="nb">rewrite</span> traverse_purity1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure ‚àò extract ‚àò traverse g ‚àò Comonad.cojoin) (w, b) =
(g ‚àò (pure ‚àò map extract) ‚àò Comonad.cojoin) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk5d"><span class="nb">rewrite</span> &lt;- map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure ‚àò extract ‚àò map g ‚àò Comonad.cojoin) (w, b) =
(g ‚àò (pure ‚àò map extract) ‚àò Comonad.cojoin) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk5e">unfold_ops @Pure_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(id ‚àò extract ‚àò map g ‚àò Comonad.cojoin) (w, b) =
(g ‚àò (id ‚àò map extract) ‚àò Comonad.cojoin) (w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk5f"><span class="nb">unfold</span> compose, id; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (id (w, b)) =
g (id (map extract (decorate_prefix_list w)), b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk60"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (w, b) = g (map extract (decorate_prefix_list w), b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk61">compose near w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (w, b) =
g ((map extract ‚àò decorate_prefix_list) w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="decoratedtraversablefunctorpoly-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="decoratedtraversablefunctorpoly-v-chk62"><span class="nb">rewrite</span> decorate_prefix_list_extract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapdtPoly T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>DecoratedTraversableFunctorPoly T</span></span></span><br><span><var>A1, A2, B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>list B2 * A1 -&gt; A2</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (w, b) = g (id w, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">monomorphic_binders</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">decorated_traversable_functor_polymorphic_monomorphic</span>.</span></span></pre>
</div>
</div></body>
</html>
