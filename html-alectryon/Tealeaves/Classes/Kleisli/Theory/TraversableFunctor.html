<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>TraversableFunctor.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Kleisli.TraversableFunctor
  Classes.Categorical.ContainerFunctor
  Classes.Categorical.ShapelyFunctor
  Classes.Categorical.Monad (Return, ret)
  Functors.Backwards
  Functors.Constant
  Functors.Identity
  Functors.Early.List
  Functors.ProductFunctor
  Misc.<span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Categorical.ApplicativeCommutativeIdempotent.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require</span>
  Classes.Coalgebraic.TraversableFunctor
  Adapters.KleisliToCoalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Kleisli.TraversableFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ContainerFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Subset.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Categorical.Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ProductFunctor.Notations. <span class="c">(* ‚óª *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variable</span> <span class="nf">T</span> G M œï A B C.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Miscellaneous Properties of Traversable Functors *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Traversing in the Idempotent Center stays in the Idempotent Center *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">traverse_comm_idem</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{Applicative G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{f: A -&gt; G B}
    (Hyp: <span class="kr">forall</span> <span class="nv">a</span>, IdempotentCenter G B (f a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk0"><span class="kn">Lemma</span> <span class="nf">traverse_idem_center</span>: <span class="kr">forall</span> (<span class="nv">t</span>: T A),
      IdempotentCenter G (T B) (traverse (G := G) f t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A,
IdempotentCenter G (T B) (traverse f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>Hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IdempotentCenter G B (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A,
IdempotentCenter G (T B) (traverse f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Actually, this requires the representation theorem *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">traverse_comm_idem</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Interaction between &lt;&lt;traverse&gt;&gt; and &lt;&lt;pure&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">traversable_purity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2"><span class="kn">Theorem</span> <span class="nf">traverse_purity1</span>:
    <span class="kr">forall</span> `{Applicative G},
      `(traverse (G := G) pure = @pure G _ (T A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt; <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, traverse pure = pure</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt; <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, traverse pure = pure</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse pure = pure</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5"><span class="nb">change</span> (@pure G _ A) <span class="kr">with</span> (@pure G _ A ‚àò id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (pure ‚àò id) = pure</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6"><span class="nb">rewrite</span> &lt;- (trf_traverse_morphism (G1 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (G2 := G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò traverse id = pure</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7"><span class="nb">rewrite</span> trf_traverse_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò id = pure</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8"><span class="kn">Lemma</span> <span class="nf">traverse_purity2</span>:
    <span class="kr">forall</span> `{Applicative G2}
      `{Applicative G1}
      `(f: A -&gt; G1 B),
      traverse (G := G2 ‚àò G1) (pure (F := G2) ‚àò f) =
        pure (F := G2) ‚àò traverse f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G2)
  (<span class="nv">Pure_G</span> : Pure G2) (<span class="nv">Mult_G</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G0</span> : Map G1)
  (<span class="nv">Pure_G0</span> : Pure G1) (<span class="nv">Mult_G0</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G1 B),
traverse (pure ‚àò f) = pure ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G2)
  (<span class="nv">Pure_G</span> : Pure G2) (<span class="nv">Mult_G</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G0</span> : Map G1)
  (<span class="nv">Pure_G0</span> : Pure G1) (<span class="nv">Mult_G0</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G1 B),
traverse (pure ‚àò f) = pure ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (pure ‚àò f) = pure ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb"><span class="nb">rewrite</span> &lt;- (trf_traverse_morphism (G1 := G1) (G2 := G2 ‚àò G1)
                 (œï := <span class="kr">fun</span> <span class="nv">A</span> =&gt; @pure G2 _ (G1 A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò traverse f = pure ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Map T}
    `{! Compat_Map_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc"><span class="kn">Lemma</span> <span class="nf">traverse_purity3</span>:
    <span class="kr">forall</span> `{Applicative G2}
      `(f: A -&gt; B),
      traverse (T := T) (G := G2) (pure (F := G2) ‚àò f) =
        pure (F := G2) ‚àò map f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G2)
  (<span class="nv">Pure_G</span> : Pure G2) (<span class="nv">Mult_G</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
traverse (pure ‚àò f) = pure ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G2)
  (<span class="nv">Pure_G</span> : Pure G2) (<span class="nv">Mult_G</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
traverse (pure ‚àò f) = pure ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (pure ‚àò f) = pure ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf"><span class="nb">rewrite</span> &lt;- (trf_traverse_morphism (G1 := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (G2 := G2)
                 (œï := <span class="kr">fun</span> <span class="nv">A</span> =&gt; @pure G2 _ (A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò traverse f = pure ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10"><span class="nb">rewrite</span> map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure ‚àò traverse f = pure ‚àò traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">traversable_purity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Factorizing Operations through &lt;&lt;runBatch&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">factorize_operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Coalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Adapters.KleisliToCoalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Map T}
    `{ToBatch T}
    `{Traverse T}
    `{! Kleisli.TraversableFunctor.TraversableFunctor T}
    `{! Compat_Map_Traverse T}
    `{! Compat_ToBatch_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factoring operations through &lt;&lt;toBatch&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11"><span class="kn">Lemma</span> <span class="nf">traverse_through_runBatch</span>
    `{Applicative G} `(f: A -&gt; G B):
    traverse f = runBatch f ‚àò toBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13"><span class="nb">rewrite</span> toBatch_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò traverse (batch A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14"><span class="nb">rewrite</span> trf_traverse_morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse (runBatch f ‚àò batch A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15"><span class="nb">rewrite</span> (runBatch_batch G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk16"><span class="kn">Corollary</span> <span class="nf">map_through_runBatch</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: A -&gt; B):
    map f = runBatch (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) f ‚àò toBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk18"><span class="nb">rewrite</span> map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk19"><span class="nb">rewrite</span> traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch f ‚àò toBatch = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1a"><span class="kn">Corollary</span> <span class="nf">id_through_runBatch</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
      id = runBatch (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) id ‚àò toBatch (T := T) (A&#39; := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, id = runBatch id ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, id = runBatch id ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = runBatch id ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1d"><span class="nb">rewrite</span> &lt;- trf_traverse_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse id = runBatch id ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1e"><span class="nb">rewrite</span> (traverse_through_runBatch (G := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch id ‚àò toBatch = runBatch id ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Naturality of &lt;&lt;toBatch&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk1f"><span class="kn">Lemma</span> <span class="nf">toBatch_mapfst</span>: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; B),
      toBatch (A := B) (A&#39; := A&#39;) ‚àò map f =
        mapfst_Batch f ‚àò toBatch (A := A) (A&#39; := A&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
toBatch ‚àò map f = mapfst_Batch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
toBatch ‚àò map f = mapfst_Batch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk21"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toBatch ‚àò map f = mapfst_Batch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk22"><span class="nb">rewrite</span> toBatch_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (batch B A&#39;) ‚àò map f =
mapfst_Batch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk23"><span class="nb">rewrite</span> traverse_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (batch B A&#39; ‚àò f) = mapfst_Batch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk24"><span class="nb">rewrite</span> toBatch_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (batch B A&#39; ‚àò f) =
mapfst_Batch f ‚àò traverse (batch A A&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk25"><span class="nb">rewrite</span> (trf_traverse_morphism
               (morphism := ApplicativeMorphism_mapfst_Batch f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (batch B A&#39; ‚àò f) =
traverse (mapfst_Batch f ‚àò batch A A&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk26"><span class="nb">rewrite</span> ret_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, B, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (batch B A&#39; ‚àò f) = traverse (batch B A&#39; ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk27"><span class="kn">Lemma</span> <span class="nf">toBatch_mapsnd</span>: <span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">A</span> <span class="nv">A&#39;</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; A&#39;),
      mapsnd_Batch f ‚àò toBatch =
        map (map f) ‚àò toBatch (A := X) (A&#39; := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">A</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; A&#39;),
mapsnd_Batch f ‚àò toBatch = map (map f) ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">A</span> <span class="nv">A&#39;</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; A&#39;),
mapsnd_Batch f ‚àò toBatch = map (map f) ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk29"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>X, A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsnd_Batch f ‚àò toBatch = map (map f) ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2a"><span class="nb">rewrite</span> toBatch_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>X, A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsnd_Batch f ‚àò traverse (batch X A&#39;) =
map (map f) ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2b"><span class="nb">rewrite</span> (trf_traverse_morphism
               (morphism := ApplicativeMorphism_mapsnd_Batch f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>X, A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (mapsnd_Batch f ‚àò batch X A&#39;) =
map (map f) ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2c"><span class="nb">rewrite</span> ret_dinatural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>X, A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (map f ‚àò batch X A) = map (map f) ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2d"><span class="nb">rewrite</span> toBatch_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>X, A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (map f ‚àò batch X A) =
map (map f) ‚àò traverse (batch X A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2e"><span class="nb">rewrite</span> map_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>X, A, A'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (map f ‚àò batch X A) =
traverse (map f ‚àò batch X A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">factorize_operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Traversals by Particular Applicative Functors *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Product of Two Applicative Functors *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">traverse_applicative_product</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">applicative_arrow_combine</span> {<span class="nv">F</span> <span class="nv">G</span> <span class="nv">A</span> <span class="nv">B</span>}
    `(f: A -&gt; F B) `(g: A -&gt; G B): A -&gt; (F ‚óª G) B :=
    <span class="kr">fun</span> <span class="nv">a</span> =&gt; product (f a) (g a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;f &lt;‚óª&gt; g&quot;</span> :=
    (applicative_arrow_combine f g) (<span class="kn">at level</span> <span class="mi">60</span>): tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{Map T}
    `{! Compat_Map_Traverse T}
    `{Applicative G1}
    `{Applicative G2}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span>
    (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>)
    (<span class="nv">f</span>: A -&gt; G1 B)
    (<span class="nv">g</span>: A -&gt; G2 B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk2f"><span class="kn">Lemma</span> <span class="nf">traverse_product1</span>: <span class="kr">forall</span> (<span class="nv">t</span>: T A),
      pi1 (traverse (f &lt;‚óª&gt; g) t) = traverse f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A,
pi1 (traverse (f &lt;‚óª&gt; g) t) = traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A,
pi1 (traverse (f &lt;‚óª&gt; g) t) = traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk31"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pi1 (traverse (f &lt;‚óª&gt; g) t) = traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk32"><span class="nb">pose</span> (ApplicativeMorphism_pi1 G1 G2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>ApplicativeMorphism_pi1 G1 G2</span></span><span class="hyp-type"><b>: </b><span>ApplicativeMorphism (G1 ‚óª G2) G1 (@pi1 G1 G2)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pi1 (traverse (f &lt;‚óª&gt; g) t) = traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk33">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>ApplicativeMorphism_pi1 G1 G2</span></span><span class="hyp-type"><b>: </b><span>ApplicativeMorphism (G1 ‚óª G2) G1 (@pi1 G1 G2)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pi1 ‚àò traverse (f &lt;‚óª&gt; g)) t = traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk34"><span class="nb">rewrite</span> trf_traverse_morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>ApplicativeMorphism_pi1 G1 G2</span></span><span class="hyp-type"><b>: </b><span>ApplicativeMorphism (G1 ‚óª G2) G1 (@pi1 G1 G2)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (pi1 ‚àò (f &lt;‚óª&gt; g)) t = traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk35"><span class="kn">Lemma</span> <span class="nf">traverse_product2</span>: <span class="kr">forall</span> (<span class="nv">t</span>: T A),
      pi2 (traverse (f &lt;‚óª&gt; g) t) = traverse g t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A,
pi2 (traverse (f &lt;‚óª&gt; g) t) = traverse g t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A,
pi2 (traverse (f &lt;‚óª&gt; g) t) = traverse g t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk37"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pi2 (traverse (f &lt;‚óª&gt; g) t) = traverse g t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk38"><span class="nb">pose</span> (ApplicativeMorphism_pi2 G1 G2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>ApplicativeMorphism_pi2 G1 G2</span></span><span class="hyp-type"><b>: </b><span>ApplicativeMorphism (G1 ‚óª G2) G2 (@pi2 G1 G2)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pi2 (traverse (f &lt;‚óª&gt; g) t) = traverse g t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk39">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>ApplicativeMorphism_pi2 G1 G2</span></span><span class="hyp-type"><b>: </b><span>ApplicativeMorphism (G1 ‚óª G2) G2 (@pi2 G1 G2)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pi2 ‚àò traverse (f &lt;‚óª&gt; g)) t = traverse g t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3a"><span class="nb">rewrite</span> trf_traverse_morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>ApplicativeMorphism_pi2 G1 G2</span></span><span class="hyp-type"><b>: </b><span>ApplicativeMorphism (G1 ‚óª G2) G2 (@pi2 G1 G2)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (pi2 ‚àò (f &lt;‚óª&gt; g)) t = traverse g t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3b"><span class="kn">Theorem</span> <span class="nf">traverse_product_spec</span>:
    traverse (f &lt;‚óª&gt; g) = traverse f &lt;‚óª&gt; traverse g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) = traverse f &lt;‚óª&gt; traverse g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) = traverse f &lt;‚óª&gt; traverse g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) = traverse f &lt;‚óª&gt; traverse g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3e">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) t = (traverse f &lt;‚óª&gt; traverse g) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk3f"><span class="nb">unfold</span> applicative_arrow_combine <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) t =
product (traverse f t) (traverse g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk40"><span class="nb">erewrite</span> &lt;- traverse_product1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) t =
product (pi1 (traverse (f &lt;‚óª&gt; g) t)) (traverse g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk41"><span class="nb">erewrite</span> &lt;- traverse_product2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) t =
product (pi1 (traverse (f &lt;‚óª&gt; g) t))
  (pi2 (traverse (f &lt;‚óª&gt; g) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk42"><span class="nb">rewrite</span> &lt;- product_eta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G1 B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt; G2 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (f &lt;‚óª&gt; g) t = traverse (f &lt;‚óª&gt; g) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">traverse_applicative_product</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Constant Applicative Functors *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">constant_applicatives</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{Kleisli.TraversableFunctor.TraversableFunctor T}
    `{Map T}
    `{! Compat_Map_Traverse T}
    `{Monoid M}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk43"><span class="kn">Lemma</span> <span class="nf">traverse_const1</span>:
    <span class="kr">forall</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">B</span>: <span class="kt">Type</span>) `(f: A -&gt; M),
      traverse (G := const M) (B := <span class="kt">False</span>) f =
        traverse (G := const M) (B := B) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk45"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk46">change_left
      (map (F := const M) (A := T <span class="kt">False</span>)
         (B := T B) (map (F := T) (A := <span class="kt">False</span>) (B := B) <span class="nb">exfalso</span>)
         ‚àò traverse (T := T) (G := const M)
         (B := <span class="kt">False</span>) (f: A -&gt; const M <span class="kt">False</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map <span class="nb">exfalso</span>) ‚àò traverse (f : A -&gt; const M <span class="kt">False</span>) =
traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk47"><span class="nb">rewrite</span> (map_traverse (G1 := const M)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (map <span class="nb">exfalso</span> ‚àò f) = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk48"><span class="kn">Lemma</span> <span class="nf">traverse_const2</span>:
    <span class="kr">forall</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">f</span>: A -&gt; M) (<span class="nv">fake1</span> <span class="nv">fake2</span>: <span class="kt">Type</span>),
      traverse (G := const M) (B := fake1) f =
        traverse (G := const M) (B := fake2) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M) (<span class="nv">fake1</span> <span class="nv">fake2</span> : <span class="kt">Type</span>),
traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M) (<span class="nv">fake1</span> <span class="nv">fake2</span> : <span class="kt">Type</span>),
traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>fake1, fake2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4b"><span class="nb">rewrite</span> &lt;- (traverse_const1 fake1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>fake1, fake2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4c"><span class="nb">rewrite</span> -&gt; (traverse_const1 fake2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>fake1, fake2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">constant_applicatives</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Traversals by Commutative Applicatives *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">traversals_commutative</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Coalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4d"><span class="kn">Lemma</span> <span class="nf">traverse_commutative</span>:
    <span class="kr">forall</span> `{Kleisli.TraversableFunctor.TraversableFunctor T}
      `{ToBatch T}
      `{! Compat_ToBatch_Traverse T}
      `{ApplicativeCommutative G}
      (A B: <span class="kt">Type</span>) (f: A -&gt; G B),
      forwards ‚àò traverse (T := T)
        (G := Backwards G) (mkBackwards ‚àò f) =
        traverse (T := T) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Traverse_T</span> : Traverse T),
Kleisli.TraversableFunctor.TraversableFunctor T -&gt;
<span class="kr">forall</span> <span class="nv">H0</span> : ToBatch T,
Compat_ToBatch_Traverse T -&gt;
<span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
forwards ‚àò traverse (mkBackwards ‚àò f) = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Traverse_T</span> : Traverse T),
Kleisli.TraversableFunctor.TraversableFunctor T -&gt;
<span class="kr">forall</span> <span class="nv">H0</span> : ToBatch T,
Compat_ToBatch_Traverse T -&gt;
<span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutative G -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
forwards ‚àò traverse (mkBackwards ‚àò f) = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk4f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards ‚àò traverse (mkBackwards ‚àò f) = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk50">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(forwards ‚àò traverse (mkBackwards ‚àò f)) t =
traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk51"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (traverse (mkBackwards ‚óã f) t) = traverse f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk52"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards ((runBatch (mkBackwards ‚óã f) ‚àò toBatch) t) =
(runBatch f ‚àò toBatch) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk53"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (runBatch (mkBackwards ‚óã f) (toBatch t)) =
runBatch f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk54"><span class="nb">induction</span> (toBatch t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (runBatch (mkBackwards ‚óã f) (Done c)) =
runBatch f (Done c)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f b</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk55"><hr></label><div class="goal-conclusion">forwards (runBatch (mkBackwards ‚óã f) (Step b a)) =
runBatch f (Step b a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (runBatch (mkBackwards ‚óã f) (Done c)) =
runBatch f (Done c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk57">- <span class="c">(*LHS *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards (runBatch (mkBackwards ‚óã f) (Step b a)) =
runBatch f (Step b a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk58"><span class="nb">rewrite</span> runBatch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forwards
  (runBatch (mkBackwards ‚óã f) b &lt;‚ãÜ&gt;
   {| forwards := f a |}) = runBatch f (Step b a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk59"><span class="nb">rewrite</span> forwards_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map evalAt (forwards {| forwards := f a |}) &lt;‚ãÜ&gt;
forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f (Step b a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5a"><span class="nb">rewrite</span> IHb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map evalAt (forwards {| forwards := f a |}) &lt;‚ãÜ&gt;
runBatch f b = runBatch f (Step b a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5b"><span class="nb">rewrite</span> runBatch_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map evalAt (forwards {| forwards := f a |}) &lt;‚ãÜ&gt;
runBatch f b = runBatch f b &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5c"><span class="nb">rewrite</span> &lt;- (ap_swap (a := f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutative G</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Batch A B (B -&gt; C)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>forwards (runBatch (mkBackwards ‚óã f) b) =
runBatch f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch f b &lt;‚ãÜ&gt; f a = runBatch f b &lt;‚ãÜ&gt; f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">traversals_commutative</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">(** ** Traversals by Subset *)</span>
<span class="c">(**********************************************************************)</span>
<span class="c">Section traversals_by_subset.</span>

<span class="c">  Import Coalgebraic.TraversableFunctor.</span>
<span class="c">  Import KleisliToCoalgebraic.TraversableFunctor.</span>

<span class="c">  Lemma traverse_by_subset:</span>
<span class="c">    forall `{Kleisli.TraversableFunctor.TraversableFunctor T}</span>
<span class="c">      `{ToBatch T}</span>
<span class="c">      `{! Compat_ToBatch_Traverse T}</span>
<span class="c">      (A B: Type) (f: A -&gt; subset B),</span>
<span class="c">      forwards ‚àò traverse (T := T)</span>
<span class="c">        (G := Backwards subset) (mkBackwards ‚àò f) =</span>
<span class="c">        traverse (T := T) f.</span>
<span class="c">  Proof.</span>
<span class="c">    intros.</span>
<span class="c">    rewrite traverse_commutative.</span>
<span class="c">    intros. ext t. unfold compose.</span>
<span class="c">    do 2 rewrite traverse_through_runBatch.</span>
<span class="c">    unfold compose.</span>
<span class="c">    induction (toBatch t).</span>
<span class="c">    - reflexivity.</span>
<span class="c">    - cbn. rewrite IHb.</span>
<span class="c">      unfold ap.</span>
<span class="c">      ext c.</span>
<span class="c">      unfold_ops @Mult_subset.</span>
<span class="c">      unfold_ops @Map_subset.</span>
<span class="c">      propext.</span>
<span class="c">      { intros [[mk b&#39;] [[[b&#39;&#39; c&#39;] [rest1 rest2]] Heq]].</span>
<span class="c">        cbn in rest2.</span>
<span class="c">        inversion rest2. subst.</span>
<span class="c">        exists (mk, b&#39;). tauto. }</span>
<span class="c">      { intros [[mk b&#39;] [rest1 rest2]].</span>
<span class="c">        subst. exists (mk, b&#39;). split; auto.</span>
<span class="c">        exists (b&#39;, mk). tauto. }</span>
<span class="c">  Qed.</span>

<span class="c">End traversals_by_subset.</span>
<span class="c">*)</span>

<span class="sd">(** * Derived Operation: &lt;&lt;foldmap&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Operation &lt;&lt;foldMap&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">foldMap</span>
  {<span class="nv">T</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
  `{Traverse T}
  `{op: Monoid_op M} `{unit: Monoid_unit M}
  {A: <span class="kt">Type</span>} (f: A -&gt; M): T A -&gt; M :=
  traverse (G := const M) (B := <span class="kt">False</span>) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">foldMap</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** As a Special Case of &lt;&lt;traverse&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5d"><span class="kn">Lemma</span> <span class="nf">foldMap_to_traverse1</span>
    `{Traverse T}
    `{Monoid M}: <span class="kr">forall</span> `(f: A -&gt; M),
      foldMap (T := T) f =
        traverse (G := const M) (B := <span class="kt">False</span>) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M), foldMap f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M), foldMap f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk5f"><span class="kn">Lemma</span> <span class="nf">foldMap_to_traverse2</span>
    `{Traverse T}
    `{! TraversableFunctor T}
    `{Map T}
    `{! Compat_Map_Traverse T}
    `{Monoid M}: <span class="kr">forall</span> (<span class="nv">fake</span>: <span class="kt">Type</span>) `(f: A -&gt; M),
      foldMap (T := T) f = traverse (G := const M) (B := fake) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">fake</span> <span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">fake</span> <span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk61"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>fake, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk62"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>fake, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk63"><span class="nb">rewrite</span> (traverse_const1 fake f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>TraversableFunctor0</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>fake, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = traverse f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{Map T}
    `{! Compat_Map_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Composition with &lt;&lt;map&gt;&gt; and &lt;&lt;traverse&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk64"><span class="kn">Lemma</span> <span class="nf">foldMap_traverse</span>
    `{Monoid M} (G: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) {B: <span class="kt">Type</span>} `{Applicative G}:
    <span class="kr">forall</span> `(g: B -&gt; M) `(f: A -&gt; G B),
      map (A := T B) (B := M) (foldMap g) ‚àò traverse f =
        foldMap (map g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : B -&gt; M) (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
map (foldMap g) ‚àò traverse f = foldMap (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">g</span> : B -&gt; M) (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; G B),
map (foldMap g) ‚àò traverse f = foldMap (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk66"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (foldMap g) ‚àò traverse f = foldMap (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk67"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (traverse g) ‚àò traverse f = foldMap (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk68"><span class="nb">rewrite</span> (trf_traverse_traverse (G1 := G) (G2 := const M) A B <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚ãÜ<span class="mi">2</span> f) = foldMap (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk69"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚ãÜ<span class="mi">2</span> f) = traverse (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6a"><span class="nb">rewrite</span> map_compose_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚ãÜ<span class="mi">2</span> f) = traverse (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6b"><span class="nb">rewrite</span> mult_compose_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; G B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (g ‚ãÜ<span class="mi">2</span> f) = traverse (map g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6c"><span class="kn">Corollary</span> <span class="nf">foldMap_map</span> `{Monoid M}: <span class="kr">forall</span> `(g: B -&gt; M) `(f: A -&gt; B),
      foldMap g ‚àò map f = foldMap (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; M) (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
foldMap g ‚àò map f = foldMap (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; M) (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
foldMap g ‚àò map f = foldMap (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap g ‚àò map f = foldMap (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk6f"><span class="nb">rewrite</span> map_to_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap g ‚àò traverse f = foldMap (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk70"><span class="nb">change</span> (foldMap g) <span class="kr">with</span>
      (map (F := <span class="kr">fun</span> <span class="nv">A</span> =&gt; A) (A := T B) (B := M) (foldMap g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (foldMap g) ‚àò traverse f = foldMap (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> (foldMap_traverse (<span class="kr">fun</span> <span class="nv">X</span> =&gt; X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Composition with Homomorphisms *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk71"><span class="kn">Lemma</span> <span class="nf">foldMap_morphism</span> (<span class="nv">M1</span> <span class="nv">M2</span>: <span class="kt">Type</span>)
    `{morphism: Monoid_Morphism M1 M2 œï}:
    <span class="kr">forall</span> `(f: A -&gt; M1), œï ‚àò foldMap f = foldMap (œï ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>Monoid_Morphism M1 M2 œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M1),
œï ‚àò foldMap f = foldMap (œï ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>Monoid_Morphism M1 M2 œï</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M1),
œï ‚àò foldMap f = foldMap (œï ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk73"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>Monoid_Morphism M1 M2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï ‚àò foldMap f = foldMap (œï ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk74"><span class="nb">inversion</span> morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>Monoid_Morphism M1 M2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M1</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>Monoid M1</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>Monoid M2</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï ‚àò foldMap f = foldMap (œï ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk75"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>Monoid_Morphism M1 M2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M1</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>Monoid M1</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>Monoid M2</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">œï ‚àò traverse f = foldMap (œï ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk76"><span class="nb">change</span> œï <span class="kr">with</span> (const œï (T <span class="kt">False</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>Monoid_Morphism M1 M2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M1</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>Monoid M1</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>Monoid M2</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const œï (T <span class="kt">False</span>) ‚àò traverse f =
foldMap (const œï (T <span class="kt">False</span>) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk77"><span class="nb">rewrite</span> (trf_traverse_morphism (T := T)
               (G1 := const M1) (G2 := const M2) A <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M1, M2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>src_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M1</span></span></span><br><span><var>src_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M1</span></span></span><br><span><var>tgt_op</var><span class="hyp-type"><b>: </b><span>Monoid_op M2</span></span></span><br><span><var>tgt_unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M2</span></span></span><br><span><var>œï</var><span class="hyp-type"><b>: </b><span>M1 -&gt; M2</span></span></span><br><span><var>morphism</var><span class="hyp-type"><b>: </b><span>Monoid_Morphism M1 M2 œï</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M1</span></span></span><br><span><var>monmor_src</var><span class="hyp-type"><b>: </b><span>Monoid M1</span></span></span><br><span><var>monmor_tgt</var><span class="hyp-type"><b>: </b><span>Monoid M2</span></span></span><br><span><var>monmor_unit</var><span class="hyp-type"><b>: </b><span>œï ∆µ = ∆µ</span></span></span><br><span><var>monmor_op</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : M1,
œï (a1 ‚óè a2) = œï a1 ‚óè œï a2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse (const œï <span class="kt">False</span> ‚àò f) =
foldMap (const œï (T <span class="kt">False</span>) ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factorizing through &lt;&lt;runBatch&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Coalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk78"><span class="kn">Lemma</span> <span class="nf">foldMap_through_runBatch1</span>
      `{ToBatch T}
      `{! Compat_ToBatch_Traverse T}
      {A: <span class="kt">Type</span>} `{Monoid M}: <span class="kr">forall</span> `(f: A -&gt; M),
      foldMap f = runBatch (G := const M) f (B := <span class="kt">False</span>) ‚àò
                    toBatch (A := A) (A&#39; := <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; M, foldMap f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A -&gt; M, foldMap f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7b"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7c"><span class="nb">rewrite</span> traverse_through_runBatch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch f ‚àò toBatch = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7d"><span class="kn">Lemma</span> <span class="nf">foldMap_through_runBatch2</span>
      `{ToBatch T}
      `{! Compat_ToBatch_Traverse T}
      `{Monoid M}: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">fake</span>: <span class="kt">Type</span>) `(f: A -&gt; M),
      foldMap f = runBatch (G := const M) f (B := fake) ‚àò
                    toBatch (A&#39; := fake).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">fake</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">fake</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk7f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk80"><span class="nb">rewrite</span> foldMap_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk81"><span class="nb">change</span> (<span class="kr">fun</span> <span class="nv">_</span>: <span class="kt">Type</span> =&gt; M) <span class="kr">with</span> (const (A := <span class="kt">Type</span>) M).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk82"><span class="nb">rewrite</span> (traverse_const1 fake).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk83"><span class="nb">rewrite</span> (traverse_through_runBatch (G := const M)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch f ‚àò toBatch = runBatch f ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factorizing through &lt;&lt;toBatch&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk84"><span class="kn">Lemma</span> <span class="nf">foldMap_through_toBatch</span>
      `{ToBatch T}
      `{! Compat_ToBatch_Traverse T}
      `{Monoid M}: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">fake</span>: <span class="kt">Type</span>) `(f: A -&gt; M) (t: T A),
      foldMap f t = foldMap f (toBatch (A&#39; := fake) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">fake</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M) (<span class="nv">t</span> : T A),
foldMap f t = foldMap f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk85"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">fake</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M) (<span class="nv">t</span> : T A),
foldMap f t = foldMap f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk86"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f t = foldMap f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk87"><span class="nb">rewrite</span> (foldMap_through_runBatch2 A fake).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch f ‚àò toBatch) t = foldMap f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk88"><span class="nb">rewrite</span> runBatch_via_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map extract_Batch ‚àò traverse f ‚àò toBatch) t =
foldMap f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk89">unfold_ops @Map_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">t</span> : const M (Batch fake fake (T fake)) =&gt; t)
 ‚àò traverse f ‚àò toBatch) t = foldMap f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8a"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (toBatch t) = foldMap f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8b"><span class="nb">rewrite</span> (foldMap_to_traverse2 fake).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse f (toBatch t) = traverse f (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">foldMap</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * &lt;&lt;foldmap&gt;&gt; Corollary: &lt;&lt;tolist&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** Operation &lt;&lt;tolist&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Tolist_Traverse</span> `{Traverse T}: Tolist T :=
  <span class="kr">fun</span> <span class="nv">A</span> =&gt; foldMap (ret (T := list)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Compat_Tolist_Traverse</span>
  (<span class="nv">T</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  `{Tolist_inst: Tolist T}
  `{Traverse_inst: Traverse T}: <span class="kt">Prop</span> :=
  compat_tolist_traverse:
    Tolist_inst = @Tolist_Traverse T Traverse_inst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Compat_Tolist_Traverse_Self</span>
  `{Traverse_T: Traverse T}:
  @Compat_Tolist_Traverse T Tolist_Traverse Traverse_T
  := <span class="kp">ltac</span>:(<span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8c"><span class="kn">Lemma</span> <span class="nf">tolist_to_traverse</span>
  `{Tolist_inst: Tolist T}
  `{Traverse_T: Traverse T}
  `{! Compat_Tolist_Traverse T}:
  <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
    tolist = foldMap (ret (T := list) (A := A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Tolist_inst</var><span class="hyp-type"><b>: </b><span>Tolist T</span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_Tolist_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Tolist_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Tolist_inst</var><span class="hyp-type"><b>: </b><span>Tolist T</span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_Tolist_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Tolist_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Tolist_inst</var><span class="hyp-type"><b>: </b><span>Tolist T</span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_Tolist_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Tolist_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk8f"><span class="nb">rewrite</span> compat_tolist_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Tolist_inst</var><span class="hyp-type"><b>: </b><span>Tolist T</span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_Tolist_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Tolist_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tolist_Traverse A = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Relating &lt;&lt;foldMap (T := list)&gt;&gt; to &lt;&lt;foldMap_list&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk90"><span class="kn">Lemma</span> <span class="nf">foldMap_eq_foldMap_list</span> `{Monoid M}: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; M),
    foldMap (T := list) f = foldMap_list f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = foldMap_list f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk91"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = foldMap_list f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk92"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = foldMap_list f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk93">ext l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f l = foldMap_list f l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk94"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f nil = foldMap_list f nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk95" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap f l = foldMap_list f l</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk95"><hr></label><div class="goal-conclusion">foldMap f (a :: l) = foldMap_list f (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk96">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f nil = foldMap_list f nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk97"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure nil = ∆µ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk98">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap f l = foldMap_list f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f (a :: l) = foldMap_list f (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk99"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap f l = foldMap_list f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure cons ‚óè f a) ‚óè foldMap f l =
f a ‚óè crush_list (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9a"><span class="nb">change</span> (monoid_op <span class="nl">?x</span> <span class="nl">?y</span>) <span class="kr">with</span> (x ‚óè y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap f l = foldMap_list f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure cons ‚óè f a) ‚óè foldMap f l =
f a ‚óè crush_list (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9b">unfold_ops @Pure_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap f l = foldMap_list f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(∆µ ‚óè f a) ‚óè foldMap f l = f a ‚óè crush_list (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9c"><span class="nb">rewrite</span> monoid_id_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap f l = foldMap_list f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap f l = f a ‚óè crush_list (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9d"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap f l = foldMap_list f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f l = f a ‚óè crush_list (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The &lt;&lt;tolist&gt;&gt; operation provided by the traversability of</span>
<span class="sd">    &lt;&lt;list&gt;&gt; is the identity. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9e"><span class="kn">Lemma</span> <span class="nf">Tolist_list_id</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
    @tolist list (@Tolist_Traverse list Traverse_list) A = @id (list A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka1">unfold_ops @Tolist_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka2"><span class="nb">rewrite</span> foldMap_eq_foldMap_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka3"><span class="nb">rewrite</span> foldMap_list_ret_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">tolist</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{Map T}
    `{! Compat_Map_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Naturality *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka4">#[export] <span class="kn">Instance</span> <span class="nf">Natural_Tolist_Traverse</span>: Natural (@tolist T _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@tolist T Tolist_Traverse)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@tolist T Tolist_Traverse)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka6"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor T</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chka7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò tolist = tolist ‚àò map f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> DerivedInstances.Functor_TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò tolist = tolist ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkaa"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò tolist = tolist ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkab">unfold_ops @Tolist_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò foldMap ret = foldMap ret ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkac"><span class="nb">rewrite</span> (foldMap_morphism (list A) (list B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (map f ‚àò ret) = foldMap ret ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkad"><span class="nb">rewrite</span> foldMap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (map f ‚àò ret) = foldMap (ret ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkae"><span class="nb">rewrite</span> (natural (œï := @ret list _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (ret ‚àò map f) = foldMap (ret ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Rewriting &lt;&lt;tolist&gt;&gt; to &lt;&lt;traverse&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkaf"><span class="kn">Corollary</span> <span class="nf">tolist_to_foldMap</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
      tolist (F := T) = foldMap (ret (T := list) (A := A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb1"><span class="kn">Corollary</span> <span class="nf">tolist_to_traverse1</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
      tolist =
        traverse (G := const (list A)) (B := <span class="kt">False</span>) (ret (T := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = traverse ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tolist = traverse ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb3"><span class="kn">Corollary</span> <span class="nf">tolist_to_traverse2</span>: <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">fake</span>: <span class="kt">Type</span>),
      tolist =
        traverse (G := const (list A)) (B := fake) (ret (T := list)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">fake</span> : <span class="kt">Type</span>, tolist = traverse ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">fake</span> : <span class="kt">Type</span>, tolist = traverse ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist = traverse ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb6"><span class="nb">rewrite</span> tolist_to_traverse1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse ret = traverse ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb7"><span class="nb">rewrite</span> (traverse_const1 fake).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, fake</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse ret = traverse ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factoring &lt;&lt;tolist&gt;&gt; through &lt;&lt;runBatch&gt;&gt; and &lt;&lt;toBatch&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Coalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb8"><span class="kn">Corollary</span> <span class="nf">tolist_through_toBatch</span>
  `{ToBatch T}
  `{! Compat_ToBatch_Traverse T}
    {A: <span class="kt">Type</span>} (tag: <span class="kt">Type</span>) `(t: T A):
    tolist t = tolist (toBatch (A&#39; := tag) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist t = tolist (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkb9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist t = tolist (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkba"><span class="nb">rewrite</span> (tolist_to_foldMap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret t = tolist (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbb"><span class="nb">rewrite</span> (foldMap_through_toBatch A tag).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret (toBatch t) = tolist (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbc"><span class="kn">Corollary</span> <span class="nf">tolist_through_runBatch</span>
  `{ToBatch T}
  `{! Compat_ToBatch_Traverse T}
    {A: <span class="kt">Type</span>} (tag: <span class="kt">Type</span>) `(t: T A):
    tolist t =
      runBatch (G := const (list A))
        (ret (T := list): A -&gt; const (list A) tag)
        (B := tag) (toBatch (A&#39; := tag) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist t =
runBatch (ret : A -&gt; const (list A) tag) (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tolist t =
runBatch (ret : A -&gt; const (list A) tag) (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbe"><span class="nb">rewrite</span> (tolist_to_traverse2 A tag).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">traverse ret t = runBatch ret (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkbf"><span class="nb">rewrite</span> (traverse_through_runBatch (G := const (list A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(runBatch ret ‚àò toBatch) t = runBatch ret (toBatch t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factoring any &lt;&lt;foldMap&gt;&gt; through &lt;&lt;tolist&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc0"><span class="kn">Corollary</span> <span class="nf">foldMap_through_tolist</span>
    `{Monoid M}: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: A -&gt; M),
    foldMap (T := T) f = foldMap (T := list) f ‚àò tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = foldMap f ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; M),
foldMap f = foldMap f ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = foldMap f ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc3"><span class="nb">rewrite</span> tolist_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = foldMap f ‚àò foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc4"><span class="nb">rewrite</span> foldMap_eq_foldMap_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = foldMap_list f ‚àò foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc5"><span class="nb">rewrite</span> (foldMap_morphism (list A) M).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = foldMap (foldMap_list f ‚àò ret)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc6"><span class="nb">rewrite</span> foldMap_list_ret.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>unit0</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap f = foldMap f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">tolist</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * &lt;&lt;foldmap&gt;&gt; Corollary: &lt;&lt;tosubset&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>

<span class="sd">(** ** The &lt;&lt;tosubset&gt;&gt; Operation *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Instance</span> <span class="nf">ToSubset_Traverse</span> `{Traverse T}:
  ToSubset T :=
  <span class="kr">fun</span> <span class="nv">A</span> =&gt; foldMap (ret (T := subset)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Compatibility *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Compat_ToSubset_Traverse</span>
  (<span class="nv">T</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  `{ToSubset_inst: ToSubset T}
  `{Traverse_inst: Traverse T}: <span class="kt">Prop</span> :=
  compat_tosubset_traverse:
    ToSubset_inst = @ToSubset_Traverse T Traverse_inst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Compat_ToSubset_Traverse_Self</span>
  `{Traverse_T: Traverse T}:
  @Compat_ToSubset_Traverse T ToSubset_Traverse Traverse_T
  := <span class="kp">ltac</span>:(<span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc7"><span class="kn">Lemma</span> <span class="nf">tosubset_to_traverse</span>
  `{ToSubset_inst: ToSubset T}
  `{Traverse_inst: Traverse T}
  `{! Compat_ToSubset_Traverse T}:
  <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>), tosubset (A := A) = foldMap (ret (T := subset)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Traverse_inst</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Traverse_inst</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkc9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Traverse_inst</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkca"><span class="nb">rewrite</span> compat_tosubset_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Traverse_inst</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ToSubset_Traverse A = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">elements</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{Map T}
    `{ToSubset T}
    `{! Compat_Map_Traverse T}
    `{! Compat_ToSubset_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Naturality *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcb">#[export] <span class="kn">Instance</span> <span class="nf">Natural_Element_Traverse</span>:
    Natural (@tosubset T ToSubset_Traverse).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@tosubset T ToSubset_Traverse)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@tosubset T ToSubset_Traverse)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcd"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor T</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chkce"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò tosubset = tosubset ‚àò map f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkcf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> DerivedInstances.Functor_TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
map f ‚àò tosubset = tosubset ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd1"><span class="nb">intros</span> A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò tosubset = tosubset ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd2"><span class="nb">unfold</span> tosubset, ToSubset_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f ‚àò foldMap ret = foldMap ret ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd3"><span class="nb">rewrite</span> (foldMap_morphism (subset A) (subset B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (map f ‚àò ret) = foldMap ret ‚àò map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd4"><span class="nb">rewrite</span> foldMap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (map f ‚àò ret) = foldMap (ret ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd5"><span class="nb">rewrite</span> (natural (œï := @ret subset _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (ret ‚àò map f) = foldMap (ret ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Rewriting &lt;&lt;tosubset&gt;&gt; to &lt;&lt;foldMap&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd6"><span class="kn">Lemma</span> <span class="nf">tosubset_to_foldMap</span> `{Compat_ToSubset_Traverse T}:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
      @tosubset T _ A =
        foldMap (ret (T := subset)) (A := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Traverse_inst</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Traverse_inst</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd8"><span class="nb">rewrite</span> compat_tosubset_traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>ToSubset_inst</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Traverse_inst</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, ToSubset_Traverse A = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factoring &lt;&lt;tosubset&gt;&gt; through &lt;&lt;tolist&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkd9"><span class="kn">Corollary</span> <span class="nf">tosubset_through_tolist</span>: <span class="kr">forall</span> <span class="nv">A</span>:<span class="kt">Type</span>,
      tosubset (F := T) (A := A) =
        tosubset (F := list) ‚àò tolist (A := A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = tosubset ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkda"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = tosubset ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset = tosubset ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdc"><span class="nb">rewrite</span> tosubset_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret = tosubset ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdd"><span class="nb">rewrite</span> foldMap_through_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret ‚àò tolist = tosubset ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkde">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap ret ‚àò tolist) t = (tosubset ‚àò tolist) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkdf"><span class="nb">unfold</span> compose; <span class="nb">induction</span> (tolist t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret nil = tosubset nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chke0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap ret l = tosubset l</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chke0"><hr></label><div class="goal-conclusion">foldMap ret (a :: l) = tosubset (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret nil = tosubset nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap ret l = tosubset l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret (a :: l) = tosubset (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap ret l = tosubset l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure cons ‚óè ret a) ‚óè foldMap ret l =
tosubset (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke4"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap ret l = tosubset l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pure cons ‚óè ret a) ‚óè tosubset l = tosubset (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke5"><span class="nb">unfold</span> transparent tcs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap ret l = tosubset l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ ‚à™ (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; a = b) ‚à™ (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; List.In a l) =
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; List.In a0 (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> simpl_subset.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Rewriting &lt;&lt;a ‚àà t&gt;&gt; to &lt;&lt;foldMap&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke6"><span class="kn">Lemma</span> <span class="nf">element_of_to_foldMap</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">a</span>: A),
      element_of a =
        foldMap (op := Monoid_op_or)
          (unit := Monoid_unit_false) {{a}}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
element_of a = foldMap {{a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
element_of a = foldMap {{a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">element_of a = foldMap {{a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chke9"><span class="nb">unfold</span> element_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">t</span> : T A =&gt; tosubset t a) = foldMap {{a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkea"><span class="nb">rewrite</span> tosubset_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">t</span> : T A =&gt; foldMap ret t a) = foldMap {{a}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkeb">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret t a = foldMap {{a}} t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkec">change_left (evalAt a (foldMap (ret (T := subset)) t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evalAt a (foldMap ret t) = foldMap {{a}} t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chked">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt a ‚àò foldMap ret) t = foldMap {{a}} t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkee"><span class="nb">rewrite</span> (foldMap_morphism
               (subset A) <span class="kt">Prop</span> (œï := evalAt a)
               (ret (T := subset))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (evalAt a ‚àò ret) t = foldMap {{a}} t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkef">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">evalAt a ‚àò ret = {{a}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf0">ext b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(evalAt a ‚àò ret) b = {{a}} b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf1"><span class="nb">cbv</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(b = a) = (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> propext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factoring &lt;&lt;a ‚àà t&gt;&gt; through &lt;&lt;tolist&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf2"><span class="kn">Corollary</span> <span class="nf">element_of_through_tolist</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">a</span>: A),
      element_of (F := T) a =
        element_of (F := list) a ‚àò tolist (F := T).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
element_of a = element_of a ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A),
element_of a = element_of a ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">element_of a = element_of a ‚àò tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf5">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ‚àà t = (element_of a ‚àò tolist) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf6"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ‚àà t = a ‚àà tolist t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf7"><span class="nb">unfold</span> element_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset t a = tosubset (tolist t) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf8"><span class="nb">rewrite</span> tosubset_through_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(tosubset ‚àò tolist) t a = tosubset (tolist t) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkf9"><span class="kn">Corollary</span> <span class="nf">in_iff_in_tolist</span>:
    <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">a</span>: A) (<span class="nv">t</span>: T A),
      a ‚àà t &lt;-&gt; a ‚àà tolist t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : T A),
a ‚àà t &lt;-&gt; a ‚àà tolist t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span> : A) (<span class="nv">t</span> : T A),
a ‚àà t &lt;-&gt; a ‚àà tolist t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ‚àà t &lt;-&gt; a ‚àà tolist t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> element_of_through_tolist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Factoring &lt;&lt;tosubset&gt;&gt; through &lt;&lt;runBatch&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Coalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> KleisliToCoalgebraic.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfc"><span class="kn">Lemma</span> <span class="nf">tosubset_through_runBatch1</span>
    `{ToBatch T}
    `{! Compat_ToBatch_Traverse T}
  : <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>),
      tosubset =
        runBatch (G := const (A -&gt; <span class="kt">Prop</span>))
          (ret (T := subset) (A := A)) (B := <span class="kt">False</span>) ‚àò
          toBatch (A&#39; := <span class="kt">False</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, tosubset = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkfe"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chkff"><span class="nb">rewrite</span> tosubset_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk100"><span class="nb">rewrite</span> foldMap_through_runBatch1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch ret ‚àò toBatch = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk101"><span class="kn">Lemma</span> <span class="nf">tosubset_through_runBatch2</span>
    `{ToBatch T}
    `{! Compat_ToBatch_Traverse T}
  : <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">tag</span>: <span class="kt">Type</span>),
      tosubset =
        runBatch (G := const (A -&gt; <span class="kt">Prop</span>))
          (ret (T := subset)) (B := tag) ‚àò
          toBatch (A&#39; := tag).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">tag</span> : <span class="kt">Type</span>, tosubset = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk102"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">tag</span> : <span class="kt">Type</span>, tosubset = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk103"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tosubset = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk104"><span class="nb">rewrite</span> tosubset_to_foldMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk105"><span class="nb">rewrite</span> (foldMap_through_runBatch2 A tag).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Kleisli.TraversableFunctor.TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ToBatch T</span></span></span><br><span><var>Compat_ToBatch_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToBatch_Traverse T</span></span></span><br><span><var>A, tag</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">runBatch ret ‚àò toBatch = runBatch ret ‚àò toBatch</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">elements</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk106">#[export] <span class="kn">Instance</span> <span class="nf">Compat_ToSubset_Tolist_Traverse</span>
  `{TraversableFunctor T}:
  @Compat_ToSubset_Tolist T
    (@ToSubset_Traverse T _)
    (@Tolist_Traverse T _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_ToSubset_Tolist T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk107"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Compat_ToSubset_Tolist T</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk108"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">@tosubset T ToSubset_Traverse =
@tosubset T ToSubset_Tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk109">unfold_ops @ToSubset_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; foldMap ret) =
@tosubset T ToSubset_Tolist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10a">unfold_ops @ToSubset_Tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; foldMap ret) =
(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; tosubset ‚àò tolist)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10b">unfold_ops @Tolist_Traverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; foldMap ret) =
(<span class="kr">fun</span> <span class="nv">A</span> : <span class="kt">Type</span> =&gt; tosubset ‚àò foldMap ret)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10c">ext A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret = tosubset ‚àò foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10d"><span class="nb">rewrite</span> (foldMap_morphism (list A) (subset A)
             (œï := @tosubset list ToSubset_list A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret = foldMap (tosubset ‚àò ret)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10e"><span class="nb">rewrite</span> tosubset_list_hom1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ret = foldMap ret</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * &lt;&lt;foldmap&gt;&gt; Corollary: &lt;&lt;Forall, Forany&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">quantification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{! ToSubset T}
    `{! Compat_ToSubset_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Operations &lt;&lt;Forall&gt;&gt; and &lt;&lt;Forany&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Forall</span> `(P: A -&gt; <span class="kt">Prop</span>): T A -&gt; <span class="kt">Prop</span> :=
    @foldMap T _ <span class="kt">Prop</span> Monoid_op_and Monoid_unit_true A P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Forany</span> `(P: A -&gt; <span class="kt">Prop</span>): T A -&gt; <span class="kt">Prop</span> :=
    @foldMap T _ <span class="kt">Prop</span> Monoid_op_or Monoid_unit_false A P.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Specification via &lt;&lt;element_of&gt;&gt; *)</span>
  <span class="sd">(********************************************************************)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk10f"><span class="kn">Lemma</span> <span class="nf">forall_iff</span> `(P: A -&gt; <span class="kt">Prop</span>) (t: T A):
    Forall P t &lt;-&gt; <span class="kr">forall</span> (<span class="nv">a</span>: A), a ‚àà t -&gt; P a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall P t &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk110"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall P t &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk111"><span class="nb">unfold</span> Forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap P t &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk112"><span class="nb">rewrite</span> foldMap_through_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap P ‚àò tolist) t &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk113"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap P (tolist t) &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà t -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk114"><span class="nb">setoid_rewrite</span> in_iff_in_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap P (tolist t) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà tolist t -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk115"><span class="nb">rewrite</span> foldMap_eq_foldMap_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P (tolist t) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà tolist t -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk116"><span class="nb">induction</span> (tolist t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P nil &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà nil -&gt; P a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk117"><hr></label><div class="goal-conclusion">foldMap_list P (a :: l) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) -&gt; P a0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk118">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P nil &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà nil -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk119">simpl_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà nil -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11a">unfold_ops @Monoid_unit_true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà nil -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11b">unfold_ops @Monoid_unit_subset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà nil -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11c"><span class="nb">setoid_rewrite</span> element_of_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span> : A, <span class="kt">False</span> -&gt; P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P (a :: l) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) -&gt; P a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11e">simpl_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ‚óè foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) -&gt; P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk11f">unfold_ops @Monoid_op_and.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a /\ foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) -&gt; P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk120">unfold_ops @Monoid_op_subset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a /\ foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) -&gt; P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk121">unfold_ops @Return_subset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a /\ foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) -&gt; P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk122"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a /\ (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) -&gt; P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk123"><span class="nb">setoid_rewrite</span> element_of_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a /\ (<span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a0</span> : A, a0 = a \/ a0 ‚àà l -&gt; P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk124"><span class="nb">firstorder</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>trf_traverse_id</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, traverse id = id</span></span></span><br><span><var>trf_traverse_traverse</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">Map_G</span> : Map G1)
  (<span class="nv">Pure_G</span> : Pure G1)
  (<span class="nv">Mult_G</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">Map_G0</span> : Map G2)
  (<span class="nv">Pure_G0</span> : Pure G2)
  (<span class="nv">Mult_G0</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  (<span class="nv">g</span> : B -&gt; G2 C)
  (<span class="nv">f</span> : A -&gt; G1 B),
map (traverse g) ‚àò traverse f =
traverse (g ‚ãÜ<span class="mi">2</span> f)</span></span></span><br><span><var>trf_traverse_morphism</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">H</span> : Map G1) (<span class="nv">H0</span> : Mult G1)
  (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2)
  (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">œï</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
       G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 œï -&gt;
<span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; G1 B),
œï (T B) ‚àò traverse f =
traverse (œï B ‚àò f)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a0 = a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>foldMap_list P l</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a ‚àà l -&gt; P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk125"><span class="kn">Lemma</span> <span class="nf">forany_iff</span> `(P: A -&gt; <span class="kt">Prop</span>) (t: T A):
    Forany P t &lt;-&gt; <span class="kr">exists</span> (<span class="nv">a</span>: A), a ‚àà t /\ P a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forany P t &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà t /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk126"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forany P t &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà t /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk127"><span class="nb">unfold</span> Forany.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap P t &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà t /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk128"><span class="nb">rewrite</span> foldMap_through_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap P ‚àò tolist) t &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà t /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk129"><span class="nb">rewrite</span> foldMap_eq_foldMap_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap_list P ‚àò tolist) t &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà t /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12a"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P (tolist t) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà t /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12b"><span class="nb">setoid_rewrite</span> in_iff_in_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P (tolist t) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà tolist t /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12c"><span class="nb">induction</span> (tolist t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P nil &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà nil /\ P a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk12d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk12d"><hr></label><div class="goal-conclusion">foldMap_list P (a :: l) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) /\ P a0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P nil &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà nil /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk12f"><span class="nb">rewrite</span> foldMap_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">∆µ &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà nil /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk130">unfold_ops @Monoid_unit_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà nil /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk131"><span class="nb">setoid_rewrite</span> element_of_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span> &lt;-&gt; (<span class="kr">exists</span> <span class="nv">a</span> : A, <span class="kt">False</span> /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk132">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list P (a :: l) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) /\ P a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk133">simpl_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ‚óè foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) /\ P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk134">unfold_ops @Monoid_op_or.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) /\ P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk135">unfold_ops @Monoid_op_subset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) /\ P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk136">unfold_ops @Return_subset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) /\ P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk137"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, a0 ‚àà (a :: l) /\ P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk138"><span class="nb">setoid_rewrite</span> element_of_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk139"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a) -&gt;
<span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk13a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk13a"><hr></label><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0) -&gt;
P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a) -&gt;
<span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13c"><span class="nb">intros</span> [hyp|hyp].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk13d"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk13f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk140">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">a0</span> : A, (a0 = a \/ a0 ‚àà l) /\ P a0) -&gt;
P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk141"><span class="nb">intros</span> [a&#39; [[hyp|hyp] rest]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>a&#39; = a</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>P a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk142" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>a&#39; ‚àà l</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>P a&#39;</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk142"><hr></label><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk143">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>a&#39; = a</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>P a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk144"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk145">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>a&#39; ‚àà l</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>P a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a \/ (<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk146"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>a&#39; ‚àà l</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>P a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk147"><span class="kr">exists</span> <span class="nv">a&#39;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>ToSubset0</var><span class="hyp-type"><b>: </b><span>ToSubset T</span></span></span><br><span><var>Compat_ToSubset_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_ToSubset_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list P l &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">a</span> : A, a ‚àà l /\ P a)</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>hyp</var><span class="hyp-type"><b>: </b><span>a&#39; ‚àà l</span></span></span><br><span><var>rest</var><span class="hyp-type"><b>: </b><span>P a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; ‚àà l /\ P a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">quantification</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * &lt;&lt;foldmap&gt;&gt; Corollary: &lt;&lt;plength&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span> Misc.NaturalNumbers.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plength</span> `{Traverse T}: <span class="kr">forall</span> {<span class="nv">A</span>}, T A -&gt; nat :=
  <span class="kr">fun</span> <span class="nv">A</span> =&gt; foldMap (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** &lt;&lt;plength&gt;&gt; of a &lt;&lt;list&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk148"><span class="kn">Lemma</span> <span class="nf">list_plength_length</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">l</span>: list A),
    plength l = length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A), plength l = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk149"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A), plength l = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength l = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14b"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength nil = length nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk14c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>plength l = length l</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk14c"><hr></label><div class="goal-conclusion">plength (a :: l) = length (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength nil = length nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>plength l = length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength (a :: l) = length (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk14f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>plength l = length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (plength l) = S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Factoring &lt;&lt;plength&gt;&gt; through &lt;&lt;list&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk150"><span class="kn">Lemma</span> <span class="nf">plength_through_tolist</span> `{TraversableFunctor T}:
  <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">t</span>: T A),
    plength t = length (tolist t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
plength t = length (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk151"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">t</span> : T A),
plength t = length (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk152"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength t = length (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk153"><span class="nb">unfold</span> plength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t = length (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk154"><span class="nb">rewrite</span> foldMap_through_tolist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) ‚àò tolist) t =
length (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk155"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (tolist t) =
length (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk156"><span class="nb">rewrite</span> &lt;- list_plength_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) (tolist t) =
plength (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Naturality of &lt;&lt;plength&gt;&gt; *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Import</span>
  Classes.Categorical.ShapelyFunctor (shape, shape_map).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">naturality_plength</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{TraversableFunctor T}
    `{Map T}
    `{! Compat_Map_Traverse T}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk157"><span class="kn">Lemma</span> <span class="nf">natural_plength</span>
    {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}:
    <span class="kr">forall</span> (<span class="nv">f</span>: A -&gt; B) (<span class="nv">t</span>: T A),
      plength (map f t) = plength t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : T A),
plength (map f t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk158"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : T A),
plength (map f t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk159"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength (map f t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15a">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(plength ‚àò map f) t = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15b"><span class="nb">unfold</span> plength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap (<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; <span class="mi">1</span>) ‚àò map f) t =
foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15c"><span class="nb">rewrite</span> (foldMap_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap ((<span class="kr">fun</span> <span class="nv">_</span> : B =&gt; <span class="mi">1</span>) ‚àò f) t =
foldMap (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; <span class="mi">1</span>) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15d"><span class="kn">Corollary</span> <span class="nf">plength_shape</span>
    {<span class="nv">A</span>: <span class="kt">Type</span>}:
    <span class="kr">forall</span> (<span class="nv">t</span>: T A),
      plength (shape t) = plength t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A, plength (shape t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : T A, plength (shape t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk15f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength (shape t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk160"><span class="nb">unfold</span> shape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength (map (const tt) t) = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk161"><span class="nb">rewrite</span> natural_plength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength t = plength t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk162"><span class="kn">Corollary</span> <span class="nf">same_shape_implies_plength</span>
    {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}:
    <span class="kr">forall</span> (<span class="nv">t</span>: T A) (<span class="nv">u</span>: T B),
      shape t = shape u -&gt;
      plength t = plength u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">u</span> : T B),
shape t = shape u -&gt; plength t = plength u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk163"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : T A) (<span class="nv">u</span> : T B),
shape t = shape u -&gt; plength t = plength u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk164">introv Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength t = plength u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk165"><span class="nb">rewrite</span> &lt;- plength_shape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength (shape t) = plength u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk166"><span class="nb">rewrite</span> &lt;- (plength_shape u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength (shape t) = plength (shape u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk167"><span class="nb">rewrite</span> Hshape.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Map T</span></span></span><br><span><var>Compat_Map_Traverse0</var><span class="hyp-type"><b>: </b><span>Compat_Map_Traverse T</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>T B</span></span></span><br><span><var>Hshape</var><span class="hyp-type"><b>: </b><span>shape t = shape u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plength (shape u) = plength (shape u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">naturality_plength</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * &lt;&lt;foldMap&gt;&gt; by a Commutative Monoid *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">foldMap_commutative_monoid</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Arguments</span> foldMap {T}%function_scope {H} {M}%type_scope
    (op) {unit} {A}%type_scope f%function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk168"><span class="kn">Lemma</span> <span class="nf">foldMap_opposite_list</span>
    `{unit: Monoid_unit M}
    `{op: Monoid_op M}
    `{! Monoid M} {A}: <span class="kr">forall</span> (<span class="nv">f</span>: A -&gt; M) (<span class="nv">l</span>: list A),
      foldMap op f l = foldMap (Monoid_op_Opposite op) f (List.rev l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">l</span> : list A),
foldMap op f l =
foldMap (Monoid_op_Opposite op) f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk169"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">l</span> : list A),
foldMap op f l =
foldMap (Monoid_op_Opposite op) f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk16a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f l =
foldMap (Monoid_op_Opposite op) f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk16b"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> foldMap_eq_foldMap_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f l = foldMap_list f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk16c"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f [] = foldMap_list f (List.rev [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk16d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk16d"><hr></label><div class="goal-conclusion">foldMap_list f (a :: l) =
foldMap_list f (List.rev (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk16e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f [] = foldMap_list f (List.rev [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk16f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f (a :: l) =
foldMap_list f (List.rev (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk170"><span class="nb">rewrite</span> foldMap_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f l =
foldMap_list f (List.rev (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk171"><span class="nb">change</span> (List.rev (a :: l)) <span class="kr">with</span> (List.rev l ++ [a]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f l =
foldMap_list f (List.rev l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk172"><span class="nb">rewrite</span> foldMap_list_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f l =
foldMap_list f (List.rev l) ‚óè foldMap_list f [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk173"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f (List.rev l) =
foldMap_list f (List.rev l) ‚óè foldMap_list f [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk174">unfold_ops @Monoid_op_Opposite.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f (List.rev l) =
foldMap_list f [a] ‚óè foldMap_list f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk175"><span class="nb">rewrite</span> foldMap_list_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap_list f l = foldMap_list f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f (List.rev l) =
f a ‚óè foldMap_list f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk176"><span class="kn">Lemma</span> <span class="nf">foldMap_comm_list</span>
    `{unit: Monoid_unit M}
    `{op: Monoid_op M}
    `{! Monoid M}
    {A: <span class="kt">Type</span>}
    `{comm: ! CommutativeMonoidOp op}
  : <span class="kr">forall</span> (<span class="nv">f</span>: A -&gt; M) (<span class="nv">l</span>: list A),
      foldMap op f l = foldMap op f (List.rev l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">l</span> : list A),
foldMap op f l = foldMap op f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk177"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">l</span> : list A),
foldMap op f l = foldMap op f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk178"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f l = foldMap op f (List.rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk179"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f [] = foldMap op f (List.rev [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="traversablefunctor-v-chk17a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><label class="goal-separator" for="traversablefunctor-v-chk17a"><hr></label><div class="goal-conclusion">foldMap op f (a :: l) =
foldMap op f (List.rev (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f [] = foldMap op f (List.rev [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f (a :: l) =
foldMap op f (List.rev (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17d"><span class="nb">rewrite</span> foldMap_eq_foldMap_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f (a :: l) =
foldMap_list f (List.rev (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17e"><span class="nb">rewrite</span> foldMap_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a ‚óè foldMap_list f l =
foldMap_list f (List.rev (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk17f"><span class="nb">rewrite</span> (comm_mon_swap (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f l ‚óè f a =
foldMap_list f (List.rev (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk180"><span class="nb">change</span> (List.rev (a :: l)) <span class="kr">with</span> (List.rev l ++ [a]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f l ‚óè f a =
foldMap_list f (List.rev l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk181"><span class="nb">rewrite</span> foldMap_list_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f l ‚óè f a =
foldMap_list f (List.rev l) ‚óè foldMap_list f [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk182"><span class="nb">rewrite</span> foldMap_list_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap_list f l ‚óè f a =
foldMap_list f (List.rev l) ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk183"><span class="nb">rewrite</span> &lt;- foldMap_eq_foldMap_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f l ‚óè f a = foldMap op f (List.rev l) ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk184"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldMap op f l = foldMap op f (List.rev l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f (List.rev l) ‚óè f a =
foldMap op f (List.rev l) ‚óè f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk185"><span class="kn">Lemma</span> <span class="nf">foldMap_comm</span>
    `{unit: Monoid_unit M}
    `{op: Monoid_op M}
    `{! Monoid M}
    `{comm: ! CommutativeMonoidOp op}
    `{TraversableFunctor T} {A: <span class="kt">Type</span>}:
    <span class="kr">forall</span> (<span class="nv">f</span>: A -&gt; M) (<span class="nv">t</span>: T A),
      foldMap op f t =
        foldMap (Monoid_op_Opposite op) f t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">t</span> : T A),
foldMap op f t = foldMap (Monoid_op_Opposite op) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk186"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : A -&gt; M) (<span class="nv">t</span> : T A),
foldMap op f t = foldMap (Monoid_op_Opposite op) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk187"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f t = foldMap (Monoid_op_Opposite op) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk188"><span class="nb">rewrite</span> (foldMap_through_tolist _ f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap op f ‚àò tolist) t =
foldMap (Monoid_op_Opposite op) f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk189"><span class="nb">rewrite</span> (foldMap_through_tolist (op := Monoid_op_Opposite op)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(foldMap op f ‚àò tolist) t =
(foldMap (Monoid_op_Opposite op) f ‚àò tolist) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk18a"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap op f (tolist t) =
foldMap (Monoid_op_Opposite op) f (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk18b"><span class="nb">rewrite</span> foldMap_opposite_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (Monoid_op_Opposite op) f
  (List.rev (tolist t)) =
foldMap (Monoid_op_Opposite op) f (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="traversablefunctor-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="traversablefunctor-v-chk18c"><span class="nb">rewrite</span> &lt;- foldMap_comm_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>Monoid_unit M</span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>Monoid_op M</span></span></span><br><span><var>Monoid0</var><span class="hyp-type"><b>: </b><span>Monoid M</span></span></span><br><span><var>comm</var><span class="hyp-type"><b>: </b><span>CommutativeMonoidOp op</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Traverse_T</var><span class="hyp-type"><b>: </b><span>Traverse T</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>TraversableFunctor T</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; M</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>T A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldMap (Monoid_op_Opposite op) f (tolist t) =
foldMap (Monoid_op_Opposite op) f (tolist t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">foldMap_commutative_monoid</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Notations *)</span>
<span class="sd">(**********************************************************************)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Notations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;f &lt;‚óª&gt; g&quot;</span> := (applicative_arrow_combine f g)
                          (<span class="kn">at level</span> <span class="mi">60</span>): tealeaves_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Notations</span>.</span></span></pre>
</div>
</div></body>
</html>
