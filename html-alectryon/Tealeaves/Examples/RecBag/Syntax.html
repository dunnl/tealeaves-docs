<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Syntax.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Classes.Categorical.ApplicativeCommutativeIdempotent
  Classes.Categorical.TraversableFunctor
  Classes.Kleisli.DecoratedTraversableCommIdemFunctor
  Classes.Kleisli.DecoratedTraversableMonadPoly
  Functors.List
  Backends.Common.Names
  Functors.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Product.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Monoid.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> DecoratedTraversableCommIdemFunctor.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Applicative.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span> Ï•.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dist_pair</span>
  {<span class="nv">b1</span> <span class="nv">v1</span>: <span class="kt">Type</span>}
  `{Map G} `{Mult G} `{Pure G}:
  list (G b1) * G v1 -&gt; G (list b1 * v1) :=
  <span class="kr">fun</span> &#39;(x, y) =&gt; pure (@pair (list b1) v1) &lt;â‹†&gt; dist list G x &lt;â‹†&gt; y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dec_bag</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>), list A -&gt; list (list A * A) :=
  <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">l</span> =&gt; map (pair l) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">lfg</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{ApplicativeCommutativeIdempotent G} (A: <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk0"><span class="kn">Lemma</span> <span class="nf">map_dist_pair_nil</span>: <span class="kr">forall</span> (<span class="nv">ctx</span>: list (G A)) (<span class="nv">l</span>: list (G A)),
      l = nil -&gt;
      dist list G (A := (list A) * A) (map (F := list) dist_pair (map (F := list) (pair ctx) l))
      = pure (F := G) (A := list (list A * A)) (@nil (list A * A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> <span class="nv">l</span> : list (G A),
l = [] -&gt;
dist list G (map dist_pair (map (pair ctx) l)) =
pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> <span class="nv">l</span> : list (G A),
l = [] -&gt;
dist list G (map dist_pair (map (pair ctx) l)) =
pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) l)) =
pure []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) [])) =
pure []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4"><span class="kn">Lemma</span> <span class="nf">map_dist_pair</span>: <span class="kr">forall</span> (<span class="nv">ctx</span>: list (G A)) (<span class="nv">l</span>: list (G A)),
      l &lt;&gt; nil -&gt;
      dist list G (A := (list A) * A) (map (F := list) dist_pair (map (F := list) (pair ctx) l))
      =
        pure (F := G) (<span class="kr">fun</span> <span class="nv">ctx</span> =&gt; map (F := list) (pair ctx))
          &lt;â‹†&gt; (dist list G ctx)
          &lt;â‹†&gt; dist list G l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> <span class="nv">l</span> : list (G A),
l &lt;&gt; [] -&gt;
dist list G (map dist_pair (map (pair ctx) l)) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> <span class="nv">l</span> : list (G A),
l &lt;&gt; [] -&gt;
dist list G (map dist_pair (map (pair ctx) l)) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) l)) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>[] &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) [])) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>g :: l &lt;&gt; []</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk8"><hr></label><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>[] &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) [])) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>g :: l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb"><span class="nb">clear</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc"><span class="nb">generalize dependent</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx, l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd"><span class="nb">induction</span> l; <span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) [g])) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [g]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><label class="goal-separator" for="syntax-v-chke"><hr></label><div class="goal-conclusion">dist list G
  (map dist_pair (map (pair ctx) (g :: a :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G (map dist_pair (map (pair ctx) [g])) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [g]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk10"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt;
pure [] =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk11"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure cons &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt; pure [] =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk12"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose cons) &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt; pure [] =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk13"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose cons) &lt;â‹†&gt; pure pair &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; pure [] =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk14"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose cons)) &lt;â‹†&gt; pure pair &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; pure [] =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk15"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose cons âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
pure [] =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk16"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt []) &lt;â‹†&gt;
(pure (compose cons âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk17"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt []) &lt;â‹†&gt;
(pure (compose cons âˆ˜ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk18"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt [])) &lt;â‹†&gt;
(pure (compose cons âˆ˜ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk19"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (evalAt [])) &lt;â‹†&gt;
pure (compose cons âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (evalAt []))) &lt;â‹†&gt;
pure (compose cons âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1c"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g) &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1e"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk1f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk20"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk21"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk22"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk23"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk24"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (evalAt []) &lt;â‹†&gt;
(pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt; g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk25"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt; pure (evalAt []) &lt;â‹†&gt;
(pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; pure cons) &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk26"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose (evalAt [])) &lt;â‹†&gt;
(pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; pure cons) &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk27"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt; pure (compose (evalAt [])) &lt;â‹†&gt;
(pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk28"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose (compose (evalAt []))) &lt;â‹†&gt;
(pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk29"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt; pure (compose (compose (evalAt []))) &lt;â‹†&gt;
pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose (compose (compose (evalAt [])))) &lt;â‹†&gt;
pure (compose âˆ˜ compose âˆ˜ (map â—‹ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure
  (compose (compose (evalAt []))
   âˆ˜ (compose âˆ˜ compose âˆ˜ (map â—‹ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2c"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose (compose (evalAt []))
    âˆ˜ (compose âˆ˜ compose âˆ˜ (map â—‹ pair))) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure compose &lt;â‹†&gt; pure (evalAt cons) &lt;â‹†&gt;
pure
  (compose (compose (evalAt []))
   âˆ˜ (compose âˆ˜ compose âˆ˜ (map â—‹ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure (compose (evalAt cons)) &lt;â‹†&gt;
pure
  (compose (compose (evalAt []))
   âˆ˜ (compose âˆ˜ compose âˆ˜ (map â—‹ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk2f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt []) âˆ˜ (compose cons âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g =
pure
  (evalAt cons
   âˆ˜ (compose (compose (evalAt []))
      âˆ˜ (compose âˆ˜ compose âˆ˜ (map â—‹ pair)))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk30">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G
  (map dist_pair (map (pair ctx) (g :: a :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk31"><span class="nb">rewrite</span> map_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G
  (map dist_pair ((ctx, g) :: map (pair ctx) (a :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk32"><span class="nb">rewrite</span> map_list_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist list G
  (dist_pair (ctx, g)
   :: map dist_pair (map (pair ctx) (a :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk33"><span class="nb">rewrite</span> dist_list_cons_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; dist_pair (ctx, g) &lt;â‹†&gt;
dist list G (map dist_pair (map (pair ctx) (a :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk34"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; dist_pair (ctx, g) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
 dist list G (a :: l)) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk35"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l)) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk36"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk37"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a) &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk38"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure compose &lt;â‹†&gt;
  (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
  (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx))) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk39"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3c"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g))) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3d"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g))) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3e"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
 (pure compose &lt;â‹†&gt;
  (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)))) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk3f"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g))) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk40"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose compose) &lt;â‹†&gt;
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g))) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk41"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose âˆ˜ compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g))) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk42"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
pure (compose âˆ˜ compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure compose &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk43"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose âˆ˜ compose (compose âˆ˜ compose))) &lt;â‹†&gt;
pure compose &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk44"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g)) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk45"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
pure (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk46"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose
     (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk47"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
   âˆ˜ cons) &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk48"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
pure
  (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
   âˆ˜ cons) &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk49"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose
     (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ cons)) &lt;â‹†&gt; (pure pair &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
g &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
pure
  (compose
     (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ cons)) &lt;â‹†&gt; pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose
     (compose
        (compose âˆ˜ compose (compose âˆ˜ compose)
         âˆ˜ compose âˆ˜ cons))) &lt;â‹†&gt; pure pair &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose
     (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4d"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose
      (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
 pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4e"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose
      (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
 pure (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk4f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt cons)) &lt;â‹†&gt;
(pure
   (compose
      (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
 pure (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk50"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (evalAt cons)) &lt;â‹†&gt;
(pure
   (compose
      (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk51"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (evalAt cons))) &lt;â‹†&gt;
(pure
   (compose
      (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk52"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
pure (compose (compose (evalAt cons))) &lt;â‹†&gt;
(pure
   (compose
      (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk53"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (compose (evalAt cons)))) &lt;â‹†&gt;
(pure
   (compose
      (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk54"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
pure (compose (compose (compose (evalAt cons)))) &lt;â‹†&gt;
pure
  (compose
     (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk55"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose (compose (compose (evalAt cons))))) &lt;â‹†&gt;
pure
  (compose
     (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ cons) âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk56"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose (compose (evalAt cons)))
   âˆ˜ (compose
        (compose âˆ˜ compose (compose âˆ˜ compose)
         âˆ˜ compose âˆ˜ cons) âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk57"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt (map â—‹ pair)) &lt;â‹†&gt;
(pure
   (compose (compose (compose (evalAt cons)))
    âˆ˜ (compose
         (compose âˆ˜ compose (compose âˆ˜ compose)
          âˆ˜ compose âˆ˜ cons) âˆ˜ pair)) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; g) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk58"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt (map â—‹ pair)) &lt;â‹†&gt;
(pure
   (compose (compose (compose (evalAt cons)))
    âˆ˜ (compose
         (compose âˆ˜ compose (compose âˆ˜ compose)
          âˆ˜ compose âˆ˜ cons) âˆ˜ pair)) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk59"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt (map â—‹ pair))) &lt;â‹†&gt;
(pure
   (compose (compose (compose (evalAt cons)))
    âˆ˜ (compose
         (compose âˆ˜ compose (compose âˆ˜ compose)
          âˆ˜ compose âˆ˜ cons) âˆ˜ pair)) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (evalAt (map â—‹ pair))) &lt;â‹†&gt;
pure
  (compose (compose (compose (evalAt cons)))
   âˆ˜ (compose
        (compose âˆ˜ compose (compose âˆ˜ compose)
         âˆ˜ compose âˆ˜ cons) âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (evalAt (map â—‹ pair)))) &lt;â‹†&gt;
pure
  (compose (compose (compose (evalAt cons)))
   âˆ˜ (compose
        (compose âˆ˜ compose (compose âˆ˜ compose)
         âˆ˜ compose âˆ˜ cons) âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (evalAt (map â—‹ pair))
   âˆ˜ (compose (compose (compose (evalAt cons)))
      âˆ˜ (compose
           (compose âˆ˜ compose (compose âˆ˜ compose)
            âˆ˜ compose âˆ˜ cons) âˆ˜ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5d"><span class="nb">rewrite</span> (ap_flip1 (G := G) (lhs := dist list G ctx) (rhs := g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map flip
  (pure
     (compose (evalAt (map â—‹ pair))
      âˆ˜ (compose (compose (compose (evalAt cons)))
         âˆ˜ (compose
              (compose âˆ˜ compose (compose âˆ˜ compose)
               âˆ˜ compose âˆ˜ cons) âˆ˜ pair)))) &lt;â‹†&gt; g &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5e"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (compose (evalAt (map â—‹ pair))
      âˆ˜ (compose (compose (compose (evalAt cons)))
         âˆ˜ (compose
              (compose âˆ˜ compose (compose âˆ˜ compose)
               âˆ˜ compose âˆ˜ cons) âˆ˜ pair)))) &lt;â‹†&gt; g &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk5f"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map double_input
  (pure
     (flip
        (compose (evalAt (map â—‹ pair))
         âˆ˜ (compose (compose (compose (evalAt cons)))
            âˆ˜ (compose
                 (compose
                  âˆ˜ compose (compose âˆ˜ compose)
                  âˆ˜ compose âˆ˜ cons) âˆ˜ pair)))) &lt;â‹†&gt; g) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk60"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose double_input)
  (pure
     (flip
        (compose (evalAt (map â—‹ pair))
         âˆ˜ (compose (compose (compose (evalAt cons)))
            âˆ˜ (compose
                 (compose
                  âˆ˜ compose (compose âˆ˜ compose)
                  âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt; g &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk61"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
   âˆ˜ flip
       (compose (evalAt (map â—‹ pair))
        âˆ˜ (compose (compose (compose (evalAt cons)))
           âˆ˜ (compose
                (compose âˆ˜ compose (compose âˆ˜ compose)
                 âˆ˜ compose âˆ˜ cons) âˆ˜ pair)))) &lt;â‹†&gt; g &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk62"><span class="nb">rewrite</span> (ap_flip1 (G := G) (B := list A) (A := A) (lhs := g) (rhs := dist list G ctx)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map flip
  (pure
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk63"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk64"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk65"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; g)) &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk66"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure compose &lt;â‹†&gt;
  (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
  (pure cons &lt;â‹†&gt; g))) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk67"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; g)) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk68"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; g)) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk69"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
 (pure cons &lt;â‹†&gt; g)) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6a"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6b"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; g) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6c"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt;
(pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
 (pure compose &lt;â‹†&gt;
  (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx))) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose compose) &lt;â‹†&gt;
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk6f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose âˆ˜ compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk70"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt;
pure (compose âˆ˜ compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure compose &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk71"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose (compose âˆ˜ compose (compose âˆ˜ compose))) &lt;â‹†&gt;
pure compose &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk72"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk73"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt;
pure (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk74"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure
  (compose
     (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose)) &lt;â‹†&gt;
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk75"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure
  (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
   âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk76"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
    âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
 g) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk77"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt; pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
    âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons) &lt;â‹†&gt;
g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk78"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose (evalAt cons)) &lt;â‹†&gt;
(pure
   (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
    âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons) &lt;â‹†&gt;
g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk79"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt; pure (compose (evalAt cons)) &lt;â‹†&gt;
(pure
   (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
    âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose (compose (evalAt cons))) &lt;â‹†&gt;
(pure
   (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
    âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7b"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt;
pure (compose (compose (evalAt cons))) &lt;â‹†&gt;
pure
  (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
   âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose (compose (compose (evalAt cons)))) &lt;â‹†&gt;
pure
  (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
   âˆ˜ (map â—‹ pair)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; pure cons &lt;â‹†&gt;
g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7d"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure
  (compose (compose (evalAt cons))
   âˆ˜ (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ (map â—‹ pair))) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
pure cons &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7e"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose (compose (evalAt cons))
    âˆ˜ (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
       âˆ˜ (map â—‹ pair))) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; g &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk7f"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure compose &lt;â‹†&gt; pure (evalAt cons) &lt;â‹†&gt;
pure
  (compose (compose (evalAt cons))
   âˆ˜ (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ (map â—‹ pair))) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk80"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure (compose (evalAt cons)) &lt;â‹†&gt;
pure
  (compose (compose (evalAt cons))
   âˆ˜ (compose âˆ˜ compose (compose âˆ˜ compose) âˆ˜ compose
      âˆ˜ (map â—‹ pair))) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk81"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : G A,
dist list G
  (map dist_pair (map (pair ctx) (g :: l))) =
pure (map â—‹ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G (g :: l)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
     (double_input
      âˆ˜ flip
          (compose (evalAt (map â—‹ pair))
           âˆ˜ (compose
                (compose (compose (evalAt cons)))
              âˆ˜ (compose
                   (compose
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ compose âˆ˜ cons) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l =
pure
  (evalAt cons
   âˆ˜ (compose (compose (evalAt cons))
      âˆ˜ (compose âˆ˜ compose (compose âˆ˜ compose)
         âˆ˜ compose âˆ˜ (map â—‹ pair)))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; g &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk82"><span class="kn">Lemma</span> <span class="nf">informative_list_nilb</span>: <span class="kr">forall</span> (<span class="nv">l</span>: list (G A)),
      {l = nil} + {l &lt;&gt; nil}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list (G A), {l = []} + {l &lt;&gt; []}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list (G A), {l = []} + {l &lt;&gt; []}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk84"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{l = []} + {l &lt;&gt; []}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk85"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[] = []} + {[] &lt;&gt; []}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk86"><hr></label><div class="goal-conclusion">{g :: l = []} + {g :: l &lt;&gt; []}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk87">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{[] = []} + {[] &lt;&gt; []}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk88">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{g :: l = []} + {g :: l &lt;&gt; []}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk89"><span class="kn">Lemma</span> <span class="nf">decorate_commute</span>: <span class="kr">forall</span> (<span class="nv">l</span>: list (G A)),
      map (dec_bag (A := A)) (dist list G l) =
        dist list G (map (F := list) dist_pair (dec_bag l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list (G A),
map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list (G A),
map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8c"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><label class="goal-separator" for="syntax-v-chk8d"><hr></label><div class="goal-conclusion">map (dec_bag (A:=A)) (dist list G (a :: l)) =
dist list G (map dist_pair (dec_bag (a :: l)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk8f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec_bag (A:=A)) (pure []) = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk90"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (dec_bag []) = pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec_bag (A:=A)) (dist list G (a :: l)) =
dist list G (map dist_pair (dec_bag (a :: l)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk92"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (dec_bag (A:=A))
  (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) =
pure cons &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt;
 a) &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk93"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (dec_bag (A:=A))) (pure cons &lt;â‹†&gt; a) &lt;â‹†&gt;
dist list G l =
pure cons &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt;
 a) &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk94"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (dec_bag (A:=A)))) (pure cons) &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l =
pure cons &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt;
 a) &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk95"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure cons &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt;
 a) &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk96"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure cons &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l)) &lt;â‹†&gt;
a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk97"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose cons) &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l)) &lt;â‹†&gt;
a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk98"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose cons) &lt;â‹†&gt; pure pair &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk99"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons)) &lt;â‹†&gt; pure pair &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose cons âˆ˜ pair) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9b"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose cons âˆ˜ pair) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a) &lt;â‹†&gt; dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9c"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons âˆ˜ pair)) &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a) &lt;â‹†&gt; dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9d"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose (compose cons âˆ˜ pair)) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9e"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose (compose cons âˆ˜ pair))) &lt;â‹†&gt;
pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chk9f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka0"><span class="nb">destruct</span> (informative_list_nilb l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>l = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="syntax-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><label class="goal-separator" for="syntax-v-chka1"><hr></label><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>l = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka3"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G [] =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G [] &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair [a]) []))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka4"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka5"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt []) &lt;â‹†&gt;
(pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a) =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka6"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt []) &lt;â‹†&gt;
pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt [])) &lt;â‹†&gt;
pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka8"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a &lt;â‹†&gt; pure []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chka9"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure (evalAt []) &lt;â‹†&gt;
(pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
 pure [] &lt;â‹†&gt; a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaa"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure compose &lt;â‹†&gt; pure (evalAt []) &lt;â‹†&gt;
(pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
 pure []) &lt;â‹†&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkab"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure (compose (evalAt [])) &lt;â‹†&gt;
(pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
 pure []) &lt;â‹†&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkac"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure compose &lt;â‹†&gt; pure (compose (evalAt [])) &lt;â‹†&gt;
(pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a) &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkad"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure (compose (compose (evalAt []))) &lt;â‹†&gt;
(pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a) &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkae"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure compose &lt;â‹†&gt; pure (compose (compose (evalAt []))) &lt;â‹†&gt;
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkaf"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure (compose (compose (compose (evalAt [])))) &lt;â‹†&gt;
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb0"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure
  (compose (compose (evalAt []))
   âˆ˜ (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt; a &lt;â‹†&gt;
pure [] &lt;â‹†&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb1"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure (evalAt []) &lt;â‹†&gt;
(pure
   (compose (compose (evalAt []))
    âˆ˜ (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt; a) &lt;â‹†&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb2"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure compose &lt;â‹†&gt; pure (evalAt []) &lt;â‹†&gt;
pure
  (compose (compose (evalAt []))
   âˆ˜ (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt; a &lt;â‹†&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb3"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure (compose (evalAt [])) &lt;â‹†&gt;
pure
  (compose (compose (evalAt []))
   âˆ˜ (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt; a &lt;â‹†&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb4"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure
  (evalAt []
   âˆ˜ (compose (compose (evalAt []))
      âˆ˜ (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt; a &lt;â‹†&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb5"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
map double_input
  (pure
     (evalAt []
      âˆ˜ (compose (compose (evalAt []))
         âˆ˜ (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb6"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G []) =
dist list G (map dist_pair (dec_bag []))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt [] âˆ˜ (compose (dec_bag (A:=A)) âˆ˜ cons)) &lt;â‹†&gt;
a =
pure
  (double_input
     (evalAt []
      âˆ˜ (compose (compose (evalAt []))
         âˆ˜ (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G (map dist_pair (map (pair (a :: l)) l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb8"><span class="nb">rewrite</span> map_dist_pair; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose cons âˆ˜ pair) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
 dist list G l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkb9"><span class="nb">rewrite</span> (ap_flip1 (A := A) (B := list A) (f := pure (compose (compose cons âˆ˜ pair) âˆ˜ cons))
                   (lhs := a) (rhs := dist list G l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map flip (pure (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; a &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
 dist list G l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkba"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; a &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
 dist list G l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbb"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map double_input
  (pure (flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
   dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
 dist list G l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbc"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map (compose double_input)
  (pure (flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
 dist list G l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbd"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (double_input
   âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
 dist list G l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbe"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt;
(pure (map â—‹ pair) &lt;â‹†&gt; dist list G (a :: l)) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkbf"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure
    (double_input
     âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
  dist list G l &lt;â‹†&gt; a)) &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G (a :: l) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc0"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G (a :: l) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc1"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G (a :: l) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc2"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G (a :: l) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc3"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G (a :: l) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc4"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; pure (map â—‹ pair) &lt;â‹†&gt;
dist list G (a :: l) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc5"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (evalAt (map â—‹ pair)) &lt;â‹†&gt;
(pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
 (pure
    (double_input
     âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
  dist list G l) &lt;â‹†&gt; a) &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc6"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (evalAt (map â—‹ pair)) &lt;â‹†&gt;
(pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
 (pure
    (double_input
     âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
  dist list G l)) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (evalAt (map â—‹ pair))) &lt;â‹†&gt;
(pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
 (pure
    (double_input
     âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
  dist list G l)) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc8"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose (evalAt (map â—‹ pair))) &lt;â‹†&gt;
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkc9"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose (evalAt (map â—‹ pair)))) &lt;â‹†&gt;
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkca"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (compose (evalAt (map â—‹ pair))
   âˆ˜ compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure
   (double_input
    âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcb"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt;
pure
  (compose (evalAt (map â—‹ pair))
   âˆ˜ compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure
  (double_input
   âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcc"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (compose
     (compose (evalAt (map â—‹ pair))
      âˆ˜ compose (compose âˆ˜ compose))) &lt;â‹†&gt;
pure
  (double_input
   âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcd"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (compose (evalAt (map â—‹ pair))
   âˆ˜ compose (compose âˆ˜ compose)
   âˆ˜ (double_input
      âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; dist list G (a :: l) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkce"><span class="nb">rewrite</span> dist_list_cons_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (compose (evalAt (map â—‹ pair))
   âˆ˜ compose (compose âˆ˜ compose)
   âˆ˜ (double_input
      âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt;
(pure cons &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkcf"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt;
(pure
   (compose (evalAt (map â—‹ pair))
    âˆ˜ compose (compose âˆ˜ compose)
    âˆ˜ (double_input
       âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; (pure cons &lt;â‹†&gt; a) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd0"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure
    (compose (evalAt (map â—‹ pair))
     âˆ˜ compose (compose âˆ˜ compose)
     âˆ˜ (double_input
        âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
  dist list G l &lt;â‹†&gt; a)) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd1"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure
   (compose (evalAt (map â—‹ pair))
    âˆ˜ compose (compose âˆ˜ compose)
    âˆ˜ (double_input
       âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd2"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure
   (compose (evalAt (map â—‹ pair))
    âˆ˜ compose (compose âˆ˜ compose)
    âˆ˜ (double_input
       âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd3"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure
   (compose (evalAt (map â—‹ pair))
    âˆ˜ compose (compose âˆ˜ compose)
    âˆ˜ (double_input
       âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd4"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure
   (compose (evalAt (map â—‹ pair))
    âˆ˜ compose (compose âˆ˜ compose)
    âˆ˜ (double_input
       âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd5"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure
   (compose (evalAt (map â—‹ pair))
    âˆ˜ compose (compose âˆ˜ compose)
    âˆ˜ (double_input
       âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd6"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure
  (compose (evalAt (map â—‹ pair))
   âˆ˜ compose (compose âˆ˜ compose)
   âˆ˜ (double_input
      âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose (compose âˆ˜ compose))) &lt;â‹†&gt;
pure
  (compose (evalAt (map â—‹ pair))
   âˆ˜ compose (compose âˆ˜ compose)
   âˆ˜ (double_input
      âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd8"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (evalAt (map â—‹ pair))
      âˆ˜ compose (compose âˆ˜ compose)
      âˆ˜ (double_input
         âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; pure cons &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkd9"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (evalAt (map â—‹ pair))
       âˆ˜ compose (compose âˆ˜ compose)
       âˆ˜ (double_input
          âˆ˜ flip
              (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
 dist list G l &lt;â‹†&gt; a) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkda"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (evalAt cons) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (evalAt (map â—‹ pair))
       âˆ˜ compose (compose âˆ˜ compose)
       âˆ˜ (double_input
          âˆ˜ flip
              (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdb"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (evalAt cons)) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (evalAt (map â—‹ pair))
       âˆ˜ compose (compose âˆ˜ compose)
       âˆ˜ (double_input
          âˆ˜ flip
              (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
 dist list G l) &lt;â‹†&gt; a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdc"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure compose &lt;â‹†&gt; pure (compose (evalAt cons)) &lt;â‹†&gt;
pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (evalAt (map â—‹ pair))
      âˆ˜ compose (compose âˆ˜ compose)
      âˆ˜ (double_input
         âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdd"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure (compose (compose (evalAt cons))) &lt;â‹†&gt;
pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (evalAt (map â—‹ pair))
      âˆ˜ compose (compose âˆ˜ compose)
      âˆ˜ (double_input
         âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons)))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkde"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (compose (evalAt cons)
   âˆ˜ (compose (compose âˆ˜ compose)
      âˆ˜ (compose (evalAt (map â—‹ pair))
         âˆ˜ compose (compose âˆ˜ compose)
         âˆ˜ (double_input
            âˆ˜ flip
                (compose (compose cons âˆ˜ pair) âˆ˜ cons))))) &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkdf"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map double_input
  (pure
     (compose (evalAt cons)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt (map â—‹ pair))
            âˆ˜ compose (compose âˆ˜ compose)
            âˆ˜ (double_input
               âˆ˜ flip
                   (compose (compose cons âˆ˜ pair)
                    âˆ˜ cons))))) &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
   a &lt;â‹†&gt; a) &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke0"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map (compose double_input)
  (pure
     (compose (evalAt cons)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt (map â—‹ pair))
            âˆ˜ compose (compose âˆ˜ compose)
            âˆ˜ (double_input
               âˆ˜ flip
                   (compose (compose cons âˆ˜ pair)
                    âˆ˜ cons))))) &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
   a) &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke1"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map (compose (compose double_input))
  (pure
     (compose (evalAt cons)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt (map â—‹ pair))
            âˆ˜ compose (compose âˆ˜ compose)
            âˆ˜ (double_input
               âˆ˜ flip
                   (compose (compose cons âˆ˜ pair)
                    âˆ˜ cons))))) &lt;â‹†&gt; dist list G l) &lt;â‹†&gt;
a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke2"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map (compose (compose (compose double_input)))
  (pure
     (compose (evalAt cons)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt (map â—‹ pair))
            âˆ˜ compose (compose âˆ˜ compose)
            âˆ˜ (double_input
               âˆ˜ flip
                   (compose (compose cons âˆ˜ pair)
                    âˆ˜ cons)))))) &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke3"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (compose (compose double_input)
   âˆ˜ (compose (evalAt cons)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt (map â—‹ pair))
            âˆ˜ compose (compose âˆ˜ compose)
            âˆ˜ (double_input
               âˆ˜ flip
                   (compose (compose cons âˆ˜ pair)
                    âˆ˜ cons)))))) &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
a &lt;â‹†&gt; a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke4"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map double_input
  (pure
     (compose (compose double_input)
      âˆ˜ (compose (evalAt cons)
         âˆ˜ (compose (compose âˆ˜ compose)
            âˆ˜ (compose (evalAt (map â—‹ pair))
               âˆ˜ compose (compose âˆ˜ compose)
               âˆ˜ (double_input
                  âˆ˜ flip
                      (compose (compose cons âˆ˜ pair)
                       âˆ˜ cons)))))) &lt;â‹†&gt; dist list G l) &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke5"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map (compose double_input)
  (pure
     (compose (compose double_input)
      âˆ˜ (compose (evalAt cons)
         âˆ˜ (compose (compose âˆ˜ compose)
            âˆ˜ (compose (evalAt (map â—‹ pair))
               âˆ˜ compose (compose âˆ˜ compose)
               âˆ˜ (double_input
                  âˆ˜ flip
                      (compose (compose cons âˆ˜ pair)
                       âˆ˜ cons))))))) &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke6"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (double_input
   âˆ˜ (compose (compose double_input)
      âˆ˜ (compose (evalAt cons)
         âˆ˜ (compose (compose âˆ˜ compose)
            âˆ˜ (compose (evalAt (map â—‹ pair))
               âˆ˜ compose (compose âˆ˜ compose)
               âˆ˜ (double_input
                  âˆ˜ flip
                      (compose (compose cons âˆ˜ pair)
                       âˆ˜ cons))))))) &lt;â‹†&gt; dist list G l &lt;â‹†&gt;
a &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke7"><span class="nb">rewrite</span> (ap_flip1 (G := G) (A := list A) (B := A)
                   (f := pure
                      (double_input
                         âˆ˜ (compose (compose double_input)
                              âˆ˜ (compose (evalAt cons)
                                   âˆ˜ (compose (compose âˆ˜ compose)
                                        âˆ˜ (compose (evalAt (map â—‹ pair)) âˆ˜ compose (compose âˆ˜ compose)
                                             âˆ˜ (double_input âˆ˜ flip (compose (compose cons âˆ˜ pair) âˆ˜ cons))))))))
                   (lhs := dist list G l) (rhs := a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map flip
  (pure
     (double_input
      âˆ˜ (compose (compose double_input)
         âˆ˜ (compose (evalAt cons)
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (evalAt (map â—‹ pair))
                  âˆ˜ compose (compose âˆ˜ compose)
                  âˆ˜ (double_input
                     âˆ˜ flip
                         (compose
                            (compose cons âˆ˜ pair)
                          âˆ˜ cons)))))))) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke8"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (flip
     (double_input
      âˆ˜ (compose (compose double_input)
         âˆ˜ (compose (evalAt cons)
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (evalAt (map â—‹ pair))
                  âˆ˜ compose (compose âˆ˜ compose)
                  âˆ˜ (double_input
                     âˆ˜ flip
                         (compose
                            (compose cons âˆ˜ pair)
                          âˆ˜ cons)))))))) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l &lt;â‹†&gt; dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chke9"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map double_input
  (pure
     (flip
        (double_input
         âˆ˜ (compose (compose double_input)
            âˆ˜ (compose (evalAt cons)
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt (map â—‹ pair))
                     âˆ˜ compose (compose âˆ˜ compose)
                     âˆ˜ (double_input
                        âˆ˜ flip
                            (compose
                               (compose cons âˆ˜ pair)
                             âˆ˜ cons)))))))) &lt;â‹†&gt; a) &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkea"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
map (compose double_input)
  (pure
     (flip
        (double_input
         âˆ˜ (compose (compose double_input)
            âˆ˜ (compose (evalAt cons)
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt (map â—‹ pair))
                     âˆ˜ compose (compose âˆ˜ compose)
                     âˆ˜ (double_input
                        âˆ˜ flip
                            (compose
                               (compose cons âˆ˜ pair)
                             âˆ˜ cons))))))))) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="syntax-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="syntax-v-chkeb"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (G A)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>map (dec_bag (A:=A)) (dist list G l) =
dist list G (map dist_pair (dec_bag l))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>l &lt;&gt; []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (dec_bag (A:=A)) âˆ˜ cons) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l =
pure
  (double_input
   âˆ˜ flip
       (double_input
        âˆ˜ (compose (compose double_input)
           âˆ˜ (compose (evalAt cons)
              âˆ˜ (compose (compose âˆ˜ compose)
                 âˆ˜ (compose (evalAt (map â—‹ pair))
                    âˆ˜ compose (compose âˆ˜ compose)
                    âˆ˜ (double_input
                       âˆ˜ flip
                           (compose
                              (compose cons âˆ˜ pair)
                            âˆ˜ cons)))))))) &lt;â‹†&gt; a &lt;â‹†&gt;
dist list G l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">lfg</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">mapci</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">mapci</span>.</span></span></pre>
</div>
</div></body>
</html>
