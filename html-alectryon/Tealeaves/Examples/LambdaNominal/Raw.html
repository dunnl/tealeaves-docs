<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Raw.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Examples.LambdaNominal.Syntax
  Functors.Subset
  Backends.Common.AtomSet
  Backends.Common.Names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> Coq.funind.Recdef.  <span class="c">(* Needed for Function *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Early.Subset.Notations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">fv</span> (<span class="nv">t</span>: term name name): subset name :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar v =&gt; {{ v }}
  | tap t1 t2 =&gt; fv t1 ‚à™ fv t2
  | lam b t =&gt; <span class="kr">fun</span> <span class="nv">v</span> =&gt; (fv t v) /\  (v &lt;&gt; b)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">remove</span> (<span class="nv">x</span>: name) (<span class="nv">l</span>: list name) : list name :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | nil =&gt; nil
  | cons y rest =&gt;
      <span class="kr">if</span> x == y <span class="kr">then</span> remove x rest <span class="kr">else</span> cons y (remove x rest)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">remove_all</span> (<span class="nv">xs</span>: list name) (<span class="nv">l</span>: list name) : list name :=
  <span class="kr">match</span> xs <span class="kr">with</span>
  | nil =&gt; l
  | cons y rest =&gt;
      remove_all rest (remove y l)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">fvL</span> (<span class="nv">t</span>: term name name): list name :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar v =&gt; [ v ]
  | tap t1 t2 =&gt; fvL t1 ++ fvL t2
  | lam b t =&gt; remove b (fvL t)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">l</span>: list name} {<span class="nv">x</span>: name} {<span class="nv">u</span>: term name name}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk0"><span class="kn">Lemma</span> <span class="nf">fvL_rw1</span>: <span class="kr">forall</span> <span class="nv">v</span>,
      fvL (tvar v) = [v].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : atom, fvL `v = [v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : atom, fvL `v = [v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fvL `v = [v]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk3"><span class="kn">Lemma</span> <span class="nf">fvL_rw2</span>: <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">t</span>,
      fvL (lam b t) =
        remove b (fvL t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : atom) (<span class="nv">t</span> : term atom atom),
fvL (<span class="kr">Œª</span><span class="nv">b</span>, t) = remove b (fvL t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : atom) (<span class="nv">t</span> : term atom atom),
fvL (<span class="kr">Œª</span><span class="nv">b</span>, t) = remove b (fvL t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk5"><span class="kn">Lemma</span> <span class="nf">fvL_rw3</span>: <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span>,
      fvL (tap t1 t2) = (fvL t1) ++ (fvL t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
fvL (t1¬∑t2) = fvL t1 ++ fvL t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
fvL (t1¬∑t2) = fvL t1 ++ fvL t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fvL (t1¬∑t2) = fvL t1 ++ fvL t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Depth function for well-founded recursion *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">depth</span> (<span class="nv">t</span> : term name name) : nat :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar _ =&gt; <span class="mi">0</span>
  | lam b t =&gt; S (depth t)
  | tap t1 t2 =&gt; S (max (depth t1) (depth t2))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Well-founded measure for lexicographic ordering *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">term_lt</span> (<span class="nv">t1</span> <span class="nv">t2</span>: term name name) : <span class="kt">Prop</span> := depth t1 &lt; depth t2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk8"><span class="kn">Lemma</span> <span class="nf">term_lt_wf</span> : well_founded term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded term_lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded term_lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : term atom atom, Acc term_lt a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb"><span class="nb">intro</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc"><span class="nb">induction</span> t; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt `v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><label class="goal-separator" for="raw-v-chkd"><hr></label><div class="goal-conclusion">Acc term_lt (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br></div><label class="goal-separator" for="raw-v-chke"><hr></label><div class="goal-conclusion">Acc term_lt (t1¬∑t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt `v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk10"><span class="nb">constructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>term_lt y `v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk12"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk13"><span class="nb">intro</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk14">introv H_u_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk15"><span class="nb">assert</span> (depth u &lt;= depth t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth u &lt;= depth t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br></div><label class="goal-separator" for="raw-v-chk16"><hr></label><div class="goal-conclusion">Acc term_lt u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk17">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth u &lt;= depth t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk18"><span class="nb">unfold</span> term_lt <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc (<span class="kr">fun</span> <span class="nv">t1</span> : term atom atom =&gt; lt (depth t1) ‚óã depth) t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>depth u &lt; depth (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth u &lt;= depth t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk19"><span class="nb">cbn</span> <span class="kr">in</span> H_u_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc (<span class="kr">fun</span> <span class="nv">t1</span> : term atom atom =&gt; lt (depth t1) ‚óã depth) t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>depth u &lt; S (depth t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth u &lt;= depth t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk1a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk1b"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y u -&gt; Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk1c">introv Hlt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>term_lt y u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk1d"><span class="nb">inversion</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>term_lt y u</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk1e"><span class="nb">apply</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>term_lt u (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>term_lt y u</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk1f"><span class="nb">unfold</span> term_lt <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Acc (<span class="kr">fun</span> <span class="nv">t1</span> : term atom atom =&gt; lt (depth t1) ‚óã depth) t</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H_u_lt</var><span class="hyp-type"><b>: </b><span>depth u &lt; depth (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; depth u</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
depth y &lt; depth t -&gt;
Acc
  (<span class="kr">fun</span> <span class="nv">t1</span> : term atom atom =&gt;
   lt (depth t1) ‚óã depth) y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth y &lt; depth t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk21"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk22">introv Hlt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>term_lt y (t1¬∑t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk23"><span class="nb">inversion</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>term_lt y (t1¬∑t2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk24"><span class="nb">inversion</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>term_lt y (t1¬∑t2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk25"><span class="nb">unfold</span> term_lt <span class="kr">in</span> Hlt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; depth (t1¬∑t2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk26"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; depth (t1¬∑t2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 y -&gt; Acc term_lt y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk27">introv Hlt&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; depth (t1¬∑t2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>term_lt y0 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk28"><span class="nb">unfold</span> term_lt <span class="kr">in</span> Hlt&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; depth (t1¬∑t2)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk29"><span class="nb">cbn</span> <span class="kr">in</span> Hlt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; S (Nat.max (depth t1) (depth t2))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk2a"><span class="nb">assert</span> (depth y0 &lt; depth t1 \/ depth y0 &lt; depth t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; S (Nat.max (depth t1) (depth t2))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth y0 &lt; depth t1 \/ depth y0 &lt; depth t2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; S (Nat.max (depth t1) (depth t2))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth t1 \/ depth y0 &lt; depth t2</span></span></span><br></div><label class="goal-separator" for="raw-v-chk2b"><hr></label><div class="goal-conclusion">Acc term_lt y0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk2c"><span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; S (Nat.max (depth t1) (depth t2))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth t1 \/ depth y0 &lt; depth t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk2d"><span class="nb">destruct</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; S (Nat.max (depth t1) (depth t2))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth t1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; S (Nat.max (depth t1) (depth t2))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth t2</span></span></span><br></div><label class="goal-separator" for="raw-v-chk2e"><hr></label><div class="goal-conclusion">Acc term_lt y0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk2f"><span class="nb">apply</span> H; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>Acc term_lt t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t2</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>depth y &lt; S (Nat.max (depth t1) (depth t2))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t1 -&gt; Acc term_lt y</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y t2 -&gt; Acc term_lt y</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hlt'</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>depth y0 &lt; depth t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H0; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk30"><span class="kn">Definition</span> <span class="nf">tap_Acc1</span>: <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span>,
    Acc term_lt (tap t1 t2) -&gt; Acc term_lt t1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
Acc term_lt (t1¬∑t2) -&gt; Acc term_lt t1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
Acc term_lt (t1¬∑t2) -&gt; Acc term_lt t1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk32"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt t1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk33"><span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt t1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk34"><span class="nb">apply</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t1 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk35"><span class="nb">unfold</span> term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk36"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 &lt; S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk37"><span class="kn">Definition</span> <span class="nf">tap_Acc2</span>: <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span>,
    Acc term_lt (tap t1 t2) -&gt; Acc term_lt t2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
Acc term_lt (t1¬∑t2) -&gt; Acc term_lt t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
Acc term_lt (t1¬∑t2) -&gt; Acc term_lt t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk39"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk3a"><span class="nb">inversion</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc term_lt t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk3b"><span class="nb">apply</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t2 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk3c"><span class="nb">unfold</span> term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t2 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk3d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Acc term_lt (t1¬∑t2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t2 &lt; S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk3e"><span class="kn">Definition</span> <span class="nf">tap_depth1</span>: <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span>,
    term_lt t1 (tap t1 t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom, term_lt t1 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom, term_lt t1 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk40"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t1 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk41"><span class="nb">unfold</span> term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk42"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 &lt; S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk43"><span class="kn">Definition</span> <span class="nf">tap_depth2</span>: <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span>,
    term_lt t2 (tap t1 t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom, term_lt t2 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom, term_lt t2 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk45"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t2 (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk46"><span class="nb">unfold</span> term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t2 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk47"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t2 &lt; S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk48"><span class="kn">Definition</span> <span class="nf">rename&#39;</span>:
  <span class="kr">forall</span> (<span class="nv">l</span>: list name) (<span class="nv">x</span> <span class="nv">y</span>: name) (<span class="nv">t</span>: term name name),
    Acc term_lt t -&gt; {u : term name name | depth u = depth t}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk4a"><span class="nb">refine</span> (<span class="kr">fix</span> <span class="nb">rename</span> l x y t (Ht: Acc term_lt t) {<span class="kr">struct</span> Ht} :=
    (<span class="kr">match</span> t <span class="kr">as</span> t&#39; <span class="kr">return</span> ((<span class="kr">forall</span> <span class="nv">x</span>, term_lt x t&#39; -&gt; term_lt x t) -&gt; {u : term name name | depth u = depth t&#39;}) <span class="kr">with</span>
    | tvar v =&gt;
        <span class="kr">fun</span> <span class="nv">phi</span> =&gt;
          <span class="kr">if</span> x == v
          <span class="kr">then</span> (@exist _ _ (tvar y) _)
          <span class="kr">else</span> (@exist _ _ (tvar v) _)
    | tap t1 t2 =&gt;
        <span class="kr">fun</span> <span class="nv">phi</span> =&gt;
        <span class="kr">match</span> (<span class="nb">rename</span> l x y t1 (Acc_inv Ht t1 (phi t1 (tap_depth1 t1 t2)))) <span class="kr">with</span>
        | exist _ t1&#39; pf1&#39; =&gt;
            <span class="kr">match</span> (<span class="nb">rename</span> l x y t2 (Acc_inv Ht t2 (phi t2 (tap_depth2 t1 t2)))) <span class="kr">with</span>
            | exist _ t2&#39; pf2&#39; =&gt;
                (@exist _ _ (tap t1&#39; t2&#39;) (_ pf1&#39; pf2&#39;))
            <span class="kr">end</span>
        <span class="kr">end</span>
    | lam b t&#39; =&gt;
        <span class="kr">fun</span> <span class="nv">phi</span> =&gt;
          <span class="kr">if</span> b == x <span class="kr">then</span> (@exist _ _ (lam b t&#39;) _)
          <span class="kr">else</span> <span class="kr">if</span> b == y <span class="kr">then</span>
                 <span class="kr">let</span> <span class="nv">z</span> := <span class="kp">fresh</span> ([x] ++ l ++ [b]) <span class="kr">in</span>
                 <span class="kr">match</span> (<span class="nb">rename</span> (l ++ [z]) b z t&#39; (Acc_inv Ht t&#39; _)) <span class="kr">with</span>
                 | exist _ tm pf =&gt;
                     <span class="kr">match</span> (<span class="nb">rename</span> (l ++ [z]) x y tm (Acc_inv Ht _)) <span class="kr">with</span>
                     | exist _ tm&#39; pf&#39; =&gt;
                         @exist _ _ (lam z tm&#39;) _
                     <span class="kr">end</span>
                 <span class="kr">end</span>
               <span class="kr">else</span>  <span class="kr">match</span> (<span class="nb">rename</span> l x y t&#39; ((Acc_inv Ht t&#39; _))) <span class="kr">with</span>
                     | exist _ tm pf =&gt;
                         (@exist _ _ (lam b tm) _)
                     <span class="kr">end</span>
     <span class="kr">end</span>) (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; y) ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x `v -&gt; term_lt x t</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth `y = depth `v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x `v -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chk4b"><hr></label><div class="goal-conclusion">depth `v = depth `v</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = x</span></span></span><br></div><label class="goal-separator" for="raw-v-chk4c"><hr></label><div class="goal-conclusion">depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br></div><label class="goal-separator" for="raw-v-chk4d"><hr></label><div class="goal-conclusion">term_lt t&#39; t</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><label class="goal-separator" for="raw-v-chk4e"><hr></label><div class="goal-conclusion">term_lt tm t</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br><span><var>tm'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf'</var><span class="hyp-type"><b>: </b><span>depth tm&#39; = depth tm</span></span></span><br></div><label class="goal-separator" for="raw-v-chk4f"><hr></label><div class="goal-conclusion">depth (<span class="kr">Œª</span><span class="nv">z</span>, tm&#39;) = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chk50"><hr></label><div class="goal-conclusion">term_lt t&#39; t</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><label class="goal-separator" for="raw-v-chk51"><hr></label><div class="goal-conclusion">depth (<span class="kr">Œª</span><span class="nv">b</span>, tm) = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (t1¬∑t2) -&gt; term_lt x t</span></span></span><br><span><var>t1'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf1'</var><span class="hyp-type"><b>: </b><span>depth t1&#39; = depth t1</span></span></span><br><span><var>t2'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf2'</var><span class="hyp-type"><b>: </b><span>depth t2&#39; = depth t2</span></span></span><br></div><label class="goal-separator" for="raw-v-chk52"><hr></label><div class="goal-conclusion">depth t1&#39; = depth t1 -&gt;
depth t2&#39; = depth t2 -&gt;
depth (t1&#39;¬∑t2&#39;) = depth (t1¬∑t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x `v -&gt; term_lt x t</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>x = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth `y = depth `v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x `v -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth `v = depth `v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk55">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t&#39; t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk57"><span class="nb">apply</span> phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t&#39; (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk58"><span class="nb">unfold</span> term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t&#39; &lt; depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk59"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t&#39; &lt; S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt tm t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk5b"><span class="nb">apply</span> phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt tm (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk5c"><span class="nb">unfold</span> term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth tm &lt; depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk5d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth tm &lt; S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk5e"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [y])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth tm &lt; S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br><span><var>tm'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf'</var><span class="hyp-type"><b>: </b><span>depth tm&#39; = depth tm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (<span class="kr">Œª</span><span class="nv">z</span>, tm&#39;) = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk60"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br><span><var>tm'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf'</var><span class="hyp-type"><b>: </b><span>depth tm&#39; = depth tm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (depth tm&#39;) = S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk61"><span class="nb">rewrite</span> pf&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br><span><var>tm'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf'</var><span class="hyp-type"><b>: </b><span>depth tm&#39; = depth tm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (depth tm) = S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk62"><span class="nb">rewrite</span> pf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br><span><var>z</var><span><span class="hyp-body"><b>:= </b><span><span class="kp">fresh</span> ([x] ++ l ++ [b])</span></span><span class="hyp-type"><b>: </b><span>atom</span></span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br><span><var>tm'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf'</var><span class="hyp-type"><b>: </b><span>depth tm&#39; = depth tm</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (depth t&#39;) = S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t&#39; t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk64"><span class="nb">apply</span> phi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term_lt t&#39; (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk65"><span class="nb">unfold</span> term_lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t&#39; &lt; depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk66"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t&#39; &lt; S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk67">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (<span class="kr">Œª</span><span class="nv">b</span>, tm) = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk68"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (depth tm) = S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk69"><span class="nb">rewrite</span> pf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt; term_lt x t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>tm</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>depth tm = depth t&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (depth t&#39;) = S (depth t&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk6a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (t1¬∑t2) -&gt; term_lt x t</span></span></span><br><span><var>t1'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf1'</var><span class="hyp-type"><b>: </b><span>depth t1&#39; = depth t1</span></span></span><br><span><var>t2'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf2'</var><span class="hyp-type"><b>: </b><span>depth t2&#39; = depth t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1&#39; = depth t1 -&gt;
depth t2&#39; = depth t2 -&gt;
depth (t1&#39;¬∑t2&#39;) = depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk6b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (t1¬∑t2) -&gt; term_lt x t</span></span></span><br><span><var>t1'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf1'</var><span class="hyp-type"><b>: </b><span>depth t1&#39; = depth t1</span></span></span><br><span><var>t2'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf2'</var><span class="hyp-type"><b>: </b><span>depth t2&#39; = depth t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1&#39; = depth t1 -&gt;
depth t2&#39; = depth t2 -&gt;
S (Nat.max (depth t1&#39;) (depth t2&#39;)) =
S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk6c"><span class="nb">rewrite</span> pf1&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (t1¬∑t2) -&gt; term_lt x t</span></span></span><br><span><var>t1'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf1'</var><span class="hyp-type"><b>: </b><span>depth t1&#39; = depth t1</span></span></span><br><span><var>t2'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf2'</var><span class="hyp-type"><b>: </b><span>depth t2&#39; = depth t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 = depth t1 -&gt;
depth t2&#39; = depth t2 -&gt;
S (Nat.max (depth t1) (depth t2&#39;)) =
S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk6d"><span class="nb">rewrite</span> pf2&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>rename</var><span class="hyp-type"><b>: </b><span>list atom -&gt;
atom -&gt;
atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term atom atom,
Acc term_lt t -&gt;
{u : term atom atom | depth u = depth t}</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
term_lt x (t1¬∑t2) -&gt; term_lt x t</span></span></span><br><span><var>t1'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf1'</var><span class="hyp-type"><b>: </b><span>depth t1&#39; = depth t1</span></span></span><br><span><var>t2'</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>pf2'</var><span class="hyp-type"><b>: </b><span>depth t2&#39; = depth t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 = depth t1 -&gt;
depth t2 = depth t2 -&gt;
S (Nat.max (depth t1) (depth t2)) =
S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rename</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span> := proj1_sig (rename&#39; l x y t (term_lt_wf t)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">l</span>: list name) (<span class="nv">x</span> <span class="nv">y</span>: name) (<span class="nv">t</span>: term name name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rename_iter</span>:
  <span class="kr">forall</span> (<span class="nv">l</span>: list name) (<span class="nv">x</span> <span class="nv">y</span>: name) (<span class="nv">t</span>: term name name), term name name :=
  <span class="kr">fun</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span> =&gt;
    <span class="kr">match</span> t <span class="kr">with</span>
    | tvar v =&gt;
        <span class="kr">if</span> x == v
        <span class="kr">then</span> tvar y
        <span class="kr">else</span> tvar v
    | tap t1 t2 =&gt;
        tap (<span class="nb">rename</span> l x y t1) (<span class="nb">rename</span> l x y t2)
    | lam b t&#39; =&gt;
        <span class="kr">if</span> b == x <span class="kr">then</span> lam b t&#39;
        <span class="kr">else</span> <span class="kr">if</span> b == y
             <span class="kr">then</span> <span class="kr">let</span> <span class="nv">z</span> := <span class="kp">fresh</span> ([x] ++ l ++ [b])
                  <span class="kr">in</span> lam z (<span class="nb">rename</span> (l ++ [z]) x y (<span class="nb">rename</span> (l ++ [z]) b z t&#39;))
             <span class="kr">else</span> lam b (<span class="nb">rename</span> l x y t&#39;)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ctx</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">l</span>: list name} {<span class="nv">x</span>: name} {<span class="nv">y</span>: name}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk6e"><span class="kn">Lemma</span> <span class="nf">test</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">P</span>: A -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span>: {a: A | P a}) (<span class="nv">y</span>: {a: A | P a}),
        proj1_sig x = proj1_sig y -&gt;
        x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>)
  (<span class="nv">x</span> <span class="nv">y</span> : {a : A | P a}),
proj1_sig x = proj1_sig y -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>)
  (<span class="nv">x</span> <span class="nv">y</span> : {a : A | P a}),
proj1_sig x = proj1_sig y -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk70"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>{a : A | P a}</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proj1_sig x0 = proj1_sig y0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x0 = y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk71"><span class="nb">destruct</span> x0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x0</span></span></span><br><span><var>y0</var><span class="hyp-type"><b>: </b><span>{a : A | P a}</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proj1_sig (exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x0 p) =
proj1_sig y0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x0 p = y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk72"><span class="nb">destruct</span> y0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x0</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proj1_sig (exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x0 p) =
proj1_sig (exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x1 p0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x0 p =
exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x1 p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk73"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x0</span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x0 p =
exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x1 p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk74"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p0</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x1 p =
exist (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; P a) x1 p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk75">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p, p0</var><span class="hyp-type"><b>: </b><span>P x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> proof_irrelevance.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk76"><span class="kn">Corollary</span> <span class="nf">rename_pf_irrel</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span> <span class="nv">HAcc1</span> <span class="nv">HAcc2</span>,
        rename&#39; l x y t HAcc1 =
          rename&#39; l x y t HAcc2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom) (<span class="nv">HAcc1</span> <span class="nv">HAcc2</span> : Acc term_lt t),
rename&#39; l x y t HAcc1 = rename&#39; l x y t HAcc2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom) (<span class="nv">HAcc1</span> <span class="nv">HAcc2</span> : Acc term_lt t),
rename&#39; l x y t HAcc1 = rename&#39; l x y t HAcc2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk78"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>HAcc1, HAcc2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename&#39; l0 x0 y0 t HAcc1 = rename&#39; l0 x0 y0 t HAcc2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk79"><span class="nb">assert</span> (HAcc1 = HAcc2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>HAcc1, HAcc2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HAcc1 = HAcc2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>HAcc1, HAcc2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>HAcc1 = HAcc2</span></span></span><br></div><label class="goal-separator" for="raw-v-chk7a"><hr></label><div class="goal-conclusion">rename&#39; l0 x0 y0 t HAcc1 = rename&#39; l0 x0 y0 t HAcc2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk7b"><span class="nb">apply</span> proof_irrelevance.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>HAcc1, HAcc2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>HAcc1 = HAcc2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename&#39; l0 x0 y0 t HAcc1 = rename&#39; l0 x0 y0 t HAcc2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk7c"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>HAcc1, HAcc2</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>HAcc1 = HAcc2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename&#39; l0 x0 y0 t HAcc2 = rename&#39; l0 x0 y0 t HAcc2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk7d"><span class="kn">Lemma</span> <span class="nf">normalize_rename&#39;</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span> <span class="nv">Hacc</span>,
        rename&#39; l x y t Hacc = rename&#39; l x y t (term_lt_wf t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom) (<span class="nv">Hacc</span> : Acc term_lt t),
rename&#39; l x y t Hacc = rename&#39; l x y t (term_lt_wf t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom) (<span class="nv">Hacc</span> : Acc term_lt t),
rename&#39; l x y t Hacc = rename&#39; l x y t (term_lt_wf t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk7f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hacc</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename&#39; l0 x0 y0 t Hacc =
rename&#39; l0 x0 y0 t (term_lt_wf t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk80"><span class="nb">erewrite</span> rename_pf_irrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hacc</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename&#39; l0 x0 y0 t <span class="nl">?HAcc2</span> =
rename&#39; l0 x0 y0 t (term_lt_wf t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk81"><span class="kn">Lemma</span> <span class="nf">normalize_rename1</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span> <span class="nv">Hacc</span>,
        proj1_sig (rename&#39; l x y t Hacc) = (<span class="nb">rename</span> l x y t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom) (<span class="nv">Hacc</span> : Acc term_lt t),
proj1_sig (rename&#39; l x y t Hacc) = <span class="nb">rename</span> l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom) (<span class="nv">Hacc</span> : Acc term_lt t),
proj1_sig (rename&#39; l x y t Hacc) = <span class="nb">rename</span> l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk83"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hacc</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l0 x0 y0 t Hacc) =
<span class="nb">rename</span> l0 x0 y0 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk84"><span class="nb">unfold</span> <span class="nb">rename</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hacc</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l0 x0 y0 t Hacc) =
proj1_sig (rename&#39; l0 x0 y0 t (term_lt_wf t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk85"><span class="nb">erewrite</span> rename_pf_irrel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x0, y0</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>Hacc</var><span class="hyp-type"><b>: </b><span>Acc term_lt t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l0 x0 y0 t <span class="nl">?HAcc2</span>) =
proj1_sig (rename&#39; l0 x0 y0 t (term_lt_wf t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ctx</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk86"><span class="kn">Lemma</span> <span class="nf">rename_eq_iter</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span>,
      <span class="nb">rename</span> l x y t = (rename_iter l x y t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom),
<span class="nb">rename</span> l x y t = rename_iter l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom),
<span class="nb">rename</span> l x y t = rename_iter l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk88"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y t = rename_iter l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk89"><span class="nb">generalize dependent</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list atom,
<span class="nb">rename</span> l x y t = rename_iter l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk8a"><span class="nb">generalize dependent</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t = rename_iter l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk8b"><span class="nb">generalize dependent</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t = rename_iter l x y t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk8c"><span class="nb">induction</span> t; <span class="nb">intros</span> y x l;
      <span class="nb">unfold</span> <span class="nb">rename</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (term_lt_wf `v)) =
rename_iter l x y `v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><label class="goal-separator" for="raw-v-chk8d"><hr></label><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">b</span>, t))) =
rename_iter l x y (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><label class="goal-separator" for="raw-v-chk8e"><hr></label><div class="goal-conclusion">proj1_sig (rename&#39; l x y (t1¬∑t2) (term_lt_wf (t1¬∑t2))) =
rename_iter l x y (t1¬∑t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk8f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (term_lt_wf `v)) =
rename_iter l x y `v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk90"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (term_lt_wf `v)) =
(<span class="kr">if</span> x == v <span class="kr">then</span> `y <span class="kr">else</span> `v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk91"><span class="nb">destruct</span> (term_lt_wf (tvar v)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (Acc_intro `v a)) =
(<span class="kr">if</span> x == v <span class="kr">then</span> `y <span class="kr">else</span> `v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk92">destruct_eq_args x v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>v = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l v y `v (Acc_intro `v a)) = `y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(v &lt;&gt; x)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chk93"><hr></label><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (Acc_intro `v a)) = `v</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk94">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>v = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l v y `v (Acc_intro `v a)) = `y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk95"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>v = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> v == v
   <span class="kr">then</span>
    exist (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = <span class="mi">0</span>) `y
      eq_refl
   <span class="kr">else</span>
    exist (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = <span class="mi">0</span>) `v
      eq_refl) = `y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args v v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk96">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(v &lt;&gt; x)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (Acc_intro `v a)) = `v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk97"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(v &lt;&gt; x)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> x == v
   <span class="kr">then</span>
    exist (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = <span class="mi">0</span>) `y
      eq_refl
   <span class="kr">else</span>
    exist (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = <span class="mi">0</span>) `v
      eq_refl) = `v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk98">destruct_eq_args v v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v, y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(v &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQ, DESTR_EQs</var><span class="hyp-type"><b>: </b><span>v = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> x == v
   <span class="kr">then</span>
    exist (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = <span class="mi">0</span>) `y
      eq_refl
   <span class="kr">else</span>
    exist (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = <span class="mi">0</span>) `v
      eq_refl) = `v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args x v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk99">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">b</span>, t))) =
rename_iter l x y (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk9a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">b</span>, t))) =
(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">if</span> b == y
  <span class="kr">then</span>
   <span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [b]), <span class="nb">rename</span>
                             (l ++
                              [<span class="kp">fresh</span> (x :: l ++ [b])])
                             x y
                             (<span class="nb">rename</span>
                                (l ++
                                 [<span class="kp">fresh</span>
                                    (x :: l ++ [b])])
                                b
                                (<span class="kp">fresh</span> (x :: l ++ [b]))
                                t)
  <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk9b">destruct_eq_args b x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">x</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">x</span>, t))) =
(<span class="kr">Œª</span><span class="nv">x</span>, t)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chk9c"><hr></label><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">b</span>, t))) =
(<span class="kr">if</span> b == y
 <span class="kr">then</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [b]), 
 <span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> (x :: l ++ [b])]) x y
   (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> (x :: l ++ [b])]) b
      (<span class="kp">fresh</span> (x :: l ++ [b])) t)
 <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk9d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">x</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">x</span>, t))) =
(<span class="kr">Œª</span><span class="nv">x</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk9e"><span class="nb">destruct</span> (term_lt_wf (lam x t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">x</span>, t) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">x</span>, t) (Acc_intro (<span class="kr">Œª</span><span class="nv">x</span>, t) a)) =
(<span class="kr">Œª</span><span class="nv">x</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk9f"><span class="nb">unfold</span> rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">x</span>, t) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  <span class="kr">match</span> x == x <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt;
      exist
        (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
         depth u = depth (<span class="kr">Œª</span><span class="nv">x</span>, t)) (<span class="kr">Œª</span><span class="nv">x</span>, t) eq_refl
  | <span class="nb">right</span> x0 =&gt;
      <span class="kr">match</span> x == y <span class="kr">with</span>
      | <span class="nb">left</span> x1 =&gt;
          <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
            (<span class="kr">fix</span> <span class="nb">rename</span>
               (l : list atom) (x y : atom)
               (t : term atom atom)
               (Ht : Acc term_lt t) {<span class="kr">struct</span> Ht} :
                 {u : term atom atom
                 | depth u = depth t} :=
               <span class="kr">match</span>
                 t <span class="kr">as</span> t&#39;
                 <span class="kr">return</span>
                   ((<span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                     term_lt x2 t&#39; -&gt; term_lt x2 t) -&gt;
                    {u : term atom atom
                    | depth u = depth t&#39;})
               <span class="kr">with</span>
               | tvar v =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                         term_lt x2 `v -&gt; term_lt x2 t
                   =&gt;
                   <span class="kr">if</span> x == v
                   <span class="kr">then</span>
                    exist
                      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                       depth u = depth `v) `y eq_refl
                   <span class="kr">else</span>
                    exist
                      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                       depth u = depth `v) `v eq_refl
               | lam b t&#39; =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">phi</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                           term_lt x2 (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt;
                           term_lt x2 t =&gt;
                   <span class="kr">match</span> b == x <span class="kr">with</span>
                   | <span class="nb">left</span> _ =&gt;
                       exist
                         (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                          depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                         (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) eq_refl
                   | <span class="nb">right</span> x2 =&gt;
                       <span class="kr">match</span> b == y <span class="kr">with</span>
                       | <span class="nb">left</span> x3 =&gt;
                           <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
                             <span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span> ([x] ++ ...)])
                               b
                               (<span class="kp">fresh</span>
                                  ([x] ++ l ++ [b]))
                               t&#39;
                               (Acc_inv Ht
                                  (phi t&#39; (...))) <span class="kr">in</span>
                           <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
                             <span class="nb">rename</span>
                               (l ++ [<span class="kp">fresh</span> (...)]) x
                               y tm
                               (Acc_inv Ht
                                  (phi tm ...)) <span class="kr">in</span>
                           exist
                             (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom
                              =&gt;
                              depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                             (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), tm&#39;)
                             (eq_ind_r
                                (<span class="kr">fun</span> ... =&gt; ... = ...)
                                (eq_ind_r (...)
                                   eq_refl pf) pf&#39;)
                       | <span class="nb">right</span> _ =&gt;
                           <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
                             <span class="nb">rename</span> l x y t&#39;
                               (Acc_inv Ht
                                  (phi t&#39; (...))) <span class="kr">in</span>
                           exist
                             (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom
                              =&gt;
                              depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                             (<span class="kr">Œª</span><span class="nv">b</span>, tm)
                             (eq_ind_r
                                (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                                 S n = S ...) eq_refl
                                pf)
                       <span class="kr">end</span>
                   <span class="kr">end</span>
               | tap t1 t2 =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">phi</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                           term_lt x2 (t1¬∑t2) -&gt;
                           term_lt x2 t =&gt;
                   <span class="kr">let</span> (<span class="nv">t1&#39;</span>, pf1&#39;) :=
                     <span class="nb">rename</span> l x y t1
                       (Acc_inv Ht
                          (phi t1 (tap_depth1 t1 t2))) <span class="kr">in</span>
                   <span class="kr">let</span> (<span class="nv">t2&#39;</span>, pf2&#39;) :=
                     <span class="nb">rename</span> l x y t2
                       (Acc_inv Ht
                          (phi t2 (tap_depth2 t1 t2))) <span class="kr">in</span>
                   exist
                     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                      depth u = depth (t1¬∑t2))
                     (t1&#39;¬∑t2&#39;)
                     (eq_ind_r
                        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                         n = depth t1 -&gt;
                         depth t2&#39; = depth t2 -&gt;
                         S (...) = S (...))
                        (eq_ind_r
                           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                            depth t1 = depth t1 -&gt;
                            n = ... -&gt; ... = ...)
                           (<span class="kr">fun</span> (<span class="nv">_</span> : ... = ...)
                              (<span class="nv">_</span> : ... = ...) =&gt;
                            eq_refl) pf2&#39;) pf1&#39; pf1&#39;
                        pf2&#39;)
               <span class="kr">end</span>
                 (<span class="kr">fun</span> (<span class="nv">x2</span> : term atom atom)
                    (<span class="nv">y0</span> : term_lt x2 t) =&gt; y0))
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [x])]) x
              (<span class="kp">fresh</span> ([x] ++ l ++ [x])) t
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">x</span>, t) a)
                 (ZifyClasses.rew_iff_rev
                    (depth t &lt; S (depth t))
                    (BinInt.Z.lt
                       (BinInt.Z.of_nat (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH)))
                    (ZifyClasses.mkrel nat BinNums.Z
                       lt BinInt.Z.of_nat BinInt.Z.lt
                       Znat.Nat2Z.inj_lt (depth t)
                       (BinInt.Z.of_nat (depth t))
                       eq_refl (S (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH))
                       (ZifyClasses.mkapp nat nat
                          BinNums.Z BinNums.Z S
                          BinInt.Z.of_nat
                          BinInt.Z.of_nat
                          (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                           BinInt.Z.add x
                             (BinNums.Zpos BinNums.xH))
                          Znat.Nat2Z.inj_succ
                          (depth t)
                          (BinInt.Z.of_nat (depth t))
                          eq_refl))
                    (ZMicromega.ZTautoChecker_sound
                       (Tauto.A Tauto.isProp
                          {|
                            RingMicromega.Flhs :=
                              EnvRing.PEX BinNums.xH;
                            RingMicromega.Fop :=
                              RingMicromega.OpLt;
                            RingMicromega.Frhs :=
                              EnvRing.PEadd
                                (EnvRing.PEX
                                   BinNums.xH)
                                (EnvRing.PEc
                                   (BinNums.Zpos
                                      BinNums.xH))
                          |} tt) [] eq_refl
                       (VarMap.find BinNums.Z0
                          (VarMap.Elt
                             (BinInt.Z.of_nat
                                (depth t))))))) <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
            (<span class="kr">fix</span> <span class="nb">rename</span>
               (l : list atom) (x y : atom)
               (t : term atom atom)
               (Ht : Acc term_lt t) {<span class="kr">struct</span> Ht} :
                 {u : term atom atom
                 | depth u = depth t} :=
               <span class="kr">match</span>
                 t <span class="kr">as</span> t&#39;
                 <span class="kr">return</span>
                   ((<span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                     term_lt x2 t&#39; -&gt; term_lt x2 t) -&gt;
                    {u : term atom atom
                    | depth u = depth t&#39;})
               <span class="kr">with</span>
               | tvar v =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                         term_lt x2 `v -&gt; term_lt x2 t
                   =&gt;
                   <span class="kr">if</span> x == v
                   <span class="kr">then</span>
                    exist
                      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                       depth u = depth `v) `y eq_refl
                   <span class="kr">else</span>
                    exist
                      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                       depth u = depth `v) `v eq_refl
               | lam b t&#39; =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">phi</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                           term_lt x2 (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt;
                           term_lt x2 t =&gt;
                   <span class="kr">match</span> b == x <span class="kr">with</span>
                   | <span class="nb">left</span> _ =&gt;
                       exist
                         (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                          depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                         (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) eq_refl
                   | <span class="nb">right</span> x2 =&gt;
                       <span class="kr">match</span> b == y <span class="kr">with</span>
                       | <span class="nb">left</span> x3 =&gt;
                           <span class="kr">let</span> (<span class="nv">tm0</span>, pf0) :=
                             <span class="nb">rename</span>
                               (l ++ [<span class="kp">fresh</span> (...)]) b
                               (<span class="kp">fresh</span> ([x] ++ ...)) t&#39;
                               (Acc_inv Ht
                                  (phi t&#39; ...)) <span class="kr">in</span>
                           <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
                             <span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> ...])
                               x y tm0
                               (Acc_inv Ht (...)) <span class="kr">in</span>
                           exist
                             (<span class="kr">fun</span> <span class="nv">u</span> : ... =&gt;
                              depth u = depth ...)
                             (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ ...), tm&#39;)
                             (eq_ind_r (... =&gt; ...)
                                (eq_ind_r ... eq_refl
                                   pf0) pf&#39;)
                       | <span class="nb">right</span> _ =&gt;
                           <span class="kr">let</span> (<span class="nv">tm0</span>, pf0) :=
                             <span class="nb">rename</span> l x y t&#39;
                               (Acc_inv Ht
                                  (phi t&#39; ...)) <span class="kr">in</span>
                           exist
                             (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom
                              =&gt;
                              depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                             (<span class="kr">Œª</span><span class="nv">b</span>, tm0)
                             (eq_ind_r
                                (<span class="kr">fun</span> ... =&gt; ... = ...)
                                eq_refl pf0)
                       <span class="kr">end</span>
                   <span class="kr">end</span>
               | tap t1 t2 =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">phi</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                           term_lt x2 (t1¬∑t2) -&gt;
                           term_lt x2 t =&gt;
                   <span class="kr">let</span> (<span class="nv">t1&#39;</span>, pf1&#39;) :=
                     <span class="nb">rename</span> l x y t1
                       (Acc_inv Ht
                          (phi t1 (tap_depth1 t1 t2))) <span class="kr">in</span>
                   <span class="kr">let</span> (<span class="nv">t2&#39;</span>, pf2&#39;) :=
                     <span class="nb">rename</span> l x y t2
                       (Acc_inv Ht
                          (phi t2 (tap_depth2 t1 t2))) <span class="kr">in</span>
                   exist
                     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                      depth u = depth (t1¬∑t2))
                     (t1&#39;¬∑t2&#39;)
                     (eq_ind_r
                        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                         n = depth t1 -&gt;
                         depth t2&#39; = depth t2 -&gt;
                         S ... = S ...)
                        (eq_ind_r
                           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                            ... = ... -&gt; ... -&gt; ...)
                           (<span class="kr">fun</span> (<span class="nv">_</span> : ...) (<span class="nv">_</span> : ...) =&gt;
                            eq_refl) pf2&#39;) pf1&#39; pf1&#39;
                        pf2&#39;)
               <span class="kr">end</span>
                 (<span class="kr">fun</span> (<span class="nv">x2</span> : term atom atom)
                    (<span class="nv">y0</span> : term_lt x2 t) =&gt; y0))
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [x])]) x y tm
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">x</span>, t) a)
                 (eq_ind_r
                    (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
                     (<span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                      term_lt x2 (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt;
                      term_lt x2 (<span class="kr">Œª</span><span class="nv">x</span>, t)) -&gt;
                     b &lt;&gt; x -&gt; depth tm &lt; S (depth t))
                    (<span class="kr">fun</span>
                       (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                            term_lt x2 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                            term_lt x2 (<span class="kr">Œª</span><span class="nv">x</span>, t))
                       (<span class="nv">_</span> : y &lt;&gt; x) =&gt;
                     ZifyClasses.rew_iff_rev
                       (depth tm &lt; S (depth t))
                       (BinInt.Z.lt
                          (BinInt.Z.of_nat (depth tm))
                          (BinInt.Z.add
                             (BinInt.Z.of_nat
                                (depth t))
                             (BinNums.Zpos BinNums.xH)))
                       (ZifyClasses.mkrel nat
                          BinNums.Z lt BinInt.Z.of_nat
                          BinInt.Z.lt
                          Znat.Nat2Z.inj_lt (depth tm)
                          (BinInt.Z.of_nat (depth tm))
                          eq_refl (S (depth t))
                          (BinInt.Z.add
                             (BinInt.Z.of_nat
                                (depth t))
                             (BinNums.Zpos BinNums.xH))
                          (ZifyClasses.mkapp nat nat
                             BinNums.Z BinNums.Z S
                             BinInt.Z.of_nat
                             BinInt.Z.of_nat
                             (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                              BinInt.Z.add x
                                (BinNums.Zpos
                                   BinNums.xH))
                             Znat.Nat2Z.inj_succ
                             (depth t)
                             (BinInt.Z.of_nat
                                (depth t)) eq_refl))
                       (ZMicromega.ZTautoChecker_sound
                          (Tauto.IMPL
                             (Tauto.A Tauto.isProp
                                {|
                                  RingMicromega.Flhs :=
                                    EnvRing.PEX
                                      BinNums.xH;
                                  RingMicromega.Fop :=
                                    RingMicromega.OpEq;
                                  RingMicromega.Frhs :=
                                    EnvRing.PEX ...
                                |} tt) None
                             (Tauto.A Tauto.isProp
                                {|
                                  RingMicromega.Flhs :=
                                    EnvRing.PEX
                                      BinNums.xH;
                                  RingMicromega.Fop :=
                                    RingMicromega.OpLt;
                                  RingMicromega.Frhs :=
                                    EnvRing.PEadd ...
                                      ...
                                |} tt)) [] eq_refl
                          (VarMap.find BinNums.Z0
                             (VarMap.Branch
                                (VarMap.Elt
                                   (BinInt.Z.of_nat
                                      ...))
                                (BinInt.Z.of_nat
                                   (depth tm))
                                VarMap.Empty))
                          (ZifyClasses.rew_iff
                             (depth tm = depth t)
                             (BinInt.Z.of_nat
                                (depth tm) =
                              BinInt.Z.of_nat
                                (depth t))
                             (ZifyClasses.mkrel nat
                                BinNums.Z eq
                                BinInt.Z.of_nat eq
                                (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                                 iff_sym (...))
                                (depth tm)
                                (BinInt.Z.of_nat
                                   (depth tm)) eq_refl
                                (depth t)
                                (BinInt.Z.of_nat
                                   (depth t)) eq_refl)
                             pf))) x1
                    (<span class="kr">fun</span> (<span class="nv">x2</span> : term atom atom)
                       (<span class="nv">y</span> : term_lt x2 (<span class="kr">Œª</span><span class="nv">x</span>, t)) =&gt; y)
                    x0)) <span class="kr">in</span>
          exist
            (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
             depth u = depth (<span class="kr">Œª</span><span class="nv">x</span>, t))
            (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [x]), tm&#39;)
            (eq_ind_r
               (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
               (eq_ind_r
                  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
                  eq_refl pf) pf&#39;)
      | <span class="nb">right</span> _ =&gt;
          <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
            (<span class="kr">fix</span> <span class="nb">rename</span>
               (l : list atom) (x y : atom)
               (t : term atom atom)
               (Ht : Acc term_lt t) {<span class="kr">struct</span> Ht} :
                 {u : term atom atom
                 | depth u = depth t} :=
               <span class="kr">match</span>
                 t <span class="kr">as</span> t&#39;
                 <span class="kr">return</span>
                   ((<span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                     term_lt x2 t&#39; -&gt; term_lt x2 t) -&gt;
                    {u : term atom atom
                    | depth u = depth t&#39;})
               <span class="kr">with</span>
               | tvar v =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                         term_lt x2 `v -&gt; term_lt x2 t
                   =&gt;
                   <span class="kr">if</span> x == v
                   <span class="kr">then</span>
                    exist
                      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                       depth u = depth `v) `y eq_refl
                   <span class="kr">else</span>
                    exist
                      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                       depth u = depth `v) `v eq_refl
               | lam b t&#39; =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">phi</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                           term_lt x2 (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) -&gt;
                           term_lt x2 t =&gt;
                   <span class="kr">match</span> b == x <span class="kr">with</span>
                   | <span class="nb">left</span> _ =&gt;
                       exist
                         (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                          depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                         (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;) eq_refl
                   | <span class="nb">right</span> x2 =&gt;
                       <span class="kr">match</span> b == y <span class="kr">with</span>
                       | <span class="nb">left</span> x3 =&gt;
                           <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
                             <span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span> ([x] ++ ...)])
                               b
                               (<span class="kp">fresh</span>
                                  ([x] ++ l ++ [b]))
                               t&#39;
                               (Acc_inv Ht
                                  (phi t&#39; (...))) <span class="kr">in</span>
                           <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
                             <span class="nb">rename</span>
                               (l ++ [<span class="kp">fresh</span> (...)]) x
                               y tm
                               (Acc_inv Ht
                                  (phi tm ...)) <span class="kr">in</span>
                           exist
                             (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom
                              =&gt;
                              depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                             (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), tm&#39;)
                             (eq_ind_r
                                (<span class="kr">fun</span> ... =&gt; ... = ...)
                                (eq_ind_r (...)
                                   eq_refl pf) pf&#39;)
                       | <span class="nb">right</span> _ =&gt;
                           <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
                             <span class="nb">rename</span> l x y t&#39;
                               (Acc_inv Ht
                                  (phi t&#39; (...))) <span class="kr">in</span>
                           exist
                             (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom
                              =&gt;
                              depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t&#39;))
                             (<span class="kr">Œª</span><span class="nv">b</span>, tm)
                             (eq_ind_r
                                (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                                 S n = S ...) eq_refl
                                pf)
                       <span class="kr">end</span>
                   <span class="kr">end</span>
               | tap t1 t2 =&gt;
                   <span class="kr">fun</span>
                     <span class="nv">phi</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                           term_lt x2 (t1¬∑t2) -&gt;
                           term_lt x2 t =&gt;
                   <span class="kr">let</span> (<span class="nv">t1&#39;</span>, pf1&#39;) :=
                     <span class="nb">rename</span> l x y t1
                       (Acc_inv Ht
                          (phi t1 (tap_depth1 t1 t2))) <span class="kr">in</span>
                   <span class="kr">let</span> (<span class="nv">t2&#39;</span>, pf2&#39;) :=
                     <span class="nb">rename</span> l x y t2
                       (Acc_inv Ht
                          (phi t2 (tap_depth2 t1 t2))) <span class="kr">in</span>
                   exist
                     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
                      depth u = depth (t1¬∑t2))
                     (t1&#39;¬∑t2&#39;)
                     (eq_ind_r
                        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                         n = depth t1 -&gt;
                         depth t2&#39; = depth t2 -&gt;
                         S (...) = S (...))
                        (eq_ind_r
                           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
                            depth t1 = depth t1 -&gt;
                            n = ... -&gt; ... = ...)
                           (<span class="kr">fun</span> (<span class="nv">_</span> : ... = ...)
                              (<span class="nv">_</span> : ... = ...) =&gt;
                            eq_refl) pf2&#39;) pf1&#39; pf1&#39;
                        pf2&#39;)
               <span class="kr">end</span>
                 (<span class="kr">fun</span> (<span class="nv">x2</span> : term atom atom)
                    (<span class="nv">y0</span> : term_lt x2 t) =&gt; y0)) l x y
              t
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">x</span>, t) a)
                 (ZifyClasses.rew_iff_rev
                    (depth t &lt; S (depth t))
                    (BinInt.Z.lt
                       (BinInt.Z.of_nat (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH)))
                    (ZifyClasses.mkrel nat BinNums.Z
                       lt BinInt.Z.of_nat BinInt.Z.lt
                       Znat.Nat2Z.inj_lt (depth t)
                       (BinInt.Z.of_nat (depth t))
                       eq_refl (S (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH))
                       (ZifyClasses.mkapp nat nat
                          BinNums.Z BinNums.Z S
                          BinInt.Z.of_nat
                          BinInt.Z.of_nat
                          (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                           BinInt.Z.add x
                             (BinNums.Zpos BinNums.xH))
                          Znat.Nat2Z.inj_succ
                          (depth t)
                          (BinInt.Z.of_nat (depth t))
                          eq_refl))
                    (ZMicromega.ZTautoChecker_sound
                       (Tauto.A Tauto.isProp
                          {|
                            RingMicromega.Flhs :=
                              EnvRing.PEX BinNums.xH;
                            RingMicromega.Fop :=
                              RingMicromega.OpLt;
                            RingMicromega.Frhs :=
                              EnvRing.PEadd
                                (EnvRing.PEX
                                   BinNums.xH)
                                (EnvRing.PEc
                                   (BinNums.Zpos
                                      BinNums.xH))
                          |} tt) [] eq_refl
                       (VarMap.find BinNums.Z0
                          (VarMap.Elt
                             (BinInt.Z.of_nat
                                (depth t))))))) <span class="kr">in</span>
          exist
            (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
             depth u = depth (<span class="kr">Œª</span><span class="nv">x</span>, t)) (<span class="kr">Œª</span><span class="nv">x</span>, tm)
            (eq_ind_r
               (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
               eq_refl pf)
      <span class="kr">end</span>
  <span class="kr">end</span> = (<span class="kr">Œª</span><span class="nv">x</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka0"><span class="nb">fold</span> rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">x</span>, t) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  <span class="kr">match</span> x == x <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt;
      exist
        (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
         depth u = depth (<span class="kr">Œª</span><span class="nv">x</span>, t)) (<span class="kr">Œª</span><span class="nv">x</span>, t) eq_refl
  | <span class="nb">right</span> x0 =&gt;
      <span class="kr">match</span> x == y <span class="kr">with</span>
      | <span class="nb">left</span> x1 =&gt;
          <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
            rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [x])]) x
              (<span class="kp">fresh</span> ([x] ++ l ++ [x])) t
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">x</span>, t) a)
                 (ZifyClasses.rew_iff_rev
                    (depth t &lt; S (depth t))
                    (BinInt.Z.lt
                       (BinInt.Z.of_nat (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH)))
                    (ZifyClasses.mkrel nat BinNums.Z
                       lt BinInt.Z.of_nat BinInt.Z.lt
                       Znat.Nat2Z.inj_lt (depth t)
                       (BinInt.Z.of_nat (depth t))
                       eq_refl (S (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH))
                       (ZifyClasses.mkapp nat nat
                          BinNums.Z BinNums.Z S
                          BinInt.Z.of_nat
                          BinInt.Z.of_nat
                          (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                           BinInt.Z.add x
                             (BinNums.Zpos BinNums.xH))
                          Znat.Nat2Z.inj_succ
                          (depth t)
                          (BinInt.Z.of_nat (depth t))
                          eq_refl))
                    (ZMicromega.ZTautoChecker_sound
                       (Tauto.A Tauto.isProp
                          {|
                            RingMicromega.Flhs :=
                              EnvRing.PEX BinNums.xH;
                            RingMicromega.Fop :=
                              RingMicromega.OpLt;
                            RingMicromega.Frhs :=
                              EnvRing.PEadd
                                (EnvRing.PEX
                                   BinNums.xH)
                                (EnvRing.PEc
                                   (BinNums.Zpos
                                      BinNums.xH))
                          |} tt) [] eq_refl
                       (VarMap.find BinNums.Z0
                          (VarMap.Elt
                             (BinInt.Z.of_nat
                                (depth t))))))) <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
            rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [x])]) x
              y tm
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">x</span>, t) a)
                 (eq_ind_r
                    (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
                     (<span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                      term_lt x2 (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt;
                      term_lt x2 (<span class="kr">Œª</span><span class="nv">x</span>, t)) -&gt;
                     b &lt;&gt; x -&gt; depth tm &lt; S (depth t))
                    (<span class="kr">fun</span>
                       (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x2</span> : term atom atom,
                            term_lt x2 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                            term_lt x2 (<span class="kr">Œª</span><span class="nv">x</span>, t))
                       (<span class="nv">_</span> : y &lt;&gt; x) =&gt;
                     ZifyClasses.rew_iff_rev
                       (depth tm &lt; S (depth t))
                       (BinInt.Z.lt
                          (BinInt.Z.of_nat (depth tm))
                          (BinInt.Z.add
                             (BinInt.Z.of_nat
                                (depth t))
                             (BinNums.Zpos BinNums.xH)))
                       (ZifyClasses.mkrel nat
                          BinNums.Z lt BinInt.Z.of_nat
                          BinInt.Z.lt
                          Znat.Nat2Z.inj_lt (depth tm)
                          (BinInt.Z.of_nat (depth tm))
                          eq_refl (S (depth t))
                          (BinInt.Z.add
                             (BinInt.Z.of_nat
                                (depth t))
                             (BinNums.Zpos BinNums.xH))
                          (ZifyClasses.mkapp nat nat
                             BinNums.Z BinNums.Z S
                             BinInt.Z.of_nat
                             BinInt.Z.of_nat
                             (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                              BinInt.Z.add x
                                (BinNums.Zpos
                                   BinNums.xH))
                             Znat.Nat2Z.inj_succ
                             (depth t)
                             (BinInt.Z.of_nat
                                (depth t)) eq_refl))
                       (ZMicromega.ZTautoChecker_sound
                          (Tauto.IMPL
                             (Tauto.A Tauto.isProp
                                {|
                                  RingMicromega.Flhs :=
                                    EnvRing.PEX
                                      BinNums.xH;
                                  RingMicromega.Fop :=
                                    RingMicromega.OpEq;
                                  RingMicromega.Frhs :=
                                    EnvRing.PEX ...
                                |} tt) None
                             (Tauto.A Tauto.isProp
                                {|
                                  RingMicromega.Flhs :=
                                    EnvRing.PEX
                                      BinNums.xH;
                                  RingMicromega.Fop :=
                                    RingMicromega.OpLt;
                                  RingMicromega.Frhs :=
                                    EnvRing.PEadd ...
                                      ...
                                |} tt)) [] eq_refl
                          (VarMap.find BinNums.Z0
                             (VarMap.Branch
                                (VarMap.Elt
                                   (BinInt.Z.of_nat
                                      ...))
                                (BinInt.Z.of_nat
                                   (depth tm))
                                VarMap.Empty))
                          (ZifyClasses.rew_iff
                             (depth tm = depth t)
                             (BinInt.Z.of_nat
                                (depth tm) =
                              BinInt.Z.of_nat
                                (depth t))
                             (ZifyClasses.mkrel nat
                                BinNums.Z eq
                                BinInt.Z.of_nat eq
                                (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                                 iff_sym (...))
                                (depth tm)
                                (BinInt.Z.of_nat
                                   (depth tm)) eq_refl
                                (depth t)
                                (BinInt.Z.of_nat
                                   (depth t)) eq_refl)
                             pf))) x1
                    (<span class="kr">fun</span> (<span class="nv">x2</span> : term atom atom)
                       (<span class="nv">y</span> : term_lt x2 (<span class="kr">Œª</span><span class="nv">x</span>, t)) =&gt; y)
                    x0)) <span class="kr">in</span>
          exist
            (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
             depth u = depth (<span class="kr">Œª</span><span class="nv">x</span>, t))
            (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [x]), tm&#39;)
            (eq_ind_r
               (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
               (eq_ind_r
                  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
                  eq_refl pf) pf&#39;)
      | <span class="nb">right</span> _ =&gt;
          <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
            rename&#39; l x y t
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">x</span>, t) a)
                 (ZifyClasses.rew_iff_rev
                    (depth t &lt; S (depth t))
                    (BinInt.Z.lt
                       (BinInt.Z.of_nat (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH)))
                    (ZifyClasses.mkrel nat BinNums.Z
                       lt BinInt.Z.of_nat BinInt.Z.lt
                       Znat.Nat2Z.inj_lt (depth t)
                       (BinInt.Z.of_nat (depth t))
                       eq_refl (S (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH))
                       (ZifyClasses.mkapp nat nat
                          BinNums.Z BinNums.Z S
                          BinInt.Z.of_nat
                          BinInt.Z.of_nat
                          (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                           BinInt.Z.add x
                             (BinNums.Zpos BinNums.xH))
                          Znat.Nat2Z.inj_succ
                          (depth t)
                          (BinInt.Z.of_nat (depth t))
                          eq_refl))
                    (ZMicromega.ZTautoChecker_sound
                       (Tauto.A Tauto.isProp
                          {|
                            RingMicromega.Flhs :=
                              EnvRing.PEX BinNums.xH;
                            RingMicromega.Fop :=
                              RingMicromega.OpLt;
                            RingMicromega.Frhs :=
                              EnvRing.PEadd
                                (EnvRing.PEX
                                   BinNums.xH)
                                (EnvRing.PEc
                                   (BinNums.Zpos
                                      BinNums.xH))
                          |} tt) [] eq_refl
                       (VarMap.find BinNums.Z0
                          (VarMap.Elt
                             (BinInt.Z.of_nat
                                (depth t))))))) <span class="kr">in</span>
          exist
            (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
             depth u = depth (<span class="kr">Œª</span><span class="nv">x</span>, t)) (<span class="kr">Œª</span><span class="nv">x</span>, tm)
            (eq_ind_r
               (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
               eq_refl pf)
      <span class="kr">end</span>
  <span class="kr">end</span> = (<span class="kr">Œª</span><span class="nv">x</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args x x.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka1">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">b</span>, t))) =
(<span class="kr">if</span> b == y
 <span class="kr">then</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [b]), <span class="nb">rename</span>
                            (l ++
                             [<span class="kp">fresh</span> (x :: l ++ [b])])
                            x y
                            (<span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span> (x :: l ++ [b])])
                               b
                               (<span class="kp">fresh</span> (x :: l ++ [b]))
                               t)
 <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) (term_lt_wf (<span class="kr">Œª</span><span class="nv">b</span>, t))) =
(<span class="kr">if</span> b == y
 <span class="kr">then</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [b]), <span class="nb">rename</span>
                            (l ++
                             [<span class="kp">fresh</span> (x :: l ++ [b])])
                            x y
                            (<span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span> (x :: l ++ [b])])
                               b
                               (<span class="kp">fresh</span> (x :: l ++ [b]))
                               t)
 <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka3"><span class="nb">destruct</span> (term_lt_wf (lam b t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (rename&#39; l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)) =
(<span class="kr">if</span> b == y
 <span class="kr">then</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [b]), <span class="nb">rename</span>
                            (l ++
                             [<span class="kp">fresh</span> (x :: l ++ [b])])
                            x y
                            (<span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span> (x :: l ++ [b])])
                               b
                               (<span class="kp">fresh</span> (x :: l ++ [b]))
                               t)
 <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka4"><span class="nb">unfold</span> rename&#39;; <span class="nb">fold</span> rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  <span class="kr">match</span> b == x <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt;
      exist
        (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
         depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, t) eq_refl
  | <span class="nb">right</span> x0 =&gt;
      <span class="kr">match</span> b == y <span class="kr">with</span>
      | <span class="nb">left</span> x1 =&gt;
          <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
            rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [b])]) b
              (<span class="kp">fresh</span> ([x] ++ l ++ [b])) t
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
                 (ZifyClasses.rew_iff_rev
                    (depth t &lt; S (depth t))
                    (BinInt.Z.lt
                       (BinInt.Z.of_nat (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH)))
                    (ZifyClasses.mkrel nat BinNums.Z
                       lt BinInt.Z.of_nat BinInt.Z.lt
                       Znat.Nat2Z.inj_lt (depth t)
                       (BinInt.Z.of_nat (depth t))
                       eq_refl (S (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH))
                       (ZifyClasses.mkapp nat nat
                          BinNums.Z BinNums.Z S
                          BinInt.Z.of_nat
                          BinInt.Z.of_nat
                          (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                           BinInt.Z.add x
                             (BinNums.Zpos BinNums.xH))
                          Znat.Nat2Z.inj_succ
                          (depth t)
                          (BinInt.Z.of_nat (depth t))
                          eq_refl))
                    (ZMicromega.ZTautoChecker_sound
                       (Tauto.A Tauto.isProp
                          {|
                            RingMicromega.Flhs :=
                              EnvRing.PEX BinNums.xH;
                            RingMicromega.Fop :=
                              RingMicromega.OpLt;
                            RingMicromega.Frhs :=
                              EnvRing.PEadd
                                (EnvRing.PEX
                                   BinNums.xH)
                                (EnvRing.PEc
                                   (BinNums.Zpos
                                      BinNums.xH))
                          |} tt) [] eq_refl
                       (VarMap.find BinNums.Z0
                          (VarMap.Elt
                             (BinInt.Z.of_nat
                                (depth t))))))) <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
            rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [b])]) x
              y tm
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
                 (eq_ind_r
                    (<span class="kr">fun</span> <span class="nv">b0</span> : atom =&gt;
                     (<span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                      term_lt x (<span class="kr">Œª</span><span class="nv">b0</span>, t) -&gt;
                      term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t)) -&gt;
                     b0 &lt;&gt; x -&gt; depth tm &lt; S (depth t))
                    (<span class="kr">fun</span>
                       (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                            term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                            term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t))
                       (<span class="nv">_</span> : y &lt;&gt; x) =&gt;
                     ZifyClasses.rew_iff_rev
                       (depth tm &lt; S (depth t))
                       (BinInt.Z.lt
                          (BinInt.Z.of_nat (depth tm))
                          (BinInt.Z.add
                             (BinInt.Z.of_nat
                                (depth t))
                             (BinNums.Zpos BinNums.xH)))
                       (ZifyClasses.mkrel nat
                          BinNums.Z lt BinInt.Z.of_nat
                          BinInt.Z.lt
                          Znat.Nat2Z.inj_lt (depth tm)
                          (BinInt.Z.of_nat (depth tm))
                          eq_refl (S (depth t))
                          (BinInt.Z.add
                             (BinInt.Z.of_nat
                                (depth t))
                             (BinNums.Zpos BinNums.xH))
                          (ZifyClasses.mkapp nat nat
                             BinNums.Z BinNums.Z S
                             BinInt.Z.of_nat
                             BinInt.Z.of_nat
                             (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                              BinInt.Z.add x
                                (BinNums.Zpos
                                   BinNums.xH))
                             Znat.Nat2Z.inj_succ
                             (depth t)
                             (BinInt.Z.of_nat
                                (depth t)) eq_refl))
                       (ZMicromega.ZTautoChecker_sound
                          (Tauto.IMPL
                             (Tauto.A Tauto.isProp
                                {|
                                  RingMicromega.Flhs :=
                                    EnvRing.PEX
                                      BinNums.xH;
                                  RingMicromega.Fop :=
                                    RingMicromega.OpEq;
                                  RingMicromega.Frhs :=
                                    EnvRing.PEX ...
                                |} tt) None
                             (Tauto.A Tauto.isProp
                                {|
                                  RingMicromega.Flhs :=
                                    EnvRing.PEX
                                      BinNums.xH;
                                  RingMicromega.Fop :=
                                    RingMicromega.OpLt;
                                  RingMicromega.Frhs :=
                                    EnvRing.PEadd ...
                                      ...
                                |} tt)) [] eq_refl
                          (VarMap.find BinNums.Z0
                             (VarMap.Branch
                                (VarMap.Elt
                                   (BinInt.Z.of_nat
                                      ...))
                                (BinInt.Z.of_nat
                                   (depth tm))
                                VarMap.Empty))
                          (ZifyClasses.rew_iff
                             (depth tm = depth t)
                             (BinInt.Z.of_nat
                                (depth tm) =
                              BinInt.Z.of_nat
                                (depth t))
                             (ZifyClasses.mkrel nat
                                BinNums.Z eq
                                BinInt.Z.of_nat eq
                                (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                                 iff_sym (...))
                                (depth tm)
                                (BinInt.Z.of_nat
                                   (depth tm)) eq_refl
                                (depth t)
                                (BinInt.Z.of_nat
                                   (depth t)) eq_refl)
                             pf))) x1
                    (<span class="kr">fun</span> (<span class="nv">x</span> : term atom atom)
                       (<span class="nv">y</span> : term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t)) =&gt; y)
                    x0)) <span class="kr">in</span>
          exist
            (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
             depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t))
            (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), tm&#39;)
            (eq_ind_r
               (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
               (eq_ind_r
                  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
                  eq_refl pf) pf&#39;)
      | <span class="nb">right</span> _ =&gt;
          <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
            rename&#39; l x y t
              (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
                 (ZifyClasses.rew_iff_rev
                    (depth t &lt; S (depth t))
                    (BinInt.Z.lt
                       (BinInt.Z.of_nat (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH)))
                    (ZifyClasses.mkrel nat BinNums.Z
                       lt BinInt.Z.of_nat BinInt.Z.lt
                       Znat.Nat2Z.inj_lt (depth t)
                       (BinInt.Z.of_nat (depth t))
                       eq_refl (S (depth t))
                       (BinInt.Z.add
                          (BinInt.Z.of_nat (depth t))
                          (BinNums.Zpos BinNums.xH))
                       (ZifyClasses.mkapp nat nat
                          BinNums.Z BinNums.Z S
                          BinInt.Z.of_nat
                          BinInt.Z.of_nat
                          (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                           BinInt.Z.add x
                             (BinNums.Zpos BinNums.xH))
                          Znat.Nat2Z.inj_succ
                          (depth t)
                          (BinInt.Z.of_nat (depth t))
                          eq_refl))
                    (ZMicromega.ZTautoChecker_sound
                       (Tauto.A Tauto.isProp
                          {|
                            RingMicromega.Flhs :=
                              EnvRing.PEX BinNums.xH;
                            RingMicromega.Fop :=
                              RingMicromega.OpLt;
                            RingMicromega.Frhs :=
                              EnvRing.PEadd
                                (EnvRing.PEX
                                   BinNums.xH)
                                (EnvRing.PEc
                                   (BinNums.Zpos
                                      BinNums.xH))
                          |} tt) [] eq_refl
                       (VarMap.find BinNums.Z0
                          (VarMap.Elt
                             (BinInt.Z.of_nat
                                (depth t))))))) <span class="kr">in</span>
          exist
            (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
             depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, tm)
            (eq_ind_r
               (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
               eq_refl pf)
      <span class="kr">end</span>
  <span class="kr">end</span> =
(<span class="kr">if</span> b == y
 <span class="kr">then</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [b]), <span class="nb">rename</span>
                            (l ++
                             [<span class="kp">fresh</span> (x :: l ++ [b])])
                            x y
                            (<span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span> (x :: l ++ [b])])
                               b
                               (<span class="kp">fresh</span> (x :: l ++ [b]))
                               t)
 <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka5">destruct_eq_args b y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  <span class="kr">match</span> y == x <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt;
      exist
        (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
         depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t)) (<span class="kr">Œª</span><span class="nv">y</span>, t) eq_refl
  | <span class="nb">right</span> x0 =&gt;
      <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
        rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
          (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
          (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
             (ZifyClasses.rew_iff_rev
                (depth t &lt; S (depth t))
                (BinInt.Z.lt
                   (BinInt.Z.of_nat (depth t))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH)))
                (ZifyClasses.mkrel nat BinNums.Z lt
                   BinInt.Z.of_nat BinInt.Z.lt
                   Znat.Nat2Z.inj_lt (depth t)
                   (BinInt.Z.of_nat (depth t)) eq_refl
                   (S (depth t))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH))
                   (ZifyClasses.mkapp nat nat
                      BinNums.Z BinNums.Z S
                      BinInt.Z.of_nat BinInt.Z.of_nat
                      (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                       BinInt.Z.add x
                         (BinNums.Zpos BinNums.xH))
                      Znat.Nat2Z.inj_succ (depth t)
                      (BinInt.Z.of_nat (depth t))
                      eq_refl))
                (ZMicromega.ZTautoChecker_sound
                   (Tauto.A Tauto.isProp
                      {|
                        RingMicromega.Flhs :=
                          EnvRing.PEX BinNums.xH;
                        RingMicromega.Fop :=
                          RingMicromega.OpLt;
                        RingMicromega.Frhs :=
                          EnvRing.PEadd
                            (EnvRing.PEX BinNums.xH)
                            (EnvRing.PEc
                               (BinNums.Zpos
                                  BinNums.xH))
                      |} tt) [] eq_refl
                   (VarMap.find BinNums.Z0
                      (VarMap.Elt
                         (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
        rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
          tm
          (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
             (eq_ind_r
                (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
                 (<span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                  term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt;
                  term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) -&gt;
                 b &lt;&gt; x -&gt; depth tm &lt; S (depth t))
                (<span class="kr">fun</span>
                   (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                        term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                        term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t))
                   (<span class="nv">_</span> : y &lt;&gt; x) =&gt;
                 ZifyClasses.rew_iff_rev
                   (depth tm &lt; S (depth t))
                   (BinInt.Z.lt
                      (BinInt.Z.of_nat (depth tm))
                      (BinInt.Z.add
                         (BinInt.Z.of_nat (depth t))
                         (BinNums.Zpos BinNums.xH)))
                   (ZifyClasses.mkrel nat BinNums.Z lt
                      BinInt.Z.of_nat BinInt.Z.lt
                      Znat.Nat2Z.inj_lt (depth tm)
                      (BinInt.Z.of_nat (depth tm))
                      eq_refl (S (depth t))
                      (BinInt.Z.add
                         (BinInt.Z.of_nat (depth t))
                         (BinNums.Zpos BinNums.xH))
                      (ZifyClasses.mkapp nat nat
                         BinNums.Z BinNums.Z S
                         BinInt.Z.of_nat
                         BinInt.Z.of_nat
                         (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                          BinInt.Z.add x
                            (BinNums.Zpos BinNums.xH))
                         Znat.Nat2Z.inj_succ (depth t)
                         (BinInt.Z.of_nat (depth t))
                         eq_refl))
                   (ZMicromega.ZTautoChecker_sound
                      (Tauto.IMPL
                         (Tauto.A Tauto.isProp
                            {|
                              RingMicromega.Flhs :=
                                EnvRing.PEX BinNums.xH;
                              RingMicromega.Fop :=
                                RingMicromega.OpEq;
                              RingMicromega.Frhs :=
                                EnvRing.PEX
                                  (BinNums.xO
                                     BinNums.xH)
                            |} tt) None
                         (Tauto.A Tauto.isProp
                            {|
                              RingMicromega.Flhs :=
                                EnvRing.PEX BinNums.xH;
                              RingMicromega.Fop :=
                                RingMicromega.OpLt;
                              RingMicromega.Frhs :=
                                EnvRing.PEadd
                                  (EnvRing.PEX ...)
                                  (EnvRing.PEc ...)
                            |} tt)) [] eq_refl
                      (VarMap.find BinNums.Z0
                         (VarMap.Branch
                            (VarMap.Elt
                               (BinInt.Z.of_nat
                                  (depth t)))
                            (BinInt.Z.of_nat
                               (depth tm))
                            VarMap.Empty))
                      (ZifyClasses.rew_iff
                         (depth tm = depth t)
                         (BinInt.Z.of_nat (depth tm) =
                          BinInt.Z.of_nat (depth t))
                         (ZifyClasses.mkrel nat
                            BinNums.Z eq
                            BinInt.Z.of_nat eq
                            (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                             iff_sym
                               (Znat.Nat2Z.inj_iff x y))
                            (depth tm)
                            (BinInt.Z.of_nat
                               (depth tm)) eq_refl
                            (depth t)
                            (BinInt.Z.of_nat (depth t))
                            eq_refl) pf))) eq_refl
                (<span class="kr">fun</span> (<span class="nv">x</span> : term atom atom)
                   (<span class="nv">y</span> : term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) =&gt; y) x0)) <span class="kr">in</span>
      exist
        (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
         depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
        (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           (eq_ind_r
              (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
              eq_refl pf) pf&#39;)
  <span class="kr">end</span> =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chka6"><hr></label><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> b == x
   <span class="kr">then</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) 
      (<span class="kr">Œª</span><span class="nv">b</span>, t) eq_refl
   <span class="kr">else</span>
    <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
      rename&#39; l x y t
        (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
           (ZifyClasses.rew_iff_rev
              (depth t &lt; S (depth t))
              (BinInt.Z.lt 
                 (BinInt.Z.of_nat (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH)))
              (ZifyClasses.mkrel nat BinNums.Z lt
                 BinInt.Z.of_nat BinInt.Z.lt
                 Znat.Nat2Z.inj_lt 
                 (depth t) 
                 (BinInt.Z.of_nat (depth t)) eq_refl
                 (S (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH))
                 (ZifyClasses.mkapp nat nat BinNums.Z
                    BinNums.Z S BinInt.Z.of_nat
                    BinInt.Z.of_nat
                    (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                     BinInt.Z.add x
                     (BinNums.Zpos BinNums.xH))
                    Znat.Nat2Z.inj_succ 
                    (depth t)
                    (BinInt.Z.of_nat (depth t))
                    eq_refl))
              (ZMicromega.ZTautoChecker_sound
                 (Tauto.A Tauto.isProp
                    {|
                     RingMicromega.Flhs :=
                     EnvRing.PEX BinNums.xH;
                     RingMicromega.Fop :=
                     RingMicromega.OpLt;
                     RingMicromega.Frhs :=
                     EnvRing.PEadd
                     (EnvRing.PEX BinNums.xH)
                     (EnvRing.PEc
                     (BinNums.Zpos BinNums.xH))
                    |} tt) [] eq_refl
                 (VarMap.find BinNums.Z0
                    (VarMap.Elt
                     (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) 
      (<span class="kr">Œª</span><span class="nv">b</span>, tm)
      (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
         eq_refl pf)) = 
(<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka7">destruct_eq_args y x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
       (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
          (ZifyClasses.rew_iff_rev
             (depth t &lt; S (depth t))
             (BinInt.Z.lt (BinInt.Z.of_nat (depth t))
                (BinInt.Z.add
                   (BinInt.Z.of_nat (depth t))
                   (BinNums.Zpos BinNums.xH)))
             (ZifyClasses.mkrel nat BinNums.Z lt
                BinInt.Z.of_nat BinInt.Z.lt
                Znat.Nat2Z.inj_lt (depth t)
                (BinInt.Z.of_nat (depth t)) eq_refl
                (S (depth t))
                (BinInt.Z.add
                   (BinInt.Z.of_nat (depth t))
                   (BinNums.Zpos BinNums.xH))
                (ZifyClasses.mkapp nat nat BinNums.Z
                   BinNums.Z S BinInt.Z.of_nat
                   BinInt.Z.of_nat
                   (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                    BinInt.Z.add x
                      (BinNums.Zpos BinNums.xH))
                   Znat.Nat2Z.inj_succ (depth t)
                   (BinInt.Z.of_nat (depth t)) eq_refl))
             (ZMicromega.ZTautoChecker_sound
                (Tauto.A Tauto.isProp
                   {|
                     RingMicromega.Flhs :=
                       EnvRing.PEX BinNums.xH;
                     RingMicromega.Fop :=
                       RingMicromega.OpLt;
                     RingMicromega.Frhs :=
                       EnvRing.PEadd
                         (EnvRing.PEX BinNums.xH)
                         (EnvRing.PEc
                            (BinNums.Zpos BinNums.xH))
                   |} tt) [] eq_refl
                (VarMap.find BinNums.Z0
                   (VarMap.Elt
                      (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y tm
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
          (eq_ind_r
             (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
              (<span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
               term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) -&gt;
              b &lt;&gt; x -&gt; depth tm &lt; S (depth t))
             (<span class="kr">fun</span>
                (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) (<span class="nv">_</span> : y &lt;&gt; x)
              =&gt;
              ZifyClasses.rew_iff_rev
                (depth tm &lt; S (depth t))
                (BinInt.Z.lt
                   (BinInt.Z.of_nat (depth tm))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH)))
                (ZifyClasses.mkrel nat BinNums.Z lt
                   BinInt.Z.of_nat BinInt.Z.lt
                   Znat.Nat2Z.inj_lt (depth tm)
                   (BinInt.Z.of_nat (depth tm))
                   eq_refl (S (depth t))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH))
                   (ZifyClasses.mkapp nat nat
                      BinNums.Z BinNums.Z S
                      BinInt.Z.of_nat BinInt.Z.of_nat
                      (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                       BinInt.Z.add x
                         (BinNums.Zpos BinNums.xH))
                      Znat.Nat2Z.inj_succ (depth t)
                      (BinInt.Z.of_nat (depth t))
                      eq_refl))
                (ZMicromega.ZTautoChecker_sound
                   (Tauto.IMPL
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpEq;
                           RingMicromega.Frhs :=
                             EnvRing.PEX
                               (BinNums.xO BinNums.xH)
                         |} tt) None
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpLt;
                           RingMicromega.Frhs :=
                             EnvRing.PEadd
                               (EnvRing.PEX (...))
                               (EnvRing.PEc (...))
                         |} tt)) [] eq_refl
                   (VarMap.find BinNums.Z0
                      (VarMap.Branch
                         (VarMap.Elt
                            (BinInt.Z.of_nat (depth t)))
                         (BinInt.Z.of_nat (depth tm))
                         VarMap.Empty))
                   (ZifyClasses.rew_iff
                      (depth tm = depth t)
                      (BinInt.Z.of_nat (depth tm) =
                       BinInt.Z.of_nat (depth t))
                      (ZifyClasses.mkrel nat BinNums.Z
                         eq BinInt.Z.of_nat eq
                         (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                          iff_sym
                            (Znat.Nat2Z.inj_iff x y))
                         (depth tm)
                         (BinInt.Z.of_nat (depth tm))
                         eq_refl (depth t)
                         (BinInt.Z.of_nat (depth t))
                         eq_refl) pf))) eq_refl
             (<span class="kr">fun</span> (<span class="nv">x</span> : term atom atom)
                (<span class="nv">y</span> : term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) =&gt; y)
             DESTR_NEQ0)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl pf) pf&#39;)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chka8"><hr></label><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> b == x
   <span class="kr">then</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) 
      (<span class="kr">Œª</span><span class="nv">b</span>, t) eq_refl
   <span class="kr">else</span>
    <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
      rename&#39; l x y t
        (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
           (ZifyClasses.rew_iff_rev
              (depth t &lt; S (depth t))
              (BinInt.Z.lt 
                 (BinInt.Z.of_nat (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH)))
              (ZifyClasses.mkrel nat BinNums.Z lt
                 BinInt.Z.of_nat BinInt.Z.lt
                 Znat.Nat2Z.inj_lt 
                 (depth t) 
                 (BinInt.Z.of_nat (depth t)) eq_refl
                 (S (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH))
                 (ZifyClasses.mkapp nat nat BinNums.Z
                    BinNums.Z S BinInt.Z.of_nat
                    BinInt.Z.of_nat
                    (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                     BinInt.Z.add x
                     (BinNums.Zpos BinNums.xH))
                    Znat.Nat2Z.inj_succ 
                    (depth t)
                    (BinInt.Z.of_nat (depth t))
                    eq_refl))
              (ZMicromega.ZTautoChecker_sound
                 (Tauto.A Tauto.isProp
                    {|
                     RingMicromega.Flhs :=
                     EnvRing.PEX BinNums.xH;
                     RingMicromega.Fop :=
                     RingMicromega.OpLt;
                     RingMicromega.Frhs :=
                     EnvRing.PEadd
                     (EnvRing.PEX BinNums.xH)
                     (EnvRing.PEc
                     (BinNums.Zpos BinNums.xH))
                    |} tt) [] eq_refl
                 (VarMap.find BinNums.Z0
                    (VarMap.Elt
                     (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) 
      (<span class="kr">Œª</span><span class="nv">b</span>, tm)
      (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
         eq_refl pf)) = 
(<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chka9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
       (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
          (ZifyClasses.rew_iff_rev
             (depth t &lt; S (depth t))
             (BinInt.Z.lt (BinInt.Z.of_nat (depth t))
                (BinInt.Z.add
                   (BinInt.Z.of_nat (depth t))
                   (BinNums.Zpos BinNums.xH)))
             (ZifyClasses.mkrel nat BinNums.Z lt
                BinInt.Z.of_nat BinInt.Z.lt
                Znat.Nat2Z.inj_lt (depth t)
                (BinInt.Z.of_nat (depth t)) eq_refl
                (S (depth t))
                (BinInt.Z.add
                   (BinInt.Z.of_nat (depth t))
                   (BinNums.Zpos BinNums.xH))
                (ZifyClasses.mkapp nat nat BinNums.Z
                   BinNums.Z S BinInt.Z.of_nat
                   BinInt.Z.of_nat
                   (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                    BinInt.Z.add x
                      (BinNums.Zpos BinNums.xH))
                   Znat.Nat2Z.inj_succ (depth t)
                   (BinInt.Z.of_nat (depth t)) eq_refl))
             (ZMicromega.ZTautoChecker_sound
                (Tauto.A Tauto.isProp
                   {|
                     RingMicromega.Flhs :=
                       EnvRing.PEX BinNums.xH;
                     RingMicromega.Fop :=
                       RingMicromega.OpLt;
                     RingMicromega.Frhs :=
                       EnvRing.PEadd
                         (EnvRing.PEX BinNums.xH)
                         (EnvRing.PEc
                            (BinNums.Zpos BinNums.xH))
                   |} tt) [] eq_refl
                (VarMap.find BinNums.Z0
                   (VarMap.Elt
                      (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y tm
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
          (eq_ind_r
             (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
              (<span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
               term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) -&gt;
              b &lt;&gt; x -&gt; depth tm &lt; S (depth t))
             (<span class="kr">fun</span>
                (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) (<span class="nv">_</span> : y &lt;&gt; x)
              =&gt;
              ZifyClasses.rew_iff_rev
                (depth tm &lt; S (depth t))
                (BinInt.Z.lt
                   (BinInt.Z.of_nat (depth tm))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH)))
                (ZifyClasses.mkrel nat BinNums.Z lt
                   BinInt.Z.of_nat BinInt.Z.lt
                   Znat.Nat2Z.inj_lt (depth tm)
                   (BinInt.Z.of_nat (depth tm))
                   eq_refl (S (depth t))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH))
                   (ZifyClasses.mkapp nat nat
                      BinNums.Z BinNums.Z S
                      BinInt.Z.of_nat BinInt.Z.of_nat
                      (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                       BinInt.Z.add x
                         (BinNums.Zpos BinNums.xH))
                      Znat.Nat2Z.inj_succ (depth t)
                      (BinInt.Z.of_nat (depth t))
                      eq_refl))
                (ZMicromega.ZTautoChecker_sound
                   (Tauto.IMPL
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpEq;
                           RingMicromega.Frhs :=
                             EnvRing.PEX
                               (BinNums.xO BinNums.xH)
                         |} tt) None
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpLt;
                           RingMicromega.Frhs :=
                             EnvRing.PEadd
                               (EnvRing.PEX (...))
                               (EnvRing.PEc (...))
                         |} tt)) [] eq_refl
                   (VarMap.find BinNums.Z0
                      (VarMap.Branch
                         (VarMap.Elt
                            (BinInt.Z.of_nat (depth t)))
                         (BinInt.Z.of_nat (depth tm))
                         VarMap.Empty))
                   (ZifyClasses.rew_iff
                      (depth tm = depth t)
                      (BinInt.Z.of_nat (depth tm) =
                       BinInt.Z.of_nat (depth t))
                      (ZifyClasses.mkrel nat BinNums.Z
                         eq BinInt.Z.of_nat eq
                         (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                          iff_sym
                            (Znat.Nat2Z.inj_iff x y))
                         (depth tm)
                         (BinInt.Z.of_nat (depth tm))
                         eq_refl (depth t)
                         (BinInt.Z.of_nat (depth t))
                         eq_refl) pf))) eq_refl
             (<span class="kr">fun</span> (<span class="nv">x</span> : term atom atom)
                (<span class="nv">y</span> : term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) =&gt; y)
             DESTR_NEQ0)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl pf) pf&#39;)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkaa"><span class="nb">rewrite</span> normalize_rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
       (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t (term_lt_wf t) <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y tm
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
          (eq_ind_r
             (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
              (<span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
               term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) -&gt;
              b &lt;&gt; x -&gt; depth tm &lt; S (depth t))
             (<span class="kr">fun</span>
                (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) (<span class="nv">_</span> : y &lt;&gt; x)
              =&gt;
              ZifyClasses.rew_iff_rev
                (depth tm &lt; S (depth t))
                (BinInt.Z.lt
                   (BinInt.Z.of_nat (depth tm))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH)))
                (ZifyClasses.mkrel nat BinNums.Z lt
                   BinInt.Z.of_nat BinInt.Z.lt
                   Znat.Nat2Z.inj_lt (depth tm)
                   (BinInt.Z.of_nat (depth tm))
                   eq_refl (S (depth t))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH))
                   (ZifyClasses.mkapp nat nat
                      BinNums.Z BinNums.Z S
                      BinInt.Z.of_nat BinInt.Z.of_nat
                      (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                       BinInt.Z.add x
                         (BinNums.Zpos BinNums.xH))
                      Znat.Nat2Z.inj_succ (depth t)
                      (BinInt.Z.of_nat (depth t))
                      eq_refl))
                (ZMicromega.ZTautoChecker_sound
                   (Tauto.IMPL
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpEq;
                           RingMicromega.Frhs :=
                             EnvRing.PEX
                               (BinNums.xO BinNums.xH)
                         |} tt) None
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpLt;
                           RingMicromega.Frhs :=
                             EnvRing.PEadd
                               (EnvRing.PEX (...))
                               (EnvRing.PEc (...))
                         |} tt)) [] eq_refl
                   (VarMap.find BinNums.Z0
                      (VarMap.Branch
                         (VarMap.Elt
                            (BinInt.Z.of_nat (depth t)))
                         (BinInt.Z.of_nat (depth tm))
                         VarMap.Empty))
                   (ZifyClasses.rew_iff
                      (depth tm = depth t)
                      (BinInt.Z.of_nat (depth tm) =
                       BinInt.Z.of_nat (depth t))
                      (ZifyClasses.mkrel nat BinNums.Z
                         eq BinInt.Z.of_nat eq
                         (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                          iff_sym
                            (Znat.Nat2Z.inj_iff x y))
                         (depth tm)
                         (BinInt.Z.of_nat (depth tm))
                         eq_refl (depth t)
                         (BinInt.Z.of_nat (depth t))
                         eq_refl) pf))) eq_refl
             (<span class="kr">fun</span> (<span class="nv">x</span> : term atom atom)
                (<span class="nv">y</span> : term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) =&gt; y)
             DESTR_NEQ0)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl pf) pf&#39;)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkab"><span class="nb">pose</span> (sig_eta (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t (term_lt_wf t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
     (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
     (term_lt_wf t))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
  (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
  (term_lt_wf t) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
       (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t (term_lt_wf t) <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y tm
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
          (eq_ind_r
             (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
              (<span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
               term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) -&gt;
              b &lt;&gt; x -&gt; depth tm &lt; S (depth t))
             (<span class="kr">fun</span>
                (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) (<span class="nv">_</span> : y &lt;&gt; x)
              =&gt;
              ZifyClasses.rew_iff_rev
                (depth tm &lt; S (depth t))
                (BinInt.Z.lt
                   (BinInt.Z.of_nat (depth tm))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH)))
                (ZifyClasses.mkrel nat BinNums.Z lt
                   BinInt.Z.of_nat BinInt.Z.lt
                   Znat.Nat2Z.inj_lt (depth tm)
                   (BinInt.Z.of_nat (depth tm))
                   eq_refl (S (depth t))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH))
                   (ZifyClasses.mkapp nat nat
                      BinNums.Z BinNums.Z S
                      BinInt.Z.of_nat BinInt.Z.of_nat
                      (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                       BinInt.Z.add x
                         (BinNums.Zpos BinNums.xH))
                      Znat.Nat2Z.inj_succ (depth t)
                      (BinInt.Z.of_nat (depth t))
                      eq_refl))
                (ZMicromega.ZTautoChecker_sound
                   (Tauto.IMPL
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpEq;
                           RingMicromega.Frhs :=
                             EnvRing.PEX
                               (BinNums.xO BinNums.xH)
                         |} tt) None
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpLt;
                           RingMicromega.Frhs :=
                             EnvRing.PEadd
                               (EnvRing.PEX (...))
                               (EnvRing.PEc (...))
                         |} tt)) [] eq_refl
                   (VarMap.find BinNums.Z0
                      (VarMap.Branch
                         (VarMap.Elt
                            (BinInt.Z.of_nat (depth t)))
                         (BinInt.Z.of_nat (depth tm))
                         VarMap.Empty))
                   (ZifyClasses.rew_iff
                      (depth tm = depth t)
                      (BinInt.Z.of_nat (depth tm) =
                       BinInt.Z.of_nat (depth t))
                      (ZifyClasses.mkrel nat BinNums.Z
                         eq BinInt.Z.of_nat eq
                         (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                          iff_sym
                            (Znat.Nat2Z.inj_iff x y))
                         (depth tm)
                         (BinInt.Z.of_nat (depth tm))
                         eq_refl (depth t)
                         (BinInt.Z.of_nat (depth t))
                         eq_refl) pf))) eq_refl
             (<span class="kr">fun</span> (<span class="nv">x</span> : term atom atom)
                (<span class="nv">y</span> : term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) =&gt; y)
             DESTR_NEQ0)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl pf) pf&#39;)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkac"><span class="nb">rewrite</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
     (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
     (term_lt_wf t))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
  (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
  (term_lt_wf t) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
       (proj1_sig
          (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
             (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
             (term_lt_wf t)))
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">y</span>, t) a)
          (eq_ind_r
             (<span class="kr">fun</span> <span class="nv">b</span> : atom =&gt;
              (<span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
               term_lt x (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) -&gt;
              b &lt;&gt; x -&gt;
              depth
                (proj1_sig
                   (rename&#39;
                      (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                      y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                      (term_lt_wf t))) &lt; S (depth t))
             (<span class="kr">fun</span>
                (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">x</span> : term atom atom,
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt;
                     term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) (<span class="nv">_</span> : y &lt;&gt; x)
              =&gt;
              ZifyClasses.rew_iff_rev
                (depth
                   (proj1_sig
                      (rename&#39;
                         (l ++
                          [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                         (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                         (term_lt_wf t))) &lt;
                 S (depth t))
                (BinInt.Z.lt
                   (BinInt.Z.of_nat
                      (depth
                         (proj1_sig
                            (rename&#39;
                               (l ++ [<span class="kp">fresh</span> (...)]) y
                               (<span class="kp">fresh</span> ([x] ++ ...)) t
                               (term_lt_wf t)))))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH)))
                (ZifyClasses.mkrel nat BinNums.Z lt
                   BinInt.Z.of_nat BinInt.Z.lt
                   Znat.Nat2Z.inj_lt
                   (depth
                      (proj1_sig
                         (rename&#39;
                            (l ++
                             [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                            y
                            (<span class="kp">fresh</span> ([x] ++ l ++ [y]))
                            t (term_lt_wf t))))
                   (BinInt.Z.of_nat
                      (depth
                         (proj1_sig
                            (rename&#39;
                               (l ++ [<span class="kp">fresh</span> (...)]) y
                               (<span class="kp">fresh</span> ([x] ++ ...)) t
                               (term_lt_wf t)))))
                   eq_refl (S (depth t))
                   (BinInt.Z.add
                      (BinInt.Z.of_nat (depth t))
                      (BinNums.Zpos BinNums.xH))
                   (ZifyClasses.mkapp nat nat
                      BinNums.Z BinNums.Z S
                      BinInt.Z.of_nat BinInt.Z.of_nat
                      (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                       BinInt.Z.add x
                         (BinNums.Zpos BinNums.xH))
                      Znat.Nat2Z.inj_succ (depth t)
                      (BinInt.Z.of_nat (depth t))
                      eq_refl))
                (ZMicromega.ZTautoChecker_sound
                   (Tauto.IMPL
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpEq;
                           RingMicromega.Frhs :=
                             EnvRing.PEX
                               (BinNums.xO BinNums.xH)
                         |} tt) None
                      (Tauto.A Tauto.isProp
                         {|
                           RingMicromega.Flhs :=
                             EnvRing.PEX BinNums.xH;
                           RingMicromega.Fop :=
                             RingMicromega.OpLt;
                           RingMicromega.Frhs :=
                             EnvRing.PEadd
                               (EnvRing.PEX
                                  (BinNums.xO
                                     BinNums.xH))
                               (EnvRing.PEc
                                  (BinNums.Zpos
                                     BinNums.xH))
                         |} tt)) [] eq_refl
                   (VarMap.find BinNums.Z0
                      (VarMap.Branch
                         (VarMap.Elt
                            (BinInt.Z.of_nat (depth t)))
                         (BinInt.Z.of_nat
                            (depth
                               (proj1_sig
                                  (rename&#39; ... y ... t
                                     ...))))
                         VarMap.Empty))
                   (ZifyClasses.rew_iff
                      (depth
                         (proj1_sig
                            (rename&#39;
                               (l ++ [<span class="kp">fresh</span> ...]) y
                               (<span class="kp">fresh</span> (...)) t
                               (term_lt_wf t))) =
                       depth t)
                      (BinInt.Z.of_nat
                         (depth
                            (proj1_sig
                               (rename&#39; (...) y (...)
                                  t (...)))) =
                       BinInt.Z.of_nat (depth t))
                      (ZifyClasses.mkrel nat BinNums.Z
                         eq BinInt.Z.of_nat eq
                         (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : nat =&gt;
                          iff_sym
                            (Znat.Nat2Z.inj_iff x y))
                         (depth
                            (proj1_sig
                               (rename&#39; (l ++ [...]) y
                                  (<span class="kp">fresh</span> ...) t
                                  (term_lt_wf t))))
                         (BinInt.Z.of_nat
                            (depth
                               (proj1_sig
                                  (rename&#39; ... y ... t
                                     ...)))) eq_refl
                         (depth t)
                         (BinInt.Z.of_nat (depth t))
                         eq_refl)
                      (proj2_sig
                         (rename&#39;
                            (l ++
                             [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                            y
                            (<span class="kp">fresh</span> ([x] ++ l ++ [y]))
                            t (term_lt_wf t))))))
             eq_refl
             (<span class="kr">fun</span> (<span class="nv">x</span> : term atom atom)
                (<span class="nv">y</span> : term_lt x (<span class="kr">Œª</span><span class="nv">y</span>, t)) =&gt; y)
             DESTR_NEQ0)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl
           (proj2_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                 (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t)))) pf&#39;)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkad"><span class="nb">rewrite</span> normalize_rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
     (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
     (term_lt_wf t))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
  (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
  (term_lt_wf t) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
       (proj1_sig
          (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
             (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
             (term_lt_wf t)))
       (term_lt_wf
          (proj1_sig
             (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                (term_lt_wf t)))) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl
           (proj2_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                 (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t)))) pf&#39;)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkae"><span class="nb">pose</span> (sig_eta
                  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
                     (proj1_sig (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t (term_lt_wf t)))
                     (term_lt_wf (proj1_sig (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t (term_lt_wf t)))))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
     (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
     (term_lt_wf t))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
  (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
  (term_lt_wf t) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))</span></span></span></span><br><span><var>e0</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
     (proj1_sig
        (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
           y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
           (term_lt_wf t)))
     (term_lt_wf
        (proj1_sig
           (rename&#39;
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
              (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
              (term_lt_wf t)))))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
        (term_lt_wf t)))
  (term_lt_wf
     (proj1_sig
        (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
           y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
           (term_lt_wf t)))) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
    depth u =
    depth
      (proj1_sig
         (rename&#39;
            (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
            (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
            (term_lt_wf t)))) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x
        y
        (proj1_sig
           (rename&#39;
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
              (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
              (term_lt_wf t)))
        (term_lt_wf
           (proj1_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                 y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t))))))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x
        y
        (proj1_sig
           (rename&#39;
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
              (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
              (term_lt_wf t)))
        (term_lt_wf
           (proj1_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                 y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t))))))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm&#39;</span>, pf&#39;) :=
     rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
       (proj1_sig
          (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
             (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
             (term_lt_wf t)))
       (term_lt_wf
          (proj1_sig
             (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                (term_lt_wf t)))) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), tm&#39;)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl
           (proj2_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                 (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t)))) pf&#39;)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkaf"><span class="nb">rewrite</span> e0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
     (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
     (term_lt_wf t))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
  (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
  (term_lt_wf t) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))</span></span></span></span><br><span><var>e0</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
     (proj1_sig
        (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
           y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
           (term_lt_wf t)))
     (term_lt_wf
        (proj1_sig
           (rename&#39;
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
              (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
              (term_lt_wf t)))))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
        (term_lt_wf t)))
  (term_lt_wf
     (proj1_sig
        (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
           y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
           (term_lt_wf t)))) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
    depth u =
    depth
      (proj1_sig
         (rename&#39;
            (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
            (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
            (term_lt_wf t)))) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x
        y
        (proj1_sig
           (rename&#39;
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
              (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
              (term_lt_wf t)))
        (term_lt_wf
           (proj1_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                 y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t))))))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x
        y
        (proj1_sig
           (rename&#39;
              (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
              (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
              (term_lt_wf t)))
        (term_lt_wf
           (proj1_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                 y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t))))))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), proj1_sig
                                  (rename&#39;
                                     (l ++
                                      [<span class="kp">fresh</span>
                                         ([x] ++
                                          l ++ [y])])
                                     x y
                                     (proj1_sig
                                        (rename&#39;
                                           (l ++
                                            [<span class="kp">fresh</span>
                                               ([x] ++
                                                l ++
                                                [y])])
                                           y
                                           (<span class="kp">fresh</span>
                                              ([x] ++
                                               l ++
                                               [y])) t
                                           (term_lt_wf
                                              t)))
                                     (term_lt_wf
                                        (proj1_sig
                                           (rename&#39;
                                              (l ++
                                               [<span class="kp">fresh</span>
                                                 ([x] ++
                                                 l ++
                                                 [y])])
                                              y
                                              (<span class="kp">fresh</span>
                                                 ([x] ++
                                                 l ++
                                                 [y]))
                                              t
                                              (term_lt_wf
                                                 t))))))
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl
           (proj2_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                 (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t))))
        (proj2_sig
           (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x
              y
              (proj1_sig
                 (rename&#39;
                    (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                    (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                    (term_lt_wf t)))
              (term_lt_wf
                 (proj1_sig
                    (rename&#39;
                       (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                       y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                       (term_lt_wf t)))))))) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb0"><span class="nb">clear</span> e0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
     (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
     (term_lt_wf t))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
  (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
  (term_lt_wf t) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t) a)
  (proj1_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))
  (proj2_sig
     (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
        (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t 
        (term_lt_wf t)))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), proj1_sig
                                  (rename&#39;
                                     (l ++
                                      [<span class="kp">fresh</span>
                                         ([x] ++
                                          l ++ [y])])
                                     x y
                                     (proj1_sig
                                        (rename&#39;
                                           (l ++
                                            [<span class="kp">fresh</span>
                                               ([x] ++
                                                l ++
                                                [y])])
                                           y
                                           (<span class="kp">fresh</span>
                                              ([x] ++
                                               l ++
                                               [y])) t
                                           (term_lt_wf
                                              t)))
                                     (term_lt_wf
                                        (proj1_sig
                                           (rename&#39;
                                              (l ++
                                               [<span class="kp">fresh</span>
                                                 ([x] ++
                                                 l ++
                                                 [y])])
                                              y
                                              (<span class="kp">fresh</span>
                                                 ([x] ++
                                                 l ++
                                                 [y]))
                                              t
                                              (term_lt_wf
                                                 t))))))
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl
           (proj2_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                 (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t))))
        (proj2_sig
           (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x
              y
              (proj1_sig
                 (rename&#39;
                    (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                    (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                    (term_lt_wf t)))
              (term_lt_wf
                 (proj1_sig
                    (rename&#39;
                       (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                       y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                       (term_lt_wf t)))))))) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb1"><span class="nb">clear</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">y</span>, t))
     (<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), proj1_sig
                                  (rename&#39;
                                     (l ++
                                      [<span class="kp">fresh</span>
                                         ([x] ++
                                          l ++ [y])])
                                     x y
                                     (proj1_sig
                                        (rename&#39;
                                           (l ++
                                            [<span class="kp">fresh</span>
                                               ([x] ++
                                                l ++
                                                [y])])
                                           y
                                           (<span class="kp">fresh</span>
                                              ([x] ++
                                               l ++
                                               [y])) t
                                           (term_lt_wf
                                              t)))
                                     (term_lt_wf
                                        (proj1_sig
                                           (rename&#39;
                                              (l ++
                                               [<span class="kp">fresh</span>
                                                 ([x] ++
                                                 l ++
                                                 [y])])
                                              y
                                              (<span class="kp">fresh</span>
                                                 ([x] ++
                                                 l ++
                                                 [y]))
                                              t
                                              (term_lt_wf
                                                 t))))))
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
           eq_refl
           (proj2_sig
              (rename&#39;
                 (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                 (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                 (term_lt_wf t))))
        (proj2_sig
           (rename&#39; (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x
              y
              (proj1_sig
                 (rename&#39;
                    (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y
                    (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                    (term_lt_wf t)))
              (term_lt_wf
                 (proj1_sig
                    (rename&#39;
                       (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                       y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t
                       (term_lt_wf t)))))))) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb2"><span class="nb">unfold</span> proj1_sig.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y0</span> : term atom atom,
term_lt y0 (<span class="kr">Œª</span><span class="nv">y</span>, t) -&gt; Acc term_lt y0</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>y = y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), (<span class="kr">let</span> (<span class="nv">a</span>, _) :=
                              rename&#39;
                                (l ++
                                 [<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y])])
                                x y
                                (<span class="kr">let</span> (<span class="nv">a</span>, _) :=
                                   rename&#39;
                                     (l ++
                                      [<span class="kp">fresh</span>
                                         ([x] ++
                                          l ++ [y])])
                                     y
                                     (<span class="kp">fresh</span>
                                        ([x] ++
                                         l ++ [y])) t
                                     (term_lt_wf t) <span class="kr">in</span>
                                 a)
                                (term_lt_wf
                                   (<span class="kr">let</span> (<span class="nv">a</span>, _) :=
                                      rename&#39;
                                        (l ++
                                         [<span class="kp">fresh</span>
                                            ([x] ++
                                             l ++ [y])])
                                        y
                                        (<span class="kp">fresh</span>
                                           ([x] ++
                                            l ++ [y]))
                                        t
                                        (term_lt_wf t) <span class="kr">in</span>
                                    a)) <span class="kr">in</span>
                            a)) =
(<span class="kr">Œª</span><span class="nv">fresh</span> (<span class="nv">x</span> :: l ++ [y]), <span class="nb">rename</span>
                           (l ++
                            [<span class="kp">fresh</span> (x :: l ++ [y])]) x
                           y
                           (<span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span> (x :: l ++ [y])])
                              y
                              (<span class="kp">fresh</span> (x :: l ++ [y]))
                              t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> b == x
   <span class="kr">then</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, t) eq_refl
   <span class="kr">else</span>
    <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
      rename&#39; l x y t
        (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
           (ZifyClasses.rew_iff_rev
              (depth t &lt; S (depth t))
              (BinInt.Z.lt (BinInt.Z.of_nat (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH)))
              (ZifyClasses.mkrel nat BinNums.Z lt
                 BinInt.Z.of_nat BinInt.Z.lt
                 Znat.Nat2Z.inj_lt (depth t)
                 (BinInt.Z.of_nat (depth t)) eq_refl
                 (S (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH))
                 (ZifyClasses.mkapp nat nat BinNums.Z
                    BinNums.Z S BinInt.Z.of_nat
                    BinInt.Z.of_nat
                    (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                     BinInt.Z.add x
                       (BinNums.Zpos BinNums.xH))
                    Znat.Nat2Z.inj_succ (depth t)
                    (BinInt.Z.of_nat (depth t))
                    eq_refl))
              (ZMicromega.ZTautoChecker_sound
                 (Tauto.A Tauto.isProp
                    {|
                      RingMicromega.Flhs :=
                        EnvRing.PEX BinNums.xH;
                      RingMicromega.Fop :=
                        RingMicromega.OpLt;
                      RingMicromega.Frhs :=
                        EnvRing.PEadd
                          (EnvRing.PEX BinNums.xH)
                          (EnvRing.PEc
                             (BinNums.Zpos BinNums.xH))
                    |} tt) [] eq_refl
                 (VarMap.find BinNums.Z0
                    (VarMap.Elt
                       (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, tm)
      (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
         eq_refl pf)) = (<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> b == x
   <span class="kr">then</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, t) eq_refl
   <span class="kr">else</span>
    <span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
      rename&#39; l x y t
        (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
           (ZifyClasses.rew_iff_rev
              (depth t &lt; S (depth t))
              (BinInt.Z.lt (BinInt.Z.of_nat (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH)))
              (ZifyClasses.mkrel nat BinNums.Z lt
                 BinInt.Z.of_nat BinInt.Z.lt
                 Znat.Nat2Z.inj_lt (depth t)
                 (BinInt.Z.of_nat (depth t)) eq_refl
                 (S (depth t))
                 (BinInt.Z.add
                    (BinInt.Z.of_nat (depth t))
                    (BinNums.Zpos BinNums.xH))
                 (ZifyClasses.mkapp nat nat BinNums.Z
                    BinNums.Z S BinInt.Z.of_nat
                    BinInt.Z.of_nat
                    (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                     BinInt.Z.add x
                       (BinNums.Zpos BinNums.xH))
                    Znat.Nat2Z.inj_succ (depth t)
                    (BinInt.Z.of_nat (depth t))
                    eq_refl))
              (ZMicromega.ZTautoChecker_sound
                 (Tauto.A Tauto.isProp
                    {|
                      RingMicromega.Flhs :=
                        EnvRing.PEX BinNums.xH;
                      RingMicromega.Fop :=
                        RingMicromega.OpLt;
                      RingMicromega.Frhs :=
                        EnvRing.PEadd
                          (EnvRing.PEX BinNums.xH)
                          (EnvRing.PEc
                             (BinNums.Zpos BinNums.xH))
                    |} tt) [] eq_refl
                 (VarMap.find BinNums.Z0
                    (VarMap.Elt
                       (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
       depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, tm)
      (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
         eq_refl pf)) = (<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb5">destruct_eq_args b x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br><span><var>DESTR_NEQ1</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs1</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm</span>, pf) :=
     rename&#39; l x y t
       (Acc_inv (Acc_intro (<span class="kr">Œª</span><span class="nv">b</span>, t) a)
          (ZifyClasses.rew_iff_rev
             (depth t &lt; S (depth t))
             (BinInt.Z.lt (BinInt.Z.of_nat (depth t))
                (BinInt.Z.add
                   (BinInt.Z.of_nat (depth t))
                   (BinNums.Zpos BinNums.xH)))
             (ZifyClasses.mkrel nat BinNums.Z lt
                BinInt.Z.of_nat BinInt.Z.lt
                Znat.Nat2Z.inj_lt (depth t)
                (BinInt.Z.of_nat (depth t)) eq_refl
                (S (depth t))
                (BinInt.Z.add
                   (BinInt.Z.of_nat (depth t))
                   (BinNums.Zpos BinNums.xH))
                (ZifyClasses.mkapp nat nat BinNums.Z
                   BinNums.Z S BinInt.Z.of_nat
                   BinInt.Z.of_nat
                   (<span class="kr">fun</span> <span class="nv">x</span> : BinNums.Z =&gt;
                    BinInt.Z.add x
                      (BinNums.Zpos BinNums.xH))
                   Znat.Nat2Z.inj_succ (depth t)
                   (BinInt.Z.of_nat (depth t)) eq_refl))
             (ZMicromega.ZTautoChecker_sound
                (Tauto.A Tauto.isProp
                   {|
                     RingMicromega.Flhs :=
                       EnvRing.PEX BinNums.xH;
                     RingMicromega.Fop :=
                       RingMicromega.OpLt;
                     RingMicromega.Frhs :=
                       EnvRing.PEadd
                         (EnvRing.PEX BinNums.xH)
                         (EnvRing.PEc
                            (BinNums.Zpos BinNums.xH))
                   |} tt) [] eq_refl
                (VarMap.find BinNums.Z0
                   (VarMap.Elt
                      (BinInt.Z.of_nat (depth t))))))) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, tm)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        eq_refl pf)) = (<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb6"><span class="nb">rewrite</span> normalize_rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br><span><var>DESTR_NEQ1</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs1</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">tm</span>, pf) := rename&#39; l x y t (term_lt_wf t) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t)) (<span class="kr">Œª</span><span class="nv">b</span>, tm)
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        eq_refl pf)) = (<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb7"><span class="nb">rewrite</span> (sig_eta (rename&#39; l x y t (term_lt_wf t) )).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br><span><var>DESTR_NEQ1</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs1</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (<span class="kr">Œª</span><span class="nv">b</span>, t))
     (<span class="kr">Œª</span><span class="nv">b</span>, proj1_sig (rename&#39; l x y t (term_lt_wf t)))
     (eq_ind_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; S n = S (depth t))
        eq_refl
        (proj2_sig (rename&#39; l x y t (term_lt_wf t))))) =
(<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), <span class="nb">rename</span> l x y t = rename_iter l x y t</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (<span class="kr">Œª</span><span class="nv">b</span>, t) -&gt; Acc term_lt y</span></span></span><br><span><var>DESTR_NEQ0</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; y)%type</span></span></span><br><span><var>DESTR_NEQs0</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; b)%type</span></span></span><br><span><var>DESTR_NEQ1</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs1</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">Œª</span><span class="nv">b</span>, proj1_sig (rename&#39; l x y t (term_lt_wf t))) =
(<span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input">fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (t1¬∑t2) (term_lt_wf (t1¬∑t2))) =
rename_iter l x y (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkba"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y (t1¬∑t2) (term_lt_wf (t1¬∑t2))) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkbb"><span class="nb">destruct</span> (term_lt_wf (tap t1 t2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (rename&#39; l x y (t1¬∑t2) (Acc_intro (t1¬∑t2) a)) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkbc"><span class="nb">unfold</span> rename&#39;; <span class="nb">fold</span> rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">t1&#39;</span>, pf1&#39;) :=
     rename&#39; l x y t1
       (Acc_inv (Acc_intro (t1¬∑t2) a)
          (tap_depth1 t1 t2)) <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">t2&#39;</span>, pf2&#39;) :=
     rename&#39; l x y t2
       (Acc_inv (Acc_intro (t1¬∑t2) a)
          (tap_depth2 t1 t2)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (t1¬∑t2)) (t1&#39;¬∑t2&#39;)
     (eq_ind_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         n = depth t1 -&gt;
         depth t2&#39; = depth t2 -&gt;
         S (Nat.max n (depth t2&#39;)) =
         S (Nat.max (depth t1) (depth t2)))
        (eq_ind_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
            depth t1 = depth t1 -&gt;
            n = depth t2 -&gt;
            S (Nat.max (depth t1) n) =
            S (Nat.max (depth t1) (depth t2)))
           (<span class="kr">fun</span> (<span class="nv">_</span> : depth t1 = depth t1)
              (<span class="nv">_</span> : depth t2 = depth t2) =&gt; eq_refl)
           pf2&#39;) pf1&#39; pf1&#39; pf2&#39;)) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkbd"><span class="nb">pose</span> (sig_eta (rename&#39; l x y t1 (Acc_inv (Acc_intro (tap t1 t2) a) (tap_depth1 t1 t2)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t1
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth1 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t1
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth1 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t1)
     a)
  (proj1_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">t1&#39;</span>, pf1&#39;) :=
     rename&#39; l x y t1
       (Acc_inv (Acc_intro (t1¬∑t2) a)
          (tap_depth1 t1 t2)) <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">t2&#39;</span>, pf2&#39;) :=
     rename&#39; l x y t2
       (Acc_inv (Acc_intro (t1¬∑t2) a)
          (tap_depth2 t1 t2)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (t1¬∑t2)) (t1&#39;¬∑t2&#39;)
     (eq_ind_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         n = depth t1 -&gt;
         depth t2&#39; = depth t2 -&gt;
         S (Nat.max n (depth t2&#39;)) =
         S (Nat.max (depth t1) (depth t2)))
        (eq_ind_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
            depth t1 = depth t1 -&gt;
            n = depth t2 -&gt;
            S (Nat.max (depth t1) n) =
            S (Nat.max (depth t1) (depth t2)))
           (<span class="kr">fun</span> (<span class="nv">_</span> : depth t1 = depth t1)
              (<span class="nv">_</span> : depth t2 = depth t2) =&gt; eq_refl)
           pf2&#39;) pf1&#39; pf1&#39; pf2&#39;)) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkbe"><span class="nb">pose</span> (sig_eta (rename&#39; l x y t2 (Acc_inv (Acc_intro (tap t1 t2) a) (tap_depth2 t1 t2)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t1
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth1 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t1
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth1 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t1)
     a)
  (proj1_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))</span></span></span></span><br><span><var>e0</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t2
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth2 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t2
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth2 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t2)
     a)
  (proj1_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">t1&#39;</span>, pf1&#39;) :=
     rename&#39; l x y t1
       (Acc_inv (Acc_intro (t1¬∑t2) a)
          (tap_depth1 t1 t2)) <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">t2&#39;</span>, pf2&#39;) :=
     rename&#39; l x y t2
       (Acc_inv (Acc_intro (t1¬∑t2) a)
          (tap_depth2 t1 t2)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (t1¬∑t2)) (t1&#39;¬∑t2&#39;)
     (eq_ind_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         n = depth t1 -&gt;
         depth t2&#39; = depth t2 -&gt;
         S (Nat.max n (depth t2&#39;)) =
         S (Nat.max (depth t1) (depth t2)))
        (eq_ind_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
            depth t1 = depth t1 -&gt;
            n = depth t2 -&gt;
            S (Nat.max (depth t1) n) =
            S (Nat.max (depth t1) (depth t2)))
           (<span class="kr">fun</span> (<span class="nv">_</span> : depth t1 = depth t1)
              (<span class="nv">_</span> : depth t2 = depth t2) =&gt; eq_refl)
           pf2&#39;) pf1&#39; pf1&#39; pf2&#39;)) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkbf"><span class="nb">rewrite</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t1
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth1 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t1
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth1 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t1)
     a)
  (proj1_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))</span></span></span></span><br><span><var>e0</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t2
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth2 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t2
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth2 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t2)
     a)
  (proj1_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">let</span> (<span class="nv">t2&#39;</span>, pf2&#39;) :=
     rename&#39; l x y t2
       (Acc_inv (Acc_intro (t1¬∑t2) a)
          (tap_depth2 t1 t2)) <span class="kr">in</span>
   exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (t1¬∑t2))
     (proj1_sig
        (rename&#39; l x y t1
           (Acc_inv (Acc_intro (t1¬∑t2) a)
              (tap_depth1 t1 t2)))¬∑t2&#39;)
     (eq_ind_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         n = depth t1 -&gt;
         depth t2&#39; = depth t2 -&gt;
         S (Nat.max n (depth t2&#39;)) =
         S (Nat.max (depth t1) (depth t2)))
        (eq_ind_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
            depth t1 = depth t1 -&gt;
            n = depth t2 -&gt;
            S (Nat.max (depth t1) n) =
            S (Nat.max (depth t1) (depth t2)))
           (<span class="kr">fun</span> (<span class="nv">_</span> : depth t1 = depth t1)
              (<span class="nv">_</span> : depth t2 = depth t2) =&gt; eq_refl)
           pf2&#39;)
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2))))
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2)))) pf2&#39;)) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc0"><span class="nb">rewrite</span> e0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t1
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth1 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t1
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth1 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t1)
     a)
  (proj1_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t1
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth1 t1 t2))))</span></span></span></span><br><span><var>e0</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t2
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth2 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t2
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth2 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t2)
     a)
  (proj1_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (t1¬∑t2))
     (proj1_sig
        (rename&#39; l x y t1
           (Acc_inv (Acc_intro (t1¬∑t2) a)
              (tap_depth1 t1 t2)))¬∑proj1_sig
                                     (rename&#39; l x y t2
                                        (Acc_inv
                                           (Acc_intro
                                              (t1¬∑t2)
                                              a)
                                           (tap_depth2
                                              t1 t2))))
     (eq_ind_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         n = depth t1 -&gt;
         depth
           (proj1_sig
              (rename&#39; l x y t2
                 (Acc_inv (Acc_intro (t1¬∑t2) a)
                    (tap_depth2 t1 t2)))) = depth t2 -&gt;
         S
           (Nat.max n
              (depth
                 (proj1_sig
                    (rename&#39; l x y t2
                       (Acc_inv (Acc_intro (t1¬∑t2) a)
                          (tap_depth2 t1 t2)))))) =
         S (Nat.max (depth t1) (depth t2)))
        (eq_ind_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
            depth t1 = depth t1 -&gt;
            n = depth t2 -&gt;
            S (Nat.max (depth t1) n) =
            S (Nat.max (depth t1) (depth t2)))
           (<span class="kr">fun</span> (<span class="nv">_</span> : depth t1 = depth t1)
              (<span class="nv">_</span> : depth t2 = depth t2) =&gt; eq_refl)
           (proj2_sig
              (rename&#39; l x y t2
                 (Acc_inv (Acc_intro (t1¬∑t2) a)
                    (tap_depth2 t1 t2)))))
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2))))
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2))))
        (proj2_sig
           (rename&#39; l x y t2
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth2 t1 t2)))))) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc1"><span class="nb">clear</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br><span><var>e0</var><span><span class="hyp-body"><b>:= </b><span>sig_eta
  (rename&#39; l x y t2
     (Acc_inv (Acc_intro (t1¬∑t2) a)
        (tap_depth2 t1 t2)))</span></span><span class="hyp-type"><b>: </b><span>rename&#39; l x y t2
  (Acc_inv (Acc_intro (t1¬∑t2) a)
     (tap_depth2 t1 t2)) =
exist
  (<span class="kr">fun</span> <span class="nv">a</span> : term atom atom =&gt;
   (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth t2)
     a)
  (proj1_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))
  (proj2_sig
     (rename&#39; l x y t2
        (Acc_inv (Acc_intro (t1¬∑t2) a)
           (tap_depth2 t1 t2))))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (t1¬∑t2))
     (proj1_sig
        (rename&#39; l x y t1
           (Acc_inv (Acc_intro (t1¬∑t2) a)
              (tap_depth1 t1 t2)))¬∑proj1_sig
                                     (rename&#39; l x y t2
                                        (Acc_inv
                                           (Acc_intro
                                              (t1¬∑t2)
                                              a)
                                           (tap_depth2
                                              t1 t2))))
     (eq_ind_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         n = depth t1 -&gt;
         depth
           (proj1_sig
              (rename&#39; l x y t2
                 (Acc_inv (Acc_intro (t1¬∑t2) a)
                    (tap_depth2 t1 t2)))) = depth t2 -&gt;
         S
           (Nat.max n
              (depth
                 (proj1_sig
                    (rename&#39; l x y t2
                       (Acc_inv (Acc_intro (t1¬∑t2) a)
                          (tap_depth2 t1 t2)))))) =
         S (Nat.max (depth t1) (depth t2)))
        (eq_ind_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
            depth t1 = depth t1 -&gt;
            n = depth t2 -&gt;
            S (Nat.max (depth t1) n) =
            S (Nat.max (depth t1) (depth t2)))
           (<span class="kr">fun</span> (<span class="nv">_</span> : depth t1 = depth t1)
              (<span class="nv">_</span> : depth t2 = depth t2) =&gt; eq_refl)
           (proj2_sig
              (rename&#39; l x y t2
                 (Acc_inv (Acc_intro (t1¬∑t2) a)
                    (tap_depth2 t1 t2)))))
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2))))
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2))))
        (proj2_sig
           (rename&#39; l x y t2
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth2 t1 t2)))))) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc2"><span class="nb">clear</span> e0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (exist
     (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt;
      depth u = depth (t1¬∑t2))
     (proj1_sig
        (rename&#39; l x y t1
           (Acc_inv (Acc_intro (t1¬∑t2) a)
              (tap_depth1 t1 t2)))¬∑proj1_sig
                                     (rename&#39; l x y t2
                                        (Acc_inv
                                           (Acc_intro
                                              (t1¬∑t2)
                                              a)
                                           (tap_depth2
                                              t1 t2))))
     (eq_ind_r
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
         n = depth t1 -&gt;
         depth
           (proj1_sig
              (rename&#39; l x y t2
                 (Acc_inv (Acc_intro (t1¬∑t2) a)
                    (tap_depth2 t1 t2)))) = depth t2 -&gt;
         S
           (Nat.max n
              (depth
                 (proj1_sig
                    (rename&#39; l x y t2
                       (Acc_inv (Acc_intro (t1¬∑t2) a)
                          (tap_depth2 t1 t2)))))) =
         S (Nat.max (depth t1) (depth t2)))
        (eq_ind_r
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
            depth t1 = depth t1 -&gt;
            n = depth t2 -&gt;
            S (Nat.max (depth t1) n) =
            S (Nat.max (depth t1) (depth t2)))
           (<span class="kr">fun</span> (<span class="nv">_</span> : depth t1 = depth t1)
              (<span class="nv">_</span> : depth t2 = depth t2) =&gt; eq_refl)
           (proj2_sig
              (rename&#39; l x y t2
                 (Acc_inv (Acc_intro (t1¬∑t2) a)
                    (tap_depth2 t1 t2)))))
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2))))
        (proj2_sig
           (rename&#39; l x y t1
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth1 t1 t2))))
        (proj2_sig
           (rename&#39; l x y t2
              (Acc_inv (Acc_intro (t1¬∑t2) a)
                 (tap_depth2 t1 t2)))))) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y t1 (a t1 (tap_depth1 t1 t2)))¬∑
proj1_sig (rename&#39; l x y t2 (a t2 (tap_depth2 t1 t2))) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc4"><span class="nb">rewrite</span> normalize_rename1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y t1¬∑proj1_sig
                  (rename&#39; l x y t2
                     (a t2 (tap_depth2 t1 t2))) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc5"><span class="nb">rewrite</span> normalize_rename1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t1 = rename_iter l x y t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
<span class="nb">rename</span> l x y t2 = rename_iter l x y t2</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y (t1¬∑t2) -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2 =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc6"><span class="kn">Lemma</span> <span class="nf">rename_rw1</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">v</span>,
      <span class="nb">rename</span> l x y (tvar v) = tvar (<span class="kr">if</span> v == x <span class="kr">then</span> y <span class="kr">else</span> v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">v</span> : atom),
<span class="nb">rename</span> l x y `v = `(<span class="kr">if</span> v == x <span class="kr">then</span> y <span class="kr">else</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">v</span> : atom),
<span class="nb">rename</span> l x y `v = `(<span class="kr">if</span> v == x <span class="kr">then</span> y <span class="kr">else</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y `v = `(<span class="kr">if</span> v == x <span class="kr">then</span> y <span class="kr">else</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkc9"><span class="nb">unfold</span> <span class="nb">rename</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (term_lt_wf `v)) =
`(<span class="kr">if</span> v == x <span class="kr">then</span> y <span class="kr">else</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkca"><span class="nb">destruct</span> (term_lt_wf (tvar v)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig (rename&#39; l x y `v (Acc_intro `v a)) =
`(<span class="kr">if</span> v == x <span class="kr">then</span> y <span class="kr">else</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkcb"><span class="nb">unfold</span> rename&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : term atom atom,
term_lt y `v -&gt; Acc term_lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proj1_sig
  (<span class="kr">if</span> x == v
   <span class="kr">then</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth `v)
      `y eq_refl
   <span class="kr">else</span>
    exist
      (<span class="kr">fun</span> <span class="nv">u</span> : term atom atom =&gt; depth u = depth `v)
      `v eq_refl) = `(<span class="kr">if</span> v == x <span class="kr">then</span> y <span class="kr">else</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args x v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkcc"><span class="kn">Lemma</span> <span class="nf">rename_rw2_eq</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">b</span> <span class="nv">t</span>,
      b = x -&gt;
      <span class="nb">rename</span> l x y (lam b t) =
        lam b t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">b</span> : atom)
  (<span class="nv">t</span> : term atom atom),
b = x -&gt; <span class="nb">rename</span> l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) = (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkcd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">b</span> : atom)
  (<span class="nv">t</span> : term atom atom),
b = x -&gt; <span class="nb">rename</span> l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) = (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkce"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>b = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) = (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkcf"><span class="nb">rewrite</span> rename_eq_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>b = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename_iter l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) = (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd0"><span class="nb">unfold</span> rename_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>b = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">if</span> b == y
  <span class="kr">then</span>
   <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), <span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span>
                                   ([x] ++ l ++ [b])])
                               x y
                               (<span class="nb">rename</span>
                                  (l ++
                                   [<span class="kp">fresh</span>
                                      ([x] ++ l ++ [b])])
                                  b
                                  (<span class="kp">fresh</span>
                                     ([x] ++ l ++ [b]))
                                  t)
  <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t) = (<span class="kr">Œª</span><span class="nv">b</span>, t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args b x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd1"><span class="kn">Lemma</span> <span class="nf">rename_rw2_neq</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">b</span> <span class="nv">t</span>,
      b &lt;&gt; x -&gt;
      b = y -&gt;
      <span class="nb">rename</span> l x y (lam b t) =
        (lam (<span class="kp">fresh</span> ([x] ++ l ++ [y]))
           (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) x y
              (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [y])]) y (<span class="kp">fresh</span> ([x] ++ l ++ [y])) t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">b</span> : atom)
  (<span class="nv">t</span> : term atom atom),
b &lt;&gt; x -&gt;
b = y -&gt;
<span class="nb">rename</span> l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) =
(<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), <span class="nb">rename</span>
                             (l ++
                              [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                             x y
                             (<span class="nb">rename</span>
                                (l ++
                                 [<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y])])
                                y
                                (<span class="kp">fresh</span>
                                   ([x] ++ l ++ [y]))
                                t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">b</span> : atom)
  (<span class="nv">t</span> : term atom atom),
b &lt;&gt; x -&gt;
b = y -&gt;
<span class="nb">rename</span> l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) =
(<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), <span class="nb">rename</span>
                             (l ++
                              [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                             x y
                             (<span class="nb">rename</span>
                                (l ++
                                 [<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y])])
                                y
                                (<span class="kp">fresh</span>
                                   ([x] ++ l ++ [y]))
                                t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) =
(<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), <span class="nb">rename</span>
                             (l ++
                              [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                             x y
                             (<span class="nb">rename</span>
                                (l ++
                                 [<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y])])
                                y
                                (<span class="kp">fresh</span>
                                   ([x] ++ l ++ [y]))
                                t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd4"><span class="nb">rewrite</span> rename_eq_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename_iter l x y (<span class="kr">Œª</span><span class="nv">b</span>, t) =
(<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), <span class="nb">rename</span>
                             (l ++
                              [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                             x y
                             (<span class="nb">rename</span>
                                (l ++
                                 [<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y])])
                                y
                                (<span class="kp">fresh</span>
                                   ([x] ++ l ++ [y]))
                                t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd5"><span class="nb">unfold</span> rename_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y, b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>b = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">if</span> b == y
  <span class="kr">then</span>
   <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), <span class="nb">rename</span>
                               (l ++
                                [<span class="kp">fresh</span>
                                   ([x] ++ l ++ [b])])
                               x y
                               (<span class="nb">rename</span>
                                  (l ++
                                   [<span class="kp">fresh</span>
                                      ([x] ++ l ++ [b])])
                                  b
                                  (<span class="kp">fresh</span>
                                     ([x] ++ l ++ [b]))
                                  t)
  <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t) =
(<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), <span class="nb">rename</span>
                             (l ++
                              [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                             x y
                             (<span class="nb">rename</span>
                                (l ++
                                 [<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y])])
                                y
                                (<span class="kp">fresh</span>
                                   ([x] ++ l ++ [y]))
                                t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd6">destruct_eq_args x b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H, DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(y &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; y)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> y == y
 <span class="kr">then</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), <span class="nb">rename</span>
                              (l ++
                               [<span class="kp">fresh</span>
                                  ([x] ++ l ++ [y])])
                              x y
                              (<span class="nb">rename</span>
                                 (l ++
                                  [<span class="kp">fresh</span>
                                     ([x] ++ l ++ [y])])
                                 y
                                 (<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y]))
                                 t)
 <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">y</span>, <span class="nb">rename</span> l x y t) =
(<span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [y]), <span class="nb">rename</span>
                             (l ++
                              [<span class="kp">fresh</span> ([x] ++ l ++ [y])])
                             x y
                             (<span class="nb">rename</span>
                                (l ++
                                 [<span class="kp">fresh</span>
                                    ([x] ++ l ++ [y])])
                                y
                                (<span class="kp">fresh</span>
                                   ([x] ++ l ++ [y]))
                                t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">destruct_eq_args y y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd7"><span class="kn">Lemma</span> <span class="nf">rename_rw3</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t1</span> <span class="nv">t2</span>,
      <span class="nb">rename</span> l x y (tap t1 t2) = tap (<span class="nb">rename</span> l x y t1) (<span class="nb">rename</span> l x y t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t1</span> <span class="nv">t2</span> : term atom atom),
<span class="nb">rename</span> l x y (t1¬∑t2) = <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t1</span> <span class="nv">t2</span> : term atom atom),
<span class="nb">rename</span> l x y (t1¬∑t2) = <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkd9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y (t1¬∑t2) = <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkda"><span class="nb">rewrite</span> rename_eq_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rename_iter l x y (t1¬∑t2) =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkdb"><span class="nb">unfold</span> rename_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2 =
<span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkdc"><span class="kn">Lemma</span> <span class="nf">depth_rename_eq_strong</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span>,
    (<span class="kr">forall</span> <span class="nv">u</span>, depth u &lt;= depth t -&gt;
    depth (<span class="nb">rename</span> l x y u) = depth u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> <span class="nv">u</span> : term atom atom),
depth u &lt;= depth t -&gt; depth (<span class="nb">rename</span> l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> <span class="nv">u</span> : term atom atom),
depth u &lt;= depth t -&gt; depth (<span class="nb">rename</span> l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkde"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (<span class="nb">rename</span> l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkdf"><span class="nb">generalize dependent</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list atom, depth (<span class="nb">rename</span> l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chke0"><span class="nb">generalize dependent</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chke1"><span class="nb">generalize dependent</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t, u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chke2"><span class="nb">generalize dependent</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chke3"><span class="nb">induction</span> t; <span class="nb">intros</span>; <span class="nb">rewrite</span> rename_eq_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth `v</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chke4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><label class="goal-separator" for="raw-v-chke4"><hr></label><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote><input class="alectryon-extra-goal-toggle" id="raw-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t1 -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t2 -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (t1¬∑t2)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><label class="goal-separator" for="raw-v-chke5"><hr></label><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chke6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth `v</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chke7"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth `v</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chke8">destruct_eq_args x v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth `v</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>v = v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (rename_iter l v y u) = depth u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth `v</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(v &lt;&gt; x)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chke9"><hr></label><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkea"><span class="nb">admit</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth `v</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; v)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(v &lt;&gt; x)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkeb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkec"><span class="nb">unfold</span> rename_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth
  <span class="kr">match</span> u <span class="kr">with</span>
  | tvar v =&gt; <span class="kr">if</span> x == v <span class="kr">then</span> `y <span class="kr">else</span> `v
  | lam b t&#39; =&gt;
      <span class="kr">if</span> b == x
      <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t&#39;
      <span class="kr">else</span>
       <span class="kr">if</span> b == y
       <span class="kr">then</span>
        <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), <span class="nb">rename</span>
                                    (l ++
                                     [<span class="kp">fresh</span>
                                        ([x] ++
                                         l ++ [b])]) x
                                    y
                                    (<span class="nb">rename</span>
                                       (l ++
                                        [<span class="kp">fresh</span>
                                           ([x] ++
                                            l ++ [b])])
                                       b
                                       (<span class="kp">fresh</span>
                                          ([x] ++
                                           l ++ [b]))
                                       t&#39;)
       <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t&#39;
  | tap t1 t2 =&gt; <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2
  <span class="kr">end</span> = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chked">destruct_eq_args b x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (<span class="kr">Œª</span><span class="nv">x</span>, t)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_EQs</var><span class="hyp-type"><b>: </b><span>x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth
  <span class="kr">match</span> u <span class="kr">with</span>
  | tvar v =&gt; <span class="kr">if</span> x == v <span class="kr">then</span> `y <span class="kr">else</span> `v
  | lam b t&#39; =&gt;
      <span class="kr">if</span> b == x
      <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t&#39;
      <span class="kr">else</span>
       <span class="kr">if</span> b == y
       <span class="kr">then</span>
        <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), <span class="nb">rename</span>
                                    (l ++
                                     [<span class="kp">fresh</span>
                                        ([x] ++
                                         l ++ [b])]) x
                                    y
                                    (<span class="nb">rename</span>
                                       (l ++
                                        [<span class="kp">fresh</span>
                                           ([x] ++
                                            l ++ [b])])
                                       b
                                       (<span class="kp">fresh</span>
                                          ([x] ++
                                           l ++ [b]))
                                       t&#39;)
       <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t&#39;
  | tap t1 t2 =&gt; <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2
  <span class="kr">end</span> = depth u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="raw-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><label class="goal-separator" for="raw-v-chkee"><hr></label><div class="goal-conclusion">depth
  <span class="kr">match</span> u <span class="kr">with</span>
  | tvar v =&gt; <span class="kr">if</span> x == v <span class="kr">then</span> `y <span class="kr">else</span> `v
  | lam b t&#39; =&gt;
      <span class="kr">if</span> b == x
      <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t&#39;
      <span class="kr">else</span>
       <span class="kr">if</span> b == y
       <span class="kr">then</span>
        <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), 
       <span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [b])]) x y
         (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> ([x] ++ l ++ [b])]) b
            (<span class="kp">fresh</span> ([x] ++ l ++ [b])) t&#39;)
       <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t&#39;
  | tap t1 t2 =&gt; <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2
  <span class="kr">end</span> = depth u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkef"><span class="nb">admit</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom), depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (<span class="kr">Œª</span><span class="nv">b</span>, t)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>DESTR_NEQ</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>DESTR_NEQs</var><span class="hyp-type"><b>: </b><span>(x &lt;&gt; b)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth
  <span class="kr">match</span> u <span class="kr">with</span>
  | tvar v =&gt; <span class="kr">if</span> x == v <span class="kr">then</span> `y <span class="kr">else</span> `v
  | lam b t&#39; =&gt;
      <span class="kr">if</span> b == x
      <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t&#39;
      <span class="kr">else</span>
       <span class="kr">if</span> b == y
       <span class="kr">then</span>
        <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), <span class="nb">rename</span>
                                    (l ++
                                     [<span class="kp">fresh</span>
                                        ([x] ++
                                         l ++ [b])]) x
                                    y
                                    (<span class="nb">rename</span>
                                       (l ++
                                        [<span class="kp">fresh</span>
                                           ([x] ++
                                            l ++ [b])])
                                       b
                                       (<span class="kp">fresh</span>
                                          ([x] ++
                                           l ++ [b]))
                                       t&#39;)
       <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t&#39;
  | tap t1 t2 =&gt; <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2
  <span class="kr">end</span> = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">admit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t1 -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t2 -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (t1¬∑t2)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (rename_iter l x y u) = depth u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf1"><span class="nb">unfold</span> rename_iter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t1 -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">u</span> : term atom atom,
depth u &lt;= depth t2 -&gt;
<span class="kr">forall</span> (<span class="nv">y</span> <span class="nv">x</span> : atom) (<span class="nv">l</span> : list atom),
depth (<span class="nb">rename</span> l x y u) = depth u</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>depth u &lt;= depth (t1¬∑t2)</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth
  <span class="kr">match</span> u <span class="kr">with</span>
  | tvar v =&gt; <span class="kr">if</span> x == v <span class="kr">then</span> `y <span class="kr">else</span> `v
  | lam b t&#39; =&gt;
      <span class="kr">if</span> b == x
      <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t&#39;
      <span class="kr">else</span>
       <span class="kr">if</span> b == y
       <span class="kr">then</span>
        <span class="kr">Œª</span><span class="nv">fresh</span> ([x] ++ l ++ [b]), <span class="nb">rename</span>
                                    (l ++
                                     [<span class="kp">fresh</span>
                                        ([x] ++
                                         l ++ [b])]) x
                                    y
                                    (<span class="nb">rename</span>
                                       (l ++
                                        [<span class="kp">fresh</span>
                                           ([x] ++
                                            l ++ [b])])
                                       b
                                       (<span class="kp">fresh</span>
                                          ([x] ++
                                           l ++ [b]))
                                       t&#39;)
       <span class="kr">else</span> <span class="kr">Œª</span><span class="nv">b</span>, <span class="nb">rename</span> l x y t&#39;
  | tap t1 t2 =&gt; <span class="nb">rename</span> l x y t1¬∑<span class="nb">rename</span> l x y t2
  <span class="kr">end</span> = depth u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf2"><span class="kn">Lemma</span> <span class="nf">depth_rename_eq</span>: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span>,
    depth (<span class="nb">rename</span> l x y t) = depth t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom),
depth (<span class="nb">rename</span> l x y t) = depth t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> <span class="nv">y</span> : atom)
  (<span class="nv">t</span> : term atom atom),
depth (<span class="nb">rename</span> l x y t) = depth t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Capture-avoiding substitution with well-founded recursion *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf4"><span class="kn">Function</span> <span class="nf">substF</span> (l: list name) <span class="c">(* l is the avoid set *)</span>
  (x : name) (u : term name name)
  (t : term name name)
  {<span class="kn">measure</span> depth t}
  : term name name :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar y =&gt; <span class="kr">if</span> y == x <span class="kr">then</span> u <span class="kr">else</span> tvar y
  | tap t1 t2 =&gt;
      tap (substF l x u t1) (substF l x u t2)
  | lam b t =&gt;
      <span class="kr">if</span> b == x <span class="kr">then</span> lam b t
      <span class="kr">else</span> <span class="kr">let</span> <span class="nv">z</span> := (<span class="kp">fresh</span> l: name) <span class="kr">in</span>
           lam z (substF (l ++ [z]) x u (<span class="nb">rename</span> (l ++ [z]) b z t))
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> : atom),
term atom atom -&gt;
<span class="kr">forall</span> (<span class="nv">t</span> : term atom atom) (<span class="nv">b</span> : atom)
  (<span class="nv">t0</span> : term atom atom),
t = (<span class="kr">Œª</span><span class="nv">b</span>, t0) -&gt;
<span class="kr">forall</span> <span class="nv">anonymous</span> : b &lt;&gt; x,
(b == x) = <span class="nb">right</span> anonymous -&gt;
depth (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t0) &lt;
depth (<span class="kr">Œª</span><span class="nv">b</span>, t0)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
term atom atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
t = t1¬∑t2 -&gt; depth t2 &lt; depth (t1¬∑t2)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
term atom atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
t = t1¬∑t2 -&gt; depth t1 &lt; depth (t1¬∑t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> : atom),
term atom atom -&gt;
<span class="kr">forall</span> (<span class="nv">t</span> : term atom atom) (<span class="nv">b</span> : atom)
  (<span class="nv">t0</span> : term atom atom),
t = (<span class="kr">Œª</span><span class="nv">b</span>, t0) -&gt;
<span class="kr">forall</span> <span class="nv">anonymous</span> : b &lt;&gt; x,
(b == x) = <span class="nb">right</span> anonymous -&gt;
depth (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t0) &lt;
depth (<span class="kr">Œª</span><span class="nv">b</span>, t0)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
term atom atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
t = t1¬∑t2 -&gt; depth t2 &lt; depth (t1¬∑t2)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
term atom atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
t = t1¬∑t2 -&gt; depth t1 &lt; depth (t1¬∑t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list atom) (<span class="nv">x</span> : atom),
term atom atom -&gt;
<span class="kr">forall</span> (<span class="nv">t</span> : term atom atom) (<span class="nv">b</span> : atom)
  (<span class="nv">t0</span> : term atom atom),
t = (<span class="kr">Œª</span><span class="nv">b</span>, t0) -&gt;
<span class="kr">forall</span> <span class="nv">anonymous</span> : b &lt;&gt; x,
(b == x) = <span class="nb">right</span> anonymous -&gt;
depth (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t0) &lt;
depth (<span class="kr">Œª</span><span class="nv">b</span>, t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>t = (<span class="kr">Œª</span><span class="nv">b</span>, t0)</span></span></span><br><span><var>anonymous</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>teq0</var><span class="hyp-type"><b>: </b><span>(b == x) = <span class="nb">right</span> anonymous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t0) &lt;
depth (<span class="kr">Œª</span><span class="nv">b</span>, t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf8"><span class="nb">rewrite</span> depth_rename_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>t = (<span class="kr">Œª</span><span class="nv">b</span>, t0)</span></span></span><br><span><var>anonymous</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>teq0</var><span class="hyp-type"><b>: </b><span>(b == x) = <span class="nb">right</span> anonymous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t0 &lt; depth (<span class="kr">Œª</span><span class="nv">b</span>, t0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkf9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>t = (<span class="kr">Œª</span><span class="nv">b</span>, t0)</span></span></span><br><span><var>anonymous</var><span class="hyp-type"><b>: </b><span>(b &lt;&gt; x)%type</span></span></span><br><span><var>teq0</var><span class="hyp-type"><b>: </b><span>(b == x) = <span class="nb">right</span> anonymous</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t0 &lt; S (depth t0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkfa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
term atom atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
t = t1¬∑t2 -&gt; depth t2 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkfb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t, t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>t = t1¬∑t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t2 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkfc"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t, t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>t = t1¬∑t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t2 &lt; S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkfd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list atom -&gt;
atom -&gt;
term atom atom -&gt;
<span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
t = t1¬∑t2 -&gt; depth t1 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkfe"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t, t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>t = t1¬∑t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 &lt; depth (t1¬∑t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chkff"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t, t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>teq</var><span class="hyp-type"><b>: </b><span>t = t1¬∑t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">depth t1 &lt; S (Nat.max (depth t1) (depth t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">l</span>: list name} {<span class="nv">x</span>: name} {<span class="nv">u</span>: term name name}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk100"><span class="kn">Lemma</span> <span class="nf">substF_rw1</span>: <span class="kr">forall</span> <span class="nv">v</span>,
      substF l x u (tvar v) = (<span class="kr">if</span> v == x <span class="kr">then</span> u <span class="kr">else</span> tvar v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : atom,
substF l x u `v = (<span class="kr">if</span> v == x <span class="kr">then</span> u <span class="kr">else</span> `v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : atom,
substF l x u `v = (<span class="kr">if</span> v == x <span class="kr">then</span> u <span class="kr">else</span> `v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk102"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substF l x u `v = (<span class="kr">if</span> v == x <span class="kr">then</span> u <span class="kr">else</span> `v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk103"><span class="nb">rewrite</span> substF_equation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> v == x <span class="kr">then</span> u <span class="kr">else</span> `v) =
(<span class="kr">if</span> v == x <span class="kr">then</span> u <span class="kr">else</span> `v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk104"><span class="kn">Lemma</span> <span class="nf">substF_rw2</span>: <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">t</span>,
      substF l x u (lam b t) =
        (<span class="kr">if</span> b == x
         <span class="kr">then</span> lam b t
         <span class="kr">else</span>
           lam (<span class="kp">fresh</span> l) (substF (l ++ [<span class="kp">fresh</span> l]) x u (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : atom) (<span class="nv">t</span> : term atom atom),
substF l x u (<span class="kr">Œª</span><span class="nv">b</span>, t) =
(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> <span class="nv">l</span>, substF (l ++ [<span class="kp">fresh</span> l]) x u
              (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk105"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : atom) (<span class="nv">t</span> : term atom atom),
substF l x u (<span class="kr">Œª</span><span class="nv">b</span>, t) =
(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> <span class="nv">l</span>, substF (l ++ [<span class="kp">fresh</span> l]) x u
              (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk106"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substF l x u (<span class="kr">Œª</span><span class="nv">b</span>, t) =
(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> <span class="nv">l</span>, substF (l ++ [<span class="kp">fresh</span> l]) x u
              (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk107"><span class="nb">rewrite</span> substF_equation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> <span class="nv">l</span>, substF (l ++ [<span class="kp">fresh</span> l]) x u
              (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t)) =
(<span class="kr">if</span> b == x
 <span class="kr">then</span> <span class="kr">Œª</span><span class="nv">b</span>, t
 <span class="kr">else</span>
  <span class="kr">Œª</span><span class="nv">fresh</span> <span class="nv">l</span>, substF (l ++ [<span class="kp">fresh</span> l]) x u
              (<span class="nb">rename</span> (l ++ [<span class="kp">fresh</span> l]) b (<span class="kp">fresh</span> l) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk108"><span class="kn">Lemma</span> <span class="nf">substF_rw3</span>: <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span>,
      substF l x u (tap t1 t2) = tap (substF l x u t1) (substF l x u t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
substF l x u (t1¬∑t2) = substF l x u t1¬∑substF l x u t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk109"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term atom atom,
substF l x u (t1¬∑t2) = substF l x u t1¬∑substF l x u t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk10a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substF l x u (t1¬∑t2) = substF l x u t1¬∑substF l x u t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="raw-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="raw-v-chk10b"><span class="nb">rewrite</span> substF_equation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>u, t1, t2</var><span class="hyp-type"><b>: </b><span>term atom atom</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substF l x u t1¬∑substF l x u t2 =
substF l x u t1¬∑substF l x u t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">rw</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subst</span> (<span class="nv">x</span> : name) (<span class="nv">u</span> : term name name) (<span class="nv">t</span> : term name name) :=
  substF ([x] ++ fvL t ++ fvL u) x u t.</span></span></pre>
</div>
</div></body>
</html>
