<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Decomposition into categorical components</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="decomposition-into-categorical-components">
<h1 class="title">Decomposition into categorical components</h1>

<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require Export</span>
  Examples.LambdaNominal.Syntax
  Classes.Categorical.DecoratedMonad (shift).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require</span>
  Classes.Categorical.DecoratedTraversableMonadPoly
  Adapters.CategoricalToKleisli.DecoratedTraversableMonadPoly
  Adapters.CategoricalToKleisli.DecoratedTraversableFunctorPoly
  Adapters.CategoricalToKleisli.DecoratedTraversableMonad
  Adapters.PolyToMono.Kleisli.DecoratedTraversableMonad
  Adapters.PolyToMono.Kleisli.DecoratedTraversableFunctor
  Adapters.PolyToMono.Kleisli.DecoratedFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> List.ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Generalizable Variables</span> <span class="nf">G</span>.</span></span></pre><div class="section" id="map">
<h1>Map</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">map2_term</span> {<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span>: <span class="kt">Type</span>} (<span class="nv">Ï</span>: B1 -&gt; B2) (<span class="nv">Ïƒ</span>: V1 -&gt; V2)
  (<span class="nv">t</span>: term B1 V1): term B2 V2 :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar v =&gt; (@tvar B2 V2) (Ïƒ v)
  | lam v body =&gt; lam (Ï v) (map2_term Ï Ïƒ body)
  | tap t1 t2 =&gt; tap (map2_term Ï Ïƒ t1) (map2_term Ï Ïƒ t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk0"><span class="kn">Lemma</span> <span class="nf">map2_id_term</span>: <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span>: <span class="kt">Type</span>),
    map2_term (@id B1) (@id V1) = @id (term B1 V1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B1</span> <span class="nv">V1</span> : <span class="kt">Type</span>, map2_term id id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B1</span> <span class="nv">V1</span> : <span class="kt">Type</span>, map2_term id id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2_term id id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk3">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2_term id id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk4"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2_term id id (tvar v) = id (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2_term id id t = id t</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk5"><hr></label><div class="goal-conclusion">map2_term id id (lam b t) = id (lam b t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2_term id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2_term id id t2 = id t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk6"><hr></label><div class="goal-conclusion">map2_term id id (tap t1 t2) = id (tap t1 t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2_term id id (tvar v) = id (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2_term id id t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2_term id id (lam b t) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2_term id id t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (id b) (map2_term id id t) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2_term id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2_term id id t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2_term id id (tap t1 t2) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2_term id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2_term id id t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2_term id id t1) (map2_term id id t2) =
id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt1, IHt2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc"><span class="kn">Lemma</span> <span class="nf">map2_map2_term</span>: <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span> <span class="nv">b3</span> <span class="nv">v3</span>: <span class="kt">Type</span>)
                      (<span class="nv">Ï1</span>: B1 -&gt; B2) (<span class="nv">Ïƒ1</span>: V1 -&gt; V2) (<span class="nv">Ï2</span>: B2 -&gt; b3) (<span class="nv">Ïƒ2</span>: V2 -&gt; v3),
    map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1 = map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span> <span class="nv">b3</span> <span class="nv">v3</span> : <span class="kt">Type</span>) (<span class="nv">Ï1</span> : B1 -&gt; B2)
  (<span class="nv">Ïƒ1</span> : V1 -&gt; V2) (<span class="nv">Ï2</span> : B2 -&gt; b3) (<span class="nv">Ïƒ2</span> : V2 -&gt; v3),
map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span> <span class="nv">b3</span> <span class="nv">v3</span> : <span class="kt">Type</span>) (<span class="nv">Ï1</span> : B1 -&gt; B2)
  (<span class="nv">Ïƒ1</span> : V1 -&gt; V2) (<span class="nv">Ï2</span> : B2 -&gt; b3) (<span class="nv">Ïƒ2</span> : V2 -&gt; v3),
map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk10"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) (tvar v) =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t = map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk11"><hr></label><div class="goal-conclusion">(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) (lam b t) =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) (lam b t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk12"><hr></label><div class="goal-conclusion">(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) (tap t1 t2) =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) (tap t1 t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) (tvar v) =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t = map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) (lam b t) =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk15"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t = map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (Ï2 (Ï1 b)) (map2_term Ï2 Ïƒ2 (map2_term Ï1 Ïƒ1 t)) =
lam ((Ï2 âˆ˜ Ï1) b) (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk16">compose near t on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t = map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (Ï2 (Ï1 b))
  ((map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t) =
lam ((Ï2 âˆ˜ Ï1) b) (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) (tap t1 t2) =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk18"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2_term Ï2 Ïƒ2 (map2_term Ï1 Ïƒ1 t1))
  (map2_term Ï2 Ïƒ2 (map2_term Ï1 Ïƒ1 t2)) =
tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk19">compose near t1 on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap ((map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1)
  (map2_term Ï2 Ïƒ2 (map2_term Ï1 Ïƒ1 t2)) =
tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  (map2_term Ï2 Ïƒ2 (map2_term Ï1 Ïƒ1 t2)) =
tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b">compose near t2 on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  ((map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2) =
tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2, b3, v3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ1</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; b3</span></span></span><br><span><var>Ïƒ2</var><span class="hyp-type"><b>: </b><span>V2 -&gt; v3</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t1 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>(map2_term Ï2 Ïƒ2 âˆ˜ map2_term Ï1 Ïƒ1) t2 =
map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2) =
tap (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t1)
  (map2_term (Ï2 âˆ˜ Ï1) (Ïƒ2 âˆ˜ Ïƒ1) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d">#[export] <span class="kn">Instance</span> <span class="nf">Map2_term</span>: Map2 term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Map2 term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Map2 term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f"><span class="nb">intros</span> A1 B1 A2 B2 f1 f2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, B1, A2, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">term A1 B1 -&gt; term A2 B2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (map2_term f1 f2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">map_term_rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    {<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span>: <span class="kt">Type</span>}
      (<span class="nv">Ï</span>: B1 -&gt; B2)
      (<span class="nv">Ïƒ</span>: V1 -&gt; V2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk20"><span class="kn">Lemma</span> <span class="nf">map2_term_rw1</span>: <span class="kr">forall</span> (<span class="nv">v</span>: V1),
      map2 Ï Ïƒ (tvar (B := B1) v) = tvar (Ïƒ v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : V1, map2 Ï Ïƒ (tvar v) = tvar (Ïƒ v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : V1, map2 Ï Ïƒ (tvar v) = tvar (Ïƒ v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk22"><span class="kn">Lemma</span> <span class="nf">map2_term_rw2</span>: <span class="kr">forall</span> (<span class="nv">b</span>: B1) (<span class="nv">body</span>: term B1 V1),
      map2 Ï Ïƒ (lam b body) = lam (Ï b) (map2 Ï Ïƒ body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B1) (<span class="nv">body</span> : term B1 V1),
map2 Ï Ïƒ (lam b body) = lam (Ï b) (map2 Ï Ïƒ body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B1) (<span class="nv">body</span> : term B1 V1),
map2 Ï Ïƒ (lam b body) = lam (Ï b) (map2 Ï Ïƒ body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk24"><span class="kn">Lemma</span> <span class="nf">map2_term_rw3</span>: <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span>: term B1 V1),
      map2 Ï Ïƒ (tap t1 t2) = tap (map2 Ï Ïƒ t1) (map2 Ï Ïƒ t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B1 V1,
map2 Ï Ïƒ (tap t1 t2) = tap (map2 Ï Ïƒ t1) (map2 Ï Ïƒ t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B1 V1,
map2 Ï Ïƒ (tap t1 t2) = tap (map2 Ï Ïƒ t1) (map2 Ï Ïƒ t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">map_term_rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk26">#[export] <span class="kn">Instance</span> <span class="nf">Functor2_term</span>: Functor2 term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk28"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A1</span> <span class="nv">A2</span> : <span class="kt">Type</span>, map2 id id = id</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A1</span> <span class="nv">B2</span> <span class="nv">A2</span> <span class="nv">B3</span> <span class="nv">A3</span> : <span class="kt">Type</span>) (<span class="nv">g2</span> : B2 -&gt; B3)
  (<span class="nv">f2</span> : A2 -&gt; A3) (<span class="nv">g1</span> : B1 -&gt; B2) (<span class="nv">f1</span> : A1 -&gt; A2),
map2 g2 f2 âˆ˜ map2 g1 f1 = map2 (g2 âˆ˜ g1) (f2 âˆ˜ f1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A1</span> <span class="nv">A2</span> : <span class="kt">Type</span>, map2 id id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id id = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id id t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2c"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id id (tvar v) = id (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 id id t = id t</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk2d"><hr></label><div class="goal-conclusion">map2 id id (lam b t) = id (lam b t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 id id t2 = id t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk2e"><hr></label><div class="goal-conclusion">map2 id id (tap t1 t2) = id (tap t1 t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id id (tvar v) = id (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk30">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 id id t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id id (lam b t) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk31"><span class="nb">rewrite</span> map2_term_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 id id t = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (id b) (map2 id id t) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk32">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 id id t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id id (tap t1 t2) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk33"><span class="nb">rewrite</span> map2_term_rw3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 id id t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 id id t1) (map2 id id t2) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk34"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 id id t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (id t1) (map2 id id t2) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk35"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term A1 A2</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 id id t1 = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 id id t2 = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (id t1) (id t2) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">A1</span> <span class="nv">B2</span> <span class="nv">A2</span> <span class="nv">B3</span> <span class="nv">A3</span> : <span class="kt">Type</span>) 
  (<span class="nv">g2</span> : B2 -&gt; B3) (<span class="nv">f2</span> : A2 -&gt; A3) 
  (<span class="nv">g1</span> : B1 -&gt; B2) (<span class="nv">f1</span> : A1 -&gt; A2),
map2 g2 f2 âˆ˜ map2 g1 f1 = map2 (g2 âˆ˜ g1) (f2 âˆ˜ f1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk37"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 âˆ˜ map2 g1 f1 = map2 (g2 âˆ˜ g1) (f2 âˆ˜ f1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk38"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 â—‹ map2 g1 f1 = map2 (g2 â—‹ g1) (f2 â—‹ f1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk39">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 (map2 g1 f1 t) = map2 (g2 â—‹ g1) (f2 â—‹ f1) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk3a"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 (map2 g1 f1 (tvar v)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk3b"><hr></label><div class="goal-conclusion">map2 g2 f2 (map2 g1 f1 (lam b t)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (lam b t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t1) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t2) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk3c"><hr></label><div class="goal-conclusion">map2 g2 f2 (map2 g1 f1 (tap t1 t2)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tap t1 t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk3d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 (map2 g1 f1 (tvar v)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk3e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 (map2 g1 f1 (lam b t)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk3f"><span class="nb">rewrite</span> map2_term_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 (lam (g1 b) (map2 g1 f1 t)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk40"><span class="nb">rewrite</span> map2_term_rw2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (g2 (g1 b)) (map2 g2 f2 (map2 g1 f1 t)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk41"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (g2 (g1 b)) (map2 (g2 â—‹ g1) (f2 â—‹ f1) t) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk42">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t1) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t2) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 (map2 g1 f1 (tap t1 t2)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk43"><span class="nb">rewrite</span> map2_term_rw3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t1) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t2) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g2 f2 (tap (map2 g1 f1 t1) (map2 g1 f1 t2)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk44"><span class="nb">rewrite</span> map2_term_rw3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t1) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t2) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 g2 f2 (map2 g1 f1 t1))
  (map2 g2 f2 (map2 g1 f1 t2)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk45"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t1) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t2) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 (g2 â—‹ g1) (f2 â—‹ f1) t1)
  (map2 g2 f2 (map2 g1 f1 t2)) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk46"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, A1, B2, A2, B3, A3</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>B2 -&gt; B3</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>A2 -&gt; A3</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 A1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t1) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map2 g2 f2 (map2 g1 f1 t2) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 (g2 â—‹ g1) (f2 â—‹ f1) t1)
  (map2 (g2 â—‹ g1) (f2 â—‹ f1) t2) =
map2 (g2 â—‹ g1) (f2 â—‹ f1) (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre></div>
<div class="section" id="decoration">
<h1>Decoration</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dec_term_rec</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>} (<span class="nv">ctx</span>: list B)
  (<span class="nv">t</span>: term B V): term (list B * B) (list B * V) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar v =&gt; tvar (ctx, v)
  | lam b body =&gt; lam (ctx, b) (dec_term_rec (ctx ++ [b]) body)
  | tap t1 t2 =&gt; tap (dec_term_rec ctx t1) (dec_term_rec ctx t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">dec_term</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>}:
  term B V -&gt;
  term (list B * B) (list B * V) :=
  dec_term_rec nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk47"><span class="kn">Lemma</span> <span class="nf">dec_term_shift1</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>}:
  <span class="kr">forall</span> (<span class="nv">ctx1</span> <span class="nv">ctx2</span>: list B) (<span class="nv">t</span>: term B V),
    dec_term_rec (ctx1 ++ ctx2) t =
      shift2 (ctx1, dec_term_rec ctx2 t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx1</span> <span class="nv">ctx2</span> : list B) (<span class="nv">t</span> : term B V),
dec_term_rec (ctx1 ++ ctx2) t =
shift2 (ctx1, dec_term_rec ctx2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx1</span> <span class="nv">ctx2</span> : list B) (<span class="nv">t</span> : term B V),
dec_term_rec (ctx1 ++ ctx2) t =
shift2 (ctx1, dec_term_rec ctx2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk49"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx1, ctx2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2) t =
shift2 (ctx1, dec_term_rec ctx2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk4a"><span class="nb">generalize dependent</span> ctx1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t =
shift2 (ctx1, dec_term_rec ctx2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk4b"><span class="nb">generalize dependent</span> ctx2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t =
shift2 (ctx1, dec_term_rec ctx2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk4c"><span class="nb">induction</span> t; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2) (tvar v) =
shift2 (ctx1, dec_term_rec ctx2 (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t =
shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk4d"><hr></label><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2) (lam b t) =
shift2 (ctx1, dec_term_rec ctx2 (lam b t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t1 =
shift2 (ctx1, dec_term_rec ctx2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t2 =
shift2 (ctx1, dec_term_rec ctx2 t2)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk4e"><hr></label><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2) (tap t1 t2) =
shift2 (ctx1, dec_term_rec ctx2 (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk4f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2) (tvar v) =
shift2 (ctx1, dec_term_rec ctx2 (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk50"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tvar (ctx1 ++ ctx2, v) = tvar (ctx1 â— ctx2, v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2) (lam b t) =
shift2 (ctx1, dec_term_rec ctx2 (lam b t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk52"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (ctx1 ++ ctx2, b)
  (dec_term_rec ((ctx1 ++ ctx2) ++ [b]) t) =
lam (ctx1 â— ctx2, b)
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair ctx1) (pair ctx1)
        (dec_term_rec (ctx2 ++ [b]) t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk53">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ((ctx1 ++ ctx2) ++ [b]) t =
map2 (Datatypes.uncurry incr) (Datatypes.uncurry incr)
  (map2 (pair ctx1) (pair ctx1)
     (dec_term_rec (ctx2 ++ [b]) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk54"><span class="nb">rewrite</span> &lt;- List.app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2 ++ [b]) t =
map2 (Datatypes.uncurry incr) (Datatypes.uncurry incr)
  (map2 (pair ctx1) (pair ctx1)
     (dec_term_rec (ctx2 ++ [b]) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk55"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift2 (ctx1, dec_term_rec (ctx2 ++ [b]) t) =
map2 (Datatypes.uncurry incr) (Datatypes.uncurry incr)
  (map2 (pair ctx1) (pair ctx1)
     (dec_term_rec (ctx2 ++ [b]) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk56">compose near (dec_term_rec (ctx2 ++ [b]) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(shift2 âˆ˜ pair ctx1) (dec_term_rec (ctx2 ++ [b]) t) =
(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr)
 âˆ˜ map2 (pair ctx1) (pair ctx1))
  (dec_term_rec (ctx2 ++ [b]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk57"><span class="nb">rewrite</span> (fun2_map_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(shift2 âˆ˜ pair ctx1) (dec_term_rec (ctx2 ++ [b]) t) =
map2 (Datatypes.uncurry incr âˆ˜ pair ctx1)
  (Datatypes.uncurry incr âˆ˜ pair ctx1)
  (dec_term_rec (ctx2 ++ [b]) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk58"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(shift2 âˆ˜ pair ctx1)
  (shift2 (ctx2, dec_term_rec [b] t)) =
map2 (Datatypes.uncurry incr âˆ˜ pair ctx1)
  (Datatypes.uncurry incr âˆ˜ pair ctx1)
  (shift2 (ctx2, dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk59"><span class="nb">unfold</span> shift2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr) âˆ˜ strength2 âˆ˜ pair ctx1)
  ((map2 (Datatypes.uncurry incr)
      (Datatypes.uncurry incr) âˆ˜ strength2)
     (ctx2, dec_term_rec [b] t)) =
map2 (Datatypes.uncurry incr âˆ˜ pair ctx1)
  (Datatypes.uncurry incr âˆ˜ pair ctx1)
  ((map2 (Datatypes.uncurry incr)
      (Datatypes.uncurry incr) âˆ˜ strength2)
     (ctx2, dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk5a"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">6</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr) âˆ˜ strength2 âˆ˜ pair ctx1)
  ((map2 (Datatypes.uncurry incr)
      (Datatypes.uncurry incr) âˆ˜ strength2)
     (ctx2, dec_term_rec [b] t)) =
map2 (Datatypes.uncurry incr âˆ˜ pair ctx1)
  (Datatypes.uncurry incr âˆ˜ pair ctx1)
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (strength2 (ctx2, dec_term_rec [b] t)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk5b">compose near (strength2 (ctx2, dec_term_rec [b] t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr) âˆ˜ strength2 âˆ˜ pair ctx1)
  ((map2 (Datatypes.uncurry incr)
      (Datatypes.uncurry incr) âˆ˜ strength2)
     (ctx2, dec_term_rec [b] t)) =
(map2 (Datatypes.uncurry incr âˆ˜ pair ctx1)
   (Datatypes.uncurry incr âˆ˜ pair ctx1)
 âˆ˜ map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr))
  (strength2 (ctx2, dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk5c"><span class="nb">rewrite</span> fun2_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr) âˆ˜ strength2 âˆ˜ pair ctx1)
  ((map2 (Datatypes.uncurry incr)
      (Datatypes.uncurry incr) âˆ˜ strength2)
     (ctx2, dec_term_rec [b] t)) =
map2
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (strength2 (ctx2, dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk5d"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr) âˆ˜ strength2 âˆ˜ pair ctx1)
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (strength2 (ctx2, dec_term_rec [b] t))) =
map2
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (strength2 (ctx2, dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk5e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (Datatypes.uncurry incr) (Datatypes.uncurry incr)
  (map2 (pair ctx1) (pair ctx1)
     (map2 (Datatypes.uncurry incr)
        (Datatypes.uncurry incr)
        (map2 (pair ctx2) (pair ctx2)
           (dec_term_rec [b] t)))) =
map2
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk5f">compose near ((map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t))) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (Datatypes.uncurry incr) (Datatypes.uncurry incr)
  ((map2 (pair ctx1) (pair ctx1)
    âˆ˜ map2 (Datatypes.uncurry incr)
        (Datatypes.uncurry incr))
     (map2 (pair ctx2) (pair ctx2)
        (dec_term_rec [b] t))) =
map2
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk60"><span class="nb">rewrite</span> fun2_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (Datatypes.uncurry incr) (Datatypes.uncurry incr)
  (map2 (pair ctx1 âˆ˜ Datatypes.uncurry incr)
     (pair ctx1 âˆ˜ Datatypes.uncurry incr)
     (map2 (pair ctx2) (pair ctx2)
        (dec_term_rec [b] t))) =
map2
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk61">compose near ((map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t))) on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr)
 âˆ˜ map2 (pair ctx1 âˆ˜ Datatypes.uncurry incr)
     (pair ctx1 âˆ˜ Datatypes.uncurry incr))
  (map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t)) =
map2
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk62"><span class="nb">rewrite</span> fun2_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t = shift2 (ctx1, dec_term_rec ctx2 t)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2
  (Datatypes.uncurry incr
   âˆ˜ (pair ctx1 âˆ˜ Datatypes.uncurry incr))
  (Datatypes.uncurry incr
   âˆ˜ (pair ctx1 âˆ˜ Datatypes.uncurry incr))
  (map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t)) =
map2
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (Datatypes.uncurry incr âˆ˜ pair ctx1
   âˆ˜ Datatypes.uncurry incr)
  (map2 (pair ctx2) (pair ctx2) (dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">fequal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t1 =
shift2 (ctx1, dec_term_rec ctx2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t2 =
shift2 (ctx1, dec_term_rec ctx2 t2)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx1 ++ ctx2) (tap t1 t2) =
shift2 (ctx1, dec_term_rec ctx2 (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk64"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t1 =
shift2 (ctx1, dec_term_rec ctx2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t2 =
shift2 (ctx1, dec_term_rec ctx2 t2)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (dec_term_rec (ctx1 ++ ctx2) t1)
  (dec_term_rec (ctx1 ++ ctx2) t2) =
tap
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair ctx1) (pair ctx1)
        (dec_term_rec ctx2 t1)))
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair ctx1) (pair ctx1)
        (dec_term_rec ctx2 t2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk65"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t1 =
shift2 (ctx1, dec_term_rec ctx2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t2 =
shift2 (ctx1, dec_term_rec ctx2 t2)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (shift2 (ctx1, dec_term_rec ctx2 t1))
  (dec_term_rec (ctx1 ++ ctx2) t2) =
tap
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair ctx1) (pair ctx1)
        (dec_term_rec ctx2 t1)))
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair ctx1) (pair ctx1)
        (dec_term_rec ctx2 t2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk66"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t1 =
shift2 (ctx1, dec_term_rec ctx2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx2</span> <span class="nv">ctx1</span> : list B,
dec_term_rec (ctx1 ++ ctx2) t2 =
shift2 (ctx1, dec_term_rec ctx2 t2)</span></span></span><br><span><var>ctx2, ctx1</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (shift2 (ctx1, dec_term_rec ctx2 t1))
  (shift2 (ctx1, dec_term_rec ctx2 t2)) =
tap
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair ctx1) (pair ctx1)
        (dec_term_rec ctx2 t1)))
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair ctx1) (pair ctx1)
        (dec_term_rec ctx2 t2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk67"><span class="kn">Lemma</span> <span class="nf">dec_term_shift</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>}:
  <span class="kr">forall</span> (<span class="nv">ctx</span>: list B) (<span class="nv">t</span>: term B V),
    dec_term_rec ctx t =
      shift2 (ctx, dec_term t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx</span> : list B) (<span class="nv">t</span> : term B V),
dec_term_rec ctx t = shift2 (ctx, dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx</span> : list B) (<span class="nv">t</span> : term B V),
dec_term_rec ctx t = shift2 (ctx, dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk69"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx t = shift2 (ctx, dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk6a"><span class="nb">rewrite</span> &lt;- (List.app_nil_r ctx) <span class="nb">at</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx ++ []) t = shift2 (ctx, dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk6b"><span class="nb">rewrite</span> dec_term_shift1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift2 (ctx, dec_term_rec [] t) =
shift2 (ctx, dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">DecoratePoly_term</span>: DecoratePoly term := @dec_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">dec_term_rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>) (<span class="nv">ctx</span>: list B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk6c"><span class="kn">Lemma</span> <span class="nf">dec_term_rec_rw1</span>: <span class="kr">forall</span> (<span class="nv">v</span>: V),
      dec_term_rec ctx (tvar v) = tvar (ctx, v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : V,
dec_term_rec ctx (tvar v) = tvar (ctx, v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : V,
dec_term_rec ctx (tvar v) = tvar (ctx, v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk6e"><span class="kn">Lemma</span> <span class="nf">dec_term_rec_rw2</span>: <span class="kr">forall</span> (<span class="nv">b</span>: B) (<span class="nv">body</span>: term B V),
      dec_term_rec ctx (lam b body) =
        lam (ctx, b) (dec_term_rec (ctx ++ [b]) body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B V),
dec_term_rec ctx (lam b body) =
lam (ctx, b) (dec_term_rec (ctx ++ [b]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B V),
dec_term_rec ctx (lam b body) =
lam (ctx, b) (dec_term_rec (ctx ++ [b]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk70"><span class="kn">Lemma</span> <span class="nf">dec_term_rec_rw3</span>: <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span>: term B V),
      dec_term_rec ctx (tap t1 t2) = tap (dec_term_rec ctx t1) (dec_term_rec ctx t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B V,
dec_term_rec ctx (tap t1 t2) =
tap (dec_term_rec ctx t1) (dec_term_rec ctx t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk71"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B V,
dec_term_rec ctx (tap t1 t2) =
tap (dec_term_rec ctx t1) (dec_term_rec ctx t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk72"><span class="kn">Lemma</span> <span class="nf">dec_term_rw1</span>: <span class="kr">forall</span> (<span class="nv">v</span>: V),
      decp (tvar (B := B) v) = tvar ([], v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : V, decp (tvar v) = tvar ([], v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : V, decp (tvar v) = tvar ([], v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk74"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : V, tvar ([], v) = tvar ([], v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk75"><span class="kn">Lemma</span> <span class="nf">dec_term_rw2</span>: <span class="kr">forall</span> (<span class="nv">b</span>: B) (<span class="nv">body</span>: term B V),
      decp (lam b body) = lam ([], b) (shift2 ([b], decp body)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B V),
decp (lam b body) =
lam ([], b) (shift2 ([b], decp body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B V),
decp (lam b body) =
lam ([], b) (shift2 ([b], decp body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk77"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decp (lam b body) =
lam ([], b) (shift2 ([b], decp body))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk78"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam ([], b) (dec_term_rec [b] body) =
lam ([], b)
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair [b]) (pair [b]) (decp body)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk79"><span class="nb">rewrite</span> dec_term_shift.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam ([], b) (shift2 ([b], dec_term body)) =
lam ([], b)
  (map2 (Datatypes.uncurry incr)
     (Datatypes.uncurry incr)
     (map2 (pair [b]) (pair [b]) (decp body)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk7a"><span class="kn">Lemma</span> <span class="nf">dec_term_rw2&#39;</span>: <span class="kr">forall</span> (<span class="nv">b</span>: B) (<span class="nv">body</span>: term B V),
      decp (lam b body) = lam ([], b) (dec_term_rec [b] body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B V),
decp (lam b body) =
lam ([], b) (dec_term_rec [b] body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk7b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B V),
decp (lam b body) =
lam ([], b) (dec_term_rec [b] body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk7c"><span class="kn">Lemma</span> <span class="nf">dec_term_rw3</span>: <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span>: term B V),
      decp (tap t1 t2) = tap (decp t1) (decp t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B V,
decp (tap t1 t2) = tap (decp t1) (decp t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B V,
decp (tap t1 t2) = tap (decp t1) (decp t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">dec_term_rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Naturality, rec case *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk7e"><span class="kn">Lemma</span> <span class="nf">map_dec_rec</span>:
  <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span>: <span class="kt">Type</span>)
    (<span class="nv">Ï</span>: list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span>: list B1 * V1 -&gt; V2) (<span class="nv">ctx</span>: list B1),
    map2 Ï Ïƒ âˆ˜ dec_term_rec ctx =
      map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) âˆ˜ dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span> : <span class="kt">Type</span>) (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ âˆ˜ dec_term_rec ctx =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span> : <span class="kt">Type</span>) (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ âˆ˜ dec_term_rec ctx =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk80"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 Ï Ïƒ âˆ˜ dec_term_rec ctx =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk81">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 Ï Ïƒ âˆ˜ dec_term_rec ctx) t =
(map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) âˆ˜ dec_term) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk82"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 Ï Ïƒ (dec_term_rec ctx t) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk83"><span class="nb">generalize dependent</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list B1,
map2 Ï Ïƒ (dec_term_rec ctx t) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk84"><span class="nb">generalize dependent</span> Ïƒ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk85"><span class="nb">generalize dependent</span> Ï.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk86"><span class="nb">induction</span> t; <span class="nb">intros</span> Ï Ïƒ ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 Ï Ïƒ (dec_term_rec ctx (tvar v)) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk87"><hr></label><div class="goal-conclusion">map2 Ï Ïƒ (dec_term_rec ctx (lam b t)) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term (lam b t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t1) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t2) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk88"><hr></label><div class="goal-conclusion">map2 Ï Ïƒ (dec_term_rec ctx (tap t1 t2)) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk89">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 Ï Ïƒ (dec_term_rec ctx (tvar v)) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk8a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tvar (Ïƒ (ctx, v)) = tvar ((Ïƒ â¦¿ ctx) ([], v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk8b"><span class="nb">unfold</span> preincr, compose, incr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tvar (Ïƒ (ctx, v)) = tvar (Ïƒ (ctx â— [], v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk8c"><span class="nb">change</span> (@nil B1) <span class="kr">with</span> (Æµ: list B1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tvar (Ïƒ (ctx, v)) = tvar (Ïƒ (ctx â— (Æµ : list B1), v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk8d"><span class="nb">rewrite</span> monoid_id_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tvar (Ïƒ (ctx, v)) = tvar (Ïƒ (ctx, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk8e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 Ï Ïƒ (dec_term_rec ctx (lam b t)) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term (lam b t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk8f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (Ï (ctx, b))
  (map2 Ï Ïƒ (dec_term_rec (ctx ++ [b]) t)) =
lam ((Ï â¦¿ ctx) ([], b))
  (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk90"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (Ï (ctx, b))
  (map2 (Ï â¦¿ (ctx ++ [b])) (Ïƒ â¦¿ (ctx ++ [b]))
     (dec_term t)) =
lam ((Ï â¦¿ ctx) ([], b))
  (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term_rec [b] t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk91"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (Ï (ctx, b))
  (map2 (Ï â¦¿ (ctx ++ [b])) (Ïƒ â¦¿ (ctx ++ [b]))
     (dec_term t)) =
lam ((Ï â¦¿ ctx) ([], b))
  (map2 ((Ï â¦¿ ctx) â¦¿ [b]) ((Ïƒ â¦¿ ctx) â¦¿ [b])
     (dec_term t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk92">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï (ctx, b) = (Ï â¦¿ ctx) ([], b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk93"><hr></label><div class="goal-conclusion">map2 (Ï â¦¿ (ctx ++ [b])) (Ïƒ â¦¿ (ctx ++ [b]))
  (dec_term t) =
map2 ((Ï â¦¿ ctx) â¦¿ [b]) ((Ïƒ â¦¿ ctx) â¦¿ [b]) (dec_term t)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk94">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï (ctx, b) = (Ï â¦¿ ctx) ([], b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk95"><span class="nb">unfold</span> preincr, incr, compose, monoid_op, Monoid_op_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï (ctx, b) = Ï (ctx ++ [], b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk96"><span class="nb">rewrite</span> List.app_nil_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Ï (ctx, b) = Ï (ctx, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk97">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (Ï â¦¿ (ctx ++ [b])) (Ïƒ â¦¿ (ctx ++ [b]))
  (dec_term t) =
map2 ((Ï â¦¿ ctx) â¦¿ [b]) ((Ïƒ â¦¿ ctx) â¦¿ [b]) (dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk98"><span class="nb">rewrite</span> preincr_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (Ï â¦¿ (ctx ++ [b])) (Ïƒ â¦¿ (ctx ++ [b]))
  (dec_term t) =
map2 (Ï â¦¿ (ctx â— [b])) ((Ïƒ â¦¿ ctx) â¦¿ [b]) (dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk99"><span class="nb">rewrite</span> preincr_preincr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2) (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t) = map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (Ï â¦¿ (ctx ++ [b])) (Ïƒ â¦¿ (ctx ++ [b]))
  (dec_term t) =
map2 (Ï â¦¿ (ctx â— [b])) (Ïƒ â¦¿ (ctx â— [b])) (dec_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk9a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t1) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t2) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 Ï Ïƒ (dec_term_rec ctx (tap t1 t2)) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk9b"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t1) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t2) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 Ï Ïƒ (dec_term_rec ctx t1))
  (map2 Ï Ïƒ (dec_term_rec ctx t2)) =
tap (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1))
  (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk9c"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t1) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t2) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1))
  (map2 Ï Ïƒ (dec_term_rec ctx t2)) =
tap (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1))
  (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk9d"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t1) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">Ï</span> : list B1 * B1 -&gt; B2)
  (<span class="nv">Ïƒ</span> : list B1 * V1 -&gt; V2) 
  (<span class="nv">ctx</span> : list B1),
map2 Ï Ïƒ (dec_term_rec ctx t2) =
map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1))
  (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2)) =
tap (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t1))
  (map2 (Ï â¦¿ ctx) (Ïƒ â¦¿ ctx) (dec_term t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk9e"><span class="kn">Lemma</span> <span class="nf">dec_rec_spec</span>:
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>) (<span class="nv">ctx</span>: list B),
    dec_term_rec ctx =
      map2 (incr ctx) (incr ctx) âˆ˜ dec_term (V := V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
dec_term_rec ctx =
map2 (incr ctx) (incr ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
dec_term_rec ctx =
map2 (incr ctx) (incr ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx =
map2 (incr ctx) (incr ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka1">change_left (id âˆ˜ dec_term_rec ctx (V := V)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id âˆ˜ dec_term_rec ctx =
map2 (incr ctx) (incr ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka2"><span class="nb">rewrite</span> &lt;- fun2_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id id âˆ˜ dec_term_rec ctx =
map2 (incr ctx) (incr ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka3"><span class="nb">rewrite</span> map_dec_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (id â¦¿ ctx) (id â¦¿ ctx) âˆ˜ dec_term =
map2 (incr ctx) (incr ctx) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Counit law *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka4"><span class="kn">Lemma</span> <span class="nf">dec_rec_extract_term</span>: <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>) (<span class="nv">ctx</span>: list B),
    map2 (extract_Z2) (extract_Z2) âˆ˜ dec_term_rec ctx = @id (term B V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
map2 extract_Z2 extract_Z2 âˆ˜ dec_term_rec ctx = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
map2 extract_Z2 extract_Z2 âˆ˜ dec_term_rec ctx = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2 âˆ˜ dec_term_rec ctx = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka7">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 extract_Z2 extract_Z2 âˆ˜ dec_term_rec ctx) t =
id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka8"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2 (dec_term_rec ctx t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chka9"><span class="nb">generalize dependent</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
map2 extract_Z2 extract_Z2 (dec_term_rec ctx t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkaa"><span class="nb">induction</span> t; <span class="nb">intro</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2 (dec_term_rec ctx (tvar v)) =
id (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chkab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B, map2 extract_Z2 extract_Z2 (dec_term_rec ctx t) = id t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkab"><hr></label><div class="goal-conclusion">map2 extract_Z2 extract_Z2
  (dec_term_rec ctx (lam b t)) = id (lam b t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
map2 extract_Z2 extract_Z2
  (dec_term_rec ctx t1) = 
id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
map2 extract_Z2 extract_Z2
  (dec_term_rec ctx t2) = 
id t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkac"><hr></label><div class="goal-conclusion">map2 extract_Z2 extract_Z2
  (dec_term_rec ctx (tap t1 t2)) = id (tap t1 t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2 (dec_term_rec ctx (tvar v)) =
id (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B, map2 extract_Z2 extract_Z2 (dec_term_rec ctx t) = id t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2
  (dec_term_rec ctx (lam b t)) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkaf"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B, map2 extract_Z2 extract_Z2 (dec_term_rec ctx t) = id t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam b
  (map2 extract_Z2 extract_Z2
     (dec_term_rec (ctx ++ [b]) t)) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
map2 extract_Z2 extract_Z2
  (dec_term_rec ctx t1) = 
id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
map2 extract_Z2 extract_Z2
  (dec_term_rec ctx t2) = 
id t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2
  (dec_term_rec ctx (tap t1 t2)) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb1"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
map2 extract_Z2 extract_Z2
  (dec_term_rec ctx t1) = 
id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
map2 extract_Z2 extract_Z2
  (dec_term_rec ctx t2) = 
id t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 extract_Z2 extract_Z2 (dec_term_rec ctx t1))
  (map2 extract_Z2 extract_Z2 (dec_term_rec ctx t2)) =
id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt1, IHt2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb2"><span class="kn">Lemma</span> <span class="nf">dec_extract_term</span>: <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>),
    map2 (extract_Z2) (extract_Z2) âˆ˜ dec_term = @id (term B V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
map2 extract_Z2 extract_Z2 âˆ˜ dec_term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
map2 extract_Z2 extract_Z2 âˆ˜ dec_term = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb4"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2 âˆ˜ dec_term = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb5"><span class="nb">unfold</span> dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract_Z2 extract_Z2 âˆ˜ dec_term_rec [] = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_rec_extract_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* cojoin law *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb6"><span class="kn">Lemma</span> <span class="nf">dec_rec_dec_rec_term</span>: <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>) (<span class="nv">ctx</span>: list B),
    dec_term_rec (decorate_prefix_list ctx) âˆ˜ dec_term_rec ctx =
      map2 (cojoin_Z2) (cojoin_Z2) âˆ˜ dec_term_rec ctx (B := B) (V := V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
dec_term_rec (decorate_prefix_list ctx)
âˆ˜ dec_term_rec ctx =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
dec_term_rec (decorate_prefix_list ctx)
âˆ˜ dec_term_rec ctx =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
âˆ˜ dec_term_rec ctx =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkb9">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(dec_term_rec (decorate_prefix_list ctx)
 âˆ˜ dec_term_rec ctx) t =
(map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term_rec ctx) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkba"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkbb"><span class="nb">generalize dependent</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkbc"><span class="nb">induction</span> t; <span class="nb">intro</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx (tvar v)) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkbd"><hr></label><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx (lam b t)) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx (lam b t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chkbe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t1) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t2) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkbe"><hr></label><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx (tap t1 t2)) =
map2 cojoin_Z2 cojoin_Z2
  (dec_term_rec ctx (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkbf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx (tvar v)) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx (lam b t)) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx (lam b t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc1"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx, b)])
     (dec_term_rec (ctx ++ [b]) t)) =
lam (decorate_prefix_list ctx, (ctx, b))
  (map2 cojoin_Z2 cojoin_Z2
     (dec_term_rec (ctx ++ [b]) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc2"><span class="nb">rewrite</span> &lt;- IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx, b)])
     (dec_term_rec (ctx ++ [b]) t)) =
lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec (decorate_prefix_list (ctx ++ [b]))
     (dec_term_rec (ctx ++ [b]) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc3"><span class="nb">rewrite</span> decorate_prefix_list_rw_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx, b)])
     (dec_term_rec (ctx ++ [b]) t)) =
lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++
      map (incr ctx) (decorate_prefix_list [b]))
     (dec_term_rec (ctx ++ [b]) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc4"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx, b)])
     (dec_term_rec (ctx ++ [b]) t)) =
lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx â— [], b)])
     (dec_term_rec (ctx ++ [b]) t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc5"><span class="nb">change</span> (@nil B) <span class="kr">with</span> (Æµ: list B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx, b)])
     (dec_term_rec (ctx ++ b :: (Æµ : list B)) t)) =
lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++
      [(ctx â— (Æµ : list B), b)])
     (dec_term_rec (ctx ++ b :: (Æµ : list B)) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc6"><span class="nb">rewrite</span> monoid_id_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx) (dec_term_rec ctx t) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx, b)])
     (dec_term_rec (ctx ++ b :: Æµ) t)) =
lam (decorate_prefix_list ctx, (ctx, b))
  (dec_term_rec
     (decorate_prefix_list ctx ++ [(ctx, b)])
     (dec_term_rec (ctx ++ b :: Æµ) t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t1) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t2) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx (tap t1 t2)) =
map2 cojoin_Z2 cojoin_Z2
  (dec_term_rec ctx (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t1) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec (decorate_prefix_list ctx)
  (dec_term_rec ctx t2) =
map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap
  (dec_term_rec (decorate_prefix_list ctx)
     (dec_term_rec ctx t1))
  (dec_term_rec (decorate_prefix_list ctx)
     (dec_term_rec ctx t2)) =
tap (map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t1))
  (map2 cojoin_Z2 cojoin_Z2 (dec_term_rec ctx t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> IHt1, IHt2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkc9"><span class="kn">Lemma</span> <span class="nf">dec_dec_term</span>: <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>),
    dec_term âˆ˜ dec_term (B := B) (V := V) =
      map2 (cojoin_Z2) (cojoin_Z2) âˆ˜ dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
dec_term âˆ˜ dec_term =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
dec_term âˆ˜ dec_term =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkcb"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term âˆ˜ dec_term =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkcc"><span class="nb">unfold</span> dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec [] âˆ˜ dec_term_rec [] =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term_rec []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkcd"><span class="nb">change</span> (@nil (list B * B)) <span class="kr">with</span> (decorate_prefix_list (@nil B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (decorate_prefix_list [])
âˆ˜ dec_term_rec [] =
map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term_rec []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dec_rec_dec_rec_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">naturality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span>: <span class="kt">Type</span>}
    (<span class="nv">Ï</span>: B1 -&gt; B2) (<span class="nv">Ïƒ</span>: V1 -&gt; V2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkce"><span class="kn">Lemma</span> <span class="nf">dec_rec_map</span>: <span class="kr">forall</span> (<span class="nv">ctx</span>: list B1),
      dec_term_rec (map Ï ctx) âˆ˜ map2 Ï Ïƒ =
        map2 (map_pair (map (F := list) Ï) Ï)
          (map_pair (map (F := list) Ï) Ïƒ) âˆ˜ dec_term_rec ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list B1,
dec_term_rec (map Ï ctx) âˆ˜ map2 Ï Ïƒ =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkcf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list B1,
dec_term_rec (map Ï ctx) âˆ˜ map2 Ï Ïƒ =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï ctx) âˆ˜ map2 Ï Ïƒ =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd1">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(dec_term_rec (map Ï ctx) âˆ˜ map2 Ï Ïƒ) t =
(map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
 âˆ˜ dec_term_rec ctx) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd2"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd3"><span class="nb">generalize dependent</span> Ï; <span class="nb">clear</span> Ï.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Ï</span> : B1 -&gt; B2,
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd4"><span class="nb">generalize dependent</span> Ïƒ; <span class="nb">clear</span> Ïƒ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Ïƒ</span> : V1 -&gt; V2) (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd5"><span class="nb">generalize dependent</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2) (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd6"><span class="nb">induction</span> t <span class="kr">as</span> [v | b body IHbody | t1 IHt1 t2 IHt2];
      <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï ctx) (map2 Ï Ïƒ (tvar v)) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chkd7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï)
  (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkd7"><hr></label><div class="goal-conclusion">dec_term_rec (map Ï ctx) (map2 Ï Ïƒ (lam b body)) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx (lam b body))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chkd8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t1) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t2) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkd8"><hr></label><div class="goal-conclusion">dec_term_rec (map Ï ctx) (map2 Ï Ïƒ (tap t1 t2)) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkd9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V1</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï ctx) (map2 Ï Ïƒ (tvar v)) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkda">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï)
  (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï ctx) (map2 Ï Ïƒ (lam b body)) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx (lam b body))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkdb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï)
  (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (map Ï ctx, Ï b)
  (dec_term_rec (map Ï ctx ++ [Ï b]) (map2 Ï Ïƒ body)) =
lam (id (map Ï ctx), Ï (id b))
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec (ctx ++ [b]) body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkdc">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï)
  (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï ctx ++ [Ï b]) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec (ctx ++ [b]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkdd"><span class="nb">replace</span> (map Ï ctx ++ [Ï b])
        <span class="kr">with</span> (map Ï (ctx ++ [b])) <span class="bp">by</span> <span class="bp">now</span> <span class="nb">rewrite</span> map_list_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï)
  (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï (ctx ++ [b])) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec (ctx ++ [b]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkde"><span class="nb">rewrite</span> IHbody.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ body) =
map2 (map_pair (map Ï) Ï)
  (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec (ctx ++ [b]) body) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec (ctx ++ [b]) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkdf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t1) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t2) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï ctx) (map2 Ï Ïƒ (tap t1 t2)) =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
  (dec_term_rec ctx (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke0"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t1) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t2) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t1))
  (dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t2)) =
tap
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t1))
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke1"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t1) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t2) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t1))
  (dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t2)) =
tap
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t1))
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke2"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t1) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">ctx</span> : list B1) (<span class="nv">Ïƒ</span> : V1 -&gt; V2)
  (<span class="nv">Ï</span> : B1 -&gt; B2),
dec_term_rec (map Ï ctx) (map2 Ï Ïƒ t2) =
map2 (map_pair (map Ï) Ï) 
  (map_pair (map Ï) Ïƒ) (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B1</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t1))
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t2)) =
tap
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t1))
  (map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
     (dec_term_rec ctx t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke3"><span class="kn">Lemma</span> <span class="nf">dec_map</span>:
    dec_term âˆ˜ map2 Ï Ïƒ =
      map2 (map_pair (map (F := list) Ï) Ï)
        (map_pair (map (F := list) Ï) Ïƒ) âˆ˜ dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term âˆ˜ map2 Ï Ïƒ =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term âˆ˜ map2 Ï Ïƒ =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke5"><span class="nb">unfold</span> dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec [] âˆ˜ map2 Ï Ïƒ =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term_rec []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke6"><span class="nb">change</span> (@nil B2) <span class="kr">with</span> (map Ï nil).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (map Ï []) âˆ˜ map2 Ï Ïƒ =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term_rec []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke7"><span class="nb">rewrite</span> dec_rec_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term_rec [] =
map2 (map_pair (map Ï) Ï) (map_pair (map Ï) Ïƒ)
âˆ˜ dec_term_rec []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">naturality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke8">#[export] <span class="kn">Instance</span>: DecoratedFunctorPoly term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctorPoly term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chke9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctorPoly term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkea"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">PolyDecorateNatural term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
decp âˆ˜ decp = map2 cojoin cojoin_Z2 âˆ˜ decp</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>, map2 extract extract âˆ˜ decp = id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkeb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkec">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">PolyDecorateNatural term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chked"><span class="nb">unfold</span> PolyDecorateNatural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> <span class="nv">B&#39;</span> <span class="nv">V&#39;</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; B&#39;) (<span class="nv">f</span> : V -&gt; V&#39;),
decp âˆ˜ map2 g f = map2 (map g) (map2 g f) âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkee"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V, B', V'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>V -&gt; V&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decp âˆ˜ map2 g f = map2 (map g) (map2 g f) âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkef"><span class="nb">setoid_rewrite</span> dec_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V, B', V'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>V -&gt; V&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (map_pair (map g) g) (map_pair (map g) f)
âˆ˜ dec_term = map2 (map g) (map2 g f) âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf0">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V, B', V'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>V -&gt; V&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 (map_pair (map g) g) (map_pair (map g) f) =
map2 (map g) (map2 g f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf1">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V, B', V'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>V -&gt; V&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map_pair (map g) f = map2 g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> ext [ctx a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
decp âˆ˜ decp = map2 cojoin cojoin_Z2 âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decp âˆ˜ decp = map2 cojoin cojoin_Z2 âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf4"><span class="nb">rewrite</span> dec_dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 cojoin_Z2 cojoin_Z2 âˆ˜ dec_term =
map2 cojoin cojoin_Z2 âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>, map2 extract extract âˆ˜ decp = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 extract extract âˆ˜ decp = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf7"><span class="nb">rewrite</span> dec_extract_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="applicative-distribution">
<h1>Applicative distribution</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">dist_term</span>
  {<span class="nv">G</span>: <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Map G} `{Pure G} `{Mult G}
   {B V: <span class="kt">Type</span>}
  (t: term (G B) (G V)): G (term B V) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar vr =&gt; map (@tvar B V) vr
  | lam bin body =&gt; pure (@lam B V)
                     &lt;â‹†&gt; bin
                     &lt;â‹†&gt; dist_term body
  | tap t1 t2 =&gt; pure (@tap B V)
                  &lt;â‹†&gt; dist_term t1
                  &lt;â‹†&gt; dist_term t2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">term_dist2</span>: ApplicativeDist2 term := @dist_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf8"><span class="kn">Lemma</span> <span class="nf">dist_term_morph</span>:
  <span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Map G1} `{Mult G1} `{Pure G1}
    `{Map G2} `{Mult G2} `{Pure G2}
    (Ï•: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>), G1 A -&gt; G2 A),
    ApplicativeMorphism G1 G2 Ï• -&gt;
    <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>),
      dist2 (G := G2) âˆ˜ map2 (Ï• B) (Ï• V) =

        Ï• (term B V) âˆ˜ dist2 (G := G1) (B := B) (A := V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">Ï•</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 Ï• -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
dist2 âˆ˜ map2 (Ï• B) (Ï• V) = Ï• (term B V) âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkf9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">Ï•</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 Ï• -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
dist2 âˆ˜ map2 (Ï• B) (Ï• V) = Ï• (term B V) âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkfa"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 âˆ˜ map2 (Ï• B) (Ï• V) = Ï• (term B V) âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkfb">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(dist2 âˆ˜ map2 (Ï• B) (Ï• V)) t =
(Ï• (term B V) âˆ˜ dist2) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkfc"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chkfd"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G1 V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 (Ï• B) (Ï• V) (tvar v)) =
Ï• (term B V) (dist2 (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chkfe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkfe"><hr></label><div class="goal-conclusion">dist2 (map2 (Ï• B) (Ï• V) (lam b t)) =
Ï• (term B V) (dist2 (lam b t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chkff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chkff"><hr></label><div class="goal-conclusion">dist2 (map2 (Ï• B) (Ï• V) (tap t1 t2)) =
Ï• (term B V) (dist2 (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk100">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G1 V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 (Ï• B) (Ï• V) (tvar v)) =
Ï• (term B V) (dist2 (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk101"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G1 V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map tvar (Ï• V v) = Ï• (term B V) (map tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk102"><span class="nb">rewrite</span> appmor_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G1 V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map tvar (Ï• V v) = map tvar (Ï• V v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk103">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 (Ï• B) (Ï• V) (lam b t)) =
Ï• (term B V) (dist2 (lam b t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk104"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; Ï• B b &lt;â‹†&gt;
dist2 (map2 (Ï• B) (Ï• V) t) =
Ï• (term B V) (pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk105"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; Ï• B b &lt;â‹†&gt; Ï• (term B V) (dist2 t) =
Ï• (term B V) (pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk106"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; Ï• B b &lt;â‹†&gt; Ï• (term B V) (dist2 t) =
Ï• (term B V -&gt; term B V) (pure (lam (V:=V)) &lt;â‹†&gt; b) &lt;â‹†&gt;
Ï• (term B V) (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk107"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; Ï• B b &lt;â‹†&gt; Ï• (term B V) (dist2 t) =
Ï• (B -&gt; term B V -&gt; term B V) (pure (lam (V:=V))) &lt;â‹†&gt;
Ï• B b &lt;â‹†&gt; Ï• (term B V) (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk108"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G1 B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t) = Ï• (term B V) (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; Ï• B b &lt;â‹†&gt; Ï• (term B V) (dist2 t) =
pure (lam (V:=V)) &lt;â‹†&gt; Ï• B b &lt;â‹†&gt; Ï• (term B V) (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk109">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 (Ï• B) (Ï• V) (tap t1 t2)) =
Ï• (term B V) (dist2 (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk10a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; dist2 (map2 (Ï• B) (Ï• V) t1) &lt;â‹†&gt;
dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V)
  (pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk10b"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; Ï• (term B V) (dist2 t1) &lt;â‹†&gt;
dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V)
  (pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk10c"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; Ï• (term B V) (dist2 t1) &lt;â‹†&gt;
Ï• (term B V) (dist2 t2) =
Ï• (term B V)
  (pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk10d"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; Ï• (term B V) (dist2 t1) &lt;â‹†&gt;
Ï• (term B V) (dist2 t2) =
Ï• (term B V -&gt; term B V)
  (pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1) &lt;â‹†&gt;
Ï• (term B V) (dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk10e"><span class="nb">rewrite</span> ap_morphism_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; Ï• (term B V) (dist2 t1) &lt;â‹†&gt;
Ï• (term B V) (dist2 t2) =
Ï• (term B V -&gt; term B V -&gt; term B V)
  (pure (tap (V:=V))) &lt;â‹†&gt; Ï• (term B V) (dist2 t1) &lt;â‹†&gt;
Ï• (term B V) (dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk10f"><span class="nb">rewrite</span> appmor_pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Ï•</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ApplicativeMorphism G1 G2 Ï•</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G1 B) (G1 V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t1) =
Ï• (term B V) (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (map2 (Ï• B) (Ï• V) t2) =
Ï• (term B V) (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; Ï• (term B V) (dist2 t1) &lt;â‹†&gt;
Ï• (term B V) (dist2 t2) =
pure (tap (V:=V)) &lt;â‹†&gt; Ï• (term B V) (dist2 t1) &lt;â‹†&gt;
Ï• (term B V) (dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk110"><span class="kn">Lemma</span> <span class="nf">dist_term_linear</span>:
  <span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    `{Map G1} `{Mult G1} `{Pure G1} `{! Applicative G1}
    `{Map G2} `{Mult G2} `{Pure G2} `{! Applicative G2},
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>),
    dist2 (G := G1 âˆ˜ G2) =
    map (F := G1) (dist2 (G := G2)) âˆ˜
      dist2 (T := term) (G := G1) (B := G2 B) (A := G2 V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">H2</span> : Map G2) (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>, dist2 = map dist2 âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk111"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">H2</span> : Map G2) (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>, dist2 = map dist2 âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk112"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 = map dist2 âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk113">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 t = (map dist2 âˆ˜ dist2) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk114"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 t = map dist2 (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk115"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (tvar v) = map dist2 (dist2 (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk116"><hr></label><div class="goal-conclusion">dist2 (lam b t) = map dist2 (dist2 (lam b t))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk117"><hr></label><div class="goal-conclusion">dist2 (tap t1 t2) = map dist2 (dist2 (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk118">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (tvar v) = map dist2 (dist2 (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk119"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map tvar v = map dist2 (map tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk11a">compose near v on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map tvar v = (map dist2 âˆ˜ map tvar) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk11b"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map tvar v = map (dist2 âˆ˜ tvar) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (lam b t) = map dist2 (dist2 (lam b t))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk11d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk11e"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; map dist2 (dist2 t) =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk11f">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (pure (lam (V:=V))) &lt;â‹†&gt; b &lt;â‹†&gt; map dist2 (dist2 t) =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk120"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2) (pure (pure (lam (V:=V))) &lt;â‹†&gt; b) &lt;â‹†&gt;
map dist2 (dist2 t) =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk121"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2)
  (map (ap G2) (pure (pure (lam (V:=V)))) &lt;â‹†&gt; b) &lt;â‹†&gt;
map dist2 (dist2 t) =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk122"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (map (ap G2) (pure (pure (lam (V:=V))))) &lt;â‹†&gt; b &lt;â‹†&gt;
map dist2 (dist2 t) =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk123"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (pure (ap G2 (pure (lam (V:=V))))) &lt;â‹†&gt; b &lt;â‹†&gt;
map dist2 (dist2 t) =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk124"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (ap G2 âˆ˜ ap G2 (pure (lam (V:=V)))) &lt;â‹†&gt; b &lt;â‹†&gt;
map dist2 (dist2 t) =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk125"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose dist2)
  (pure (ap G2 âˆ˜ ap G2 (pure (lam (V:=V)))) &lt;â‹†&gt; b) &lt;â‹†&gt;
dist2 t =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk126"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (precompose dist2))
  (pure (ap G2 âˆ˜ ap G2 (pure (lam (V:=V))))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk127"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (precompose dist2
   âˆ˜ (ap G2 âˆ˜ ap G2 (pure (lam (V:=V))))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
map dist2 (pure (lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk128"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (precompose dist2
   âˆ˜ (ap G2 âˆ˜ ap G2 (pure (lam (V:=V))))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
map (compose dist2) (pure (lam (V:=G2 V)) &lt;â‹†&gt; b) &lt;â‹†&gt;
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk129"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (precompose dist2
   âˆ˜ (ap G2 âˆ˜ ap G2 (pure (lam (V:=V))))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
map (compose (compose dist2)) (pure (lam (V:=G2 V))) &lt;â‹†&gt;
b &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk12a"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>(G1 âˆ˜ G2) B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = map dist2 (dist2 t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (precompose dist2
   âˆ˜ (ap G2 âˆ˜ ap G2 (pure (lam (V:=V))))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
pure (compose dist2 âˆ˜ lam (V:=G2 V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk12b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (tap t1 t2) = map dist2 (dist2 (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk12c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2 =
map dist2
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk12d"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; map dist2 (dist2 t1) &lt;â‹†&gt;
dist2 t2 =
map dist2
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk12e"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; map dist2 (dist2 t1) &lt;â‹†&gt;
map dist2 (dist2 t2) =
map dist2
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk12f">unfold_ops @Pure_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (pure (tap (V:=V))) &lt;â‹†&gt; map dist2 (dist2 t1) &lt;â‹†&gt;
map dist2 (dist2 t2) =
map dist2
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk130"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2)
  (pure (pure (tap (V:=V))) &lt;â‹†&gt; map dist2 (dist2 t1)) &lt;â‹†&gt;
map dist2 (dist2 t2) =
map dist2
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk131"><span class="nb">rewrite</span> (ap_compose2 G2 G1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (ap G2)
  (map (ap G2) (pure (pure (tap (V:=V)))) &lt;â‹†&gt;
   map dist2 (dist2 t1)) &lt;â‹†&gt; map dist2 (dist2 t2) =
map dist2
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk132"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (map (ap G2) (pure (pure (tap (V:=V))))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; map dist2 (dist2 t2) =
map dist2
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk133"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (map (ap G2) (pure (pure (tap (V:=V))))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; map dist2 (dist2 t2) =
map (compose dist2)
  (pure (tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1) &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk134"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (map (ap G2) (pure (pure (tap (V:=V))))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; map dist2 (dist2 t2) =
map (compose (compose dist2)) (pure (tap (V:=G2 V))) &lt;â‹†&gt;
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk135"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (ap G2))
  (pure (ap G2 (pure (tap (V:=V))))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; map dist2 (dist2 t2) =
map (compose (compose dist2)) (pure (tap (V:=G2 V))) &lt;â‹†&gt;
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk136"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (ap G2 âˆ˜ ap G2 (pure (tap (V:=V)))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; map dist2 (dist2 t2) =
map (compose (compose dist2)) (pure (tap (V:=G2 V))) &lt;â‹†&gt;
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk137"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (ap G2 âˆ˜ ap G2 (pure (tap (V:=V)))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; map dist2 (dist2 t2) =
pure (compose dist2 âˆ˜ tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt;
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk138"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose dist2)
  (pure (ap G2 âˆ˜ ap G2 (pure (tap (V:=V)))) &lt;â‹†&gt;
   map dist2 (dist2 t1)) &lt;â‹†&gt; dist2 t2 =
pure (compose dist2 âˆ˜ tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt;
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk139"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (precompose dist2))
  (pure (ap G2 âˆ˜ ap G2 (pure (tap (V:=V))))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; dist2 t2 =
pure (compose dist2 âˆ˜ tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt;
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk13a"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (precompose dist2
   âˆ˜ (ap G2 âˆ˜ ap G2 (pure (tap (V:=V))))) &lt;â‹†&gt;
map dist2 (dist2 t1) &lt;â‹†&gt; dist2 t2 =
pure (compose dist2 âˆ˜ tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt;
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk13b"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose dist2)
  (pure
     (precompose dist2
      âˆ˜ (ap G2 âˆ˜ ap G2 (pure (tap (V:=V)))))) &lt;â‹†&gt;
dist2 t1 &lt;â‹†&gt; dist2 t2 =
pure (compose dist2 âˆ˜ tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt;
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk13c"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1, G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Applicative0</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Applicative1</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term ((G1 âˆ˜ G2) B) ((G1 âˆ˜ G2) V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = map dist2 (dist2 t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = map dist2 (dist2 t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (precompose dist2
     (precompose dist2
      âˆ˜ (ap G2 âˆ˜ ap G2 (pure (tap (V:=V)))))) &lt;â‹†&gt;
dist2 t1 &lt;â‹†&gt; dist2 t2 =
pure (compose dist2 âˆ˜ tap (V:=G2 V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt;
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">naturality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span>: <span class="kt">Type</span>}
    (<span class="nv">Ï</span>: B1 -&gt; B2) (<span class="nv">Ïƒ</span>: V1 -&gt; V2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk13d"><span class="kn">Lemma</span> <span class="nf">dist_map</span> `{Applicative G}:
    map (map2 Ï Ïƒ) âˆ˜ dist_term (G := G) =
      dist_term âˆ˜ map2 (map Ï) (map Ïƒ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) âˆ˜ dist_term =
dist_term âˆ˜ map2 (map Ï) (map Ïƒ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk13e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) âˆ˜ dist_term =
dist_term âˆ˜ map2 (map Ï) (map Ïƒ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk13f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) âˆ˜ dist_term =
dist_term âˆ˜ map2 (map Ï) (map Ïƒ)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk140">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map2 Ï Ïƒ) âˆ˜ dist_term) t =
(dist_term âˆ˜ map2 (map Ï) (map Ïƒ)) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk141"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) (dist_term t) =
dist_term (map2 (map Ï) (map Ïƒ) t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk142"><span class="nb">induction</span> t <span class="kr">as</span> [v | b body IHbody | t1 IHt1 t2 IHt2];
      <span class="nb">change</span> (@nil B2) <span class="kr">with</span> (map Ï nil).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) (dist_term (tvar v)) =
dist_term (map2 (map Ï) (map Ïƒ) (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk143"><hr></label><div class="goal-conclusion">map (map2 Ï Ïƒ) (dist_term (lam b body)) =
dist_term (map2 (map Ï) (map Ïƒ) (lam b body))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk144" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk144"><hr></label><div class="goal-conclusion">map (map2 Ï Ïƒ) (dist_term (tap t1 t2)) =
dist_term (map2 (map Ï) (map Ïƒ) (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk145">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) (dist_term (tvar v)) =
dist_term (map2 (map Ï) (map Ïƒ) (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk146"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) (map tvar v) = map tvar (map Ïƒ v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk147">compose near v on <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map (map2 Ï Ïƒ) âˆ˜ map tvar) v = map tvar (map Ïƒ v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk148"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ âˆ˜ tvar) v = map tvar (map Ïƒ v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk149">compose near v on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ âˆ˜ tvar) v = (map tvar âˆ˜ map Ïƒ) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk14a"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ âˆ˜ tvar) v = map (tvar âˆ˜ Ïƒ) v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk14b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) (dist_term (lam b body)) =
dist_term (map2 (map Ï) (map Ïƒ) (lam b body))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk14c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ)
  (pure (lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt; dist_term body) =
pure (lam (V:=V2)) &lt;â‹†&gt; map Ï b &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk14d"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map2 Ï Ïƒ)) (pure (lam (V:=V1)) &lt;â‹†&gt; b) &lt;â‹†&gt;
dist_term body =
pure (lam (V:=V2)) &lt;â‹†&gt; map Ï b &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk14e"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (map2 Ï Ïƒ)))
  (pure (lam (V:=V1))) &lt;â‹†&gt; b &lt;â‹†&gt; dist_term body =
pure (lam (V:=V2)) &lt;â‹†&gt; map Ï b &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk14f"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body =
pure (lam (V:=V2)) &lt;â‹†&gt; map Ï b &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk150"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body =
map (precompose Ï) (pure (lam (V:=V2))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk151"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body =
pure (precompose Ï (lam (V:=V2))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk152"><span class="nb">rewrite</span> &lt;- IHbody.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body =
pure (precompose Ï (lam (V:=V2))) &lt;â‹†&gt; b &lt;â‹†&gt;
map (map2 Ï Ïƒ) (dist_term body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk153"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body =
map (precompose (map2 Ï Ïƒ))
  (pure (precompose Ï (lam (V:=V2))) &lt;â‹†&gt; b) &lt;â‹†&gt;
dist_term body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk154"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body =
map (compose (precompose (map2 Ï Ïƒ)))
  (pure (precompose Ï (lam (V:=V2)))) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk155"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term body) =
dist_term (map2 (map Ï) (map Ïƒ) body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ lam (V:=V1)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist_term body =
pure
  (precompose (map2 Ï Ïƒ) âˆ˜ precompose Ï (lam (V:=V2))) &lt;â‹†&gt;
b &lt;â‹†&gt; dist_term body</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk156">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ) (dist_term (tap t1 t2)) =
dist_term (map2 (map Ï) (map Ïƒ) (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk157"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (map2 Ï Ïƒ)
  (pure (tap (V:=V1)) &lt;â‹†&gt; dist_term t1 &lt;â‹†&gt;
   dist_term t2) =
pure (tap (V:=V2)) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t1) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk158"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (map2 Ï Ïƒ))
  (pure (tap (V:=V1)) &lt;â‹†&gt; dist_term t1) &lt;â‹†&gt;
dist_term t2 =
pure (tap (V:=V2)) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t1) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk159"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (map2 Ï Ïƒ)))
  (pure (tap (V:=V1))) &lt;â‹†&gt; dist_term t1 &lt;â‹†&gt;
dist_term t2 =
pure (tap (V:=V2)) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t1) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk15a"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
pure (tap (V:=V2)) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t1) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk15b"><span class="nb">rewrite</span> &lt;- IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
pure (tap (V:=V2)) &lt;â‹†&gt; map (map2 Ï Ïƒ) (dist_term t1) &lt;â‹†&gt;
dist_term (map2 (map Ï) (map Ïƒ) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk15c"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
map (precompose (map2 Ï Ïƒ)) (pure (tap (V:=V2))) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term (map2 (map Ï) (map Ïƒ) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk15d"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
pure (precompose (map2 Ï Ïƒ) (tap (V:=V2))) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term (map2 (map Ï) (map Ïƒ) t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk15e"><span class="nb">rewrite</span> &lt;- IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
pure (precompose (map2 Ï Ïƒ) (tap (V:=V2))) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; map (map2 Ï Ïƒ) (dist_term t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk15f"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
map (precompose (map2 Ï Ïƒ))
  (pure (precompose (map2 Ï Ïƒ) (tap (V:=V2))) &lt;â‹†&gt;
   dist_term t1) &lt;â‹†&gt; dist_term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk160"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
map (compose (precompose (map2 Ï Ïƒ)))
  (pure (precompose (map2 Ï Ïƒ) (tap (V:=V2)))) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk161"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t1) =
dist_term (map2 (map Ï) (map Ïƒ) t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>map (map2 Ï Ïƒ) (dist_term t2) =
dist_term (map2 (map Ï) (map Ïƒ) t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (map2 Ï Ïƒ) âˆ˜ tap (V:=V1)) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2 =
pure
  (precompose (map2 Ï Ïƒ)
   âˆ˜ precompose (map2 Ï Ïƒ) (tap (V:=V2))) &lt;â‹†&gt;
dist_term t1 &lt;â‹†&gt; dist_term t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">naturality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk162">#[export] <span class="kn">Instance</span> <span class="nf">Natural_dist2_term</span>:
  <span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G) (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
    Applicative G -&gt; Natural2 (@dist2 term term_dist2 G Map_G Pure_G Mult_G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
Natural2
  (@dist2 term term_dist2 G Map_G Pure_G Mult_G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk163"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
Natural2
  (@dist2 term term_dist2 G Map_G Pure_G Mult_G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk164"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural2
  (@dist2 term term_dist2 G Map_G Pure_G Mult_G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk165"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 (<span class="kr">fun</span> <span class="nv">B</span> : <span class="kt">Type</span> =&gt; term (G B) â—‹ G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk166" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk166"><hr></label><div class="goal-conclusion">Functor2 (compose G â—‹ term)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk167" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk167"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B1 -&gt; B2) 
  (<span class="nv">A1</span> <span class="nv">A2</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A1 -&gt; A2),
map2 g f âˆ˜ dist2 = dist2 âˆ˜ map2 g f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk168">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 (<span class="kr">fun</span> <span class="nv">B</span> : <span class="kt">Type</span> =&gt; term (G B) â—‹ G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk169">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 (compose G â—‹ term)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk16a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">B2</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B1 -&gt; B2) 
  (<span class="nv">A1</span> <span class="nv">A2</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A1 -&gt; A2),
map2 g f âˆ˜ dist2 = dist2 âˆ˜ map2 g f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk16b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g f âˆ˜ dist2 = dist2 âˆ˜ map2 g f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk16c"><span class="nb">apply</span> dist_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>B1, B2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>A1, A2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A1 -&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Applicative G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk16d">#[export] <span class="kn">Instance</span> <span class="nf">TraversableFunctor2_term</span>: TraversableFunctor2 term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TraversableFunctor2 term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk16e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TraversableFunctor2 term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk16f"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
Natural2
  (@dist2 term term_dist2 G Map_G Pure_G Mult_G)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">Ï•</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 Ï• -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dist2 âˆ˜ map2 (Ï• B) (Ï• A) = Ï• (term B A) âˆ˜ dist2</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist2 = id</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G1)
  (<span class="nv">Pure_G</span> : Pure G1) (<span class="nv">Mult_G</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G0</span> : Map G2)
  (<span class="nv">Pure_G0</span> : Pure G2) (<span class="nv">Mult_G0</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist2 = map dist2 âˆ˜ dist2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk170">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk171">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
Natural2
  (@dist2 term term_dist2 G Map_G Pure_G Mult_G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk172">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> <span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">H</span> : Map G1)
  (<span class="nv">H0</span> : Mult G1) (<span class="nv">H1</span> : Pure G1) (<span class="nv">H2</span> : Map G2)
  (<span class="nv">H3</span> : Mult G2) (<span class="nv">H4</span> : Pure G2)
  (<span class="nv">Ï•</span> : <span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, G1 A -&gt; G2 A),
ApplicativeMorphism G1 G2 Ï• -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>,
dist2 âˆ˜ map2 (Ï• B) (Ï• A) = Ï• (term B A) âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dist_term_morph.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk173">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist2 = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk174"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk175">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk176"><span class="nb">unfold</span> id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 t = t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk177"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (tvar v) = tvar v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk178" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = t</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk178"><hr></label><div class="goal-conclusion">dist2 (lam b t) = lam b t</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk179" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk179"><hr></label><div class="goal-conclusion">dist2 (tap t1 t2) = tap t1 t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk17a"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (lam b t) = lam b t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk17b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk17b"><hr></label><div class="goal-conclusion">dist2 (tap t1 t2) = tap t1 t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk17c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=A)) b (dist2 t) = lam b t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk17d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk17d"><hr></label><div class="goal-conclusion">dist2 (tap t1 t2) = tap t1 t2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk17e"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>dist2 t = t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=A)) b t = lam b t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk17f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk17f"><hr></label><div class="goal-conclusion">dist2 (tap t1 t2) = tap t1 t2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk180"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (tap t1 t2) = tap t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk181"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=A)) (dist2 t1) (dist2 t2) = tap t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk182"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 t1 = t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 t2 = t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=A)) t1 t2 = tap t1 t2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk183">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">G1</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) 
  (<span class="nv">Map_G</span> : Map G1) (<span class="nv">Pure_G</span> : Pure G1)
  (<span class="nv">Mult_G</span> : Mult G1),
Applicative G1 -&gt;
<span class="kr">forall</span> (<span class="nv">G2</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) 
  (<span class="nv">Map_G0</span> : Map G2) (<span class="nv">Pure_G0</span> : Pure G2)
  (<span class="nv">Mult_G0</span> : Mult G2),
Applicative G2 -&gt;
<span class="kr">forall</span> <span class="nv">B</span> <span class="nv">A</span> : <span class="kt">Type</span>, dist2 = map dist2 âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk184"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G1</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G1</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G1</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G1</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G1</span></span></span><br><span><var>G2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G0</var><span class="hyp-type"><b>: </b><span>Map G2</span></span></span><br><span><var>Pure_G0</var><span class="hyp-type"><b>: </b><span>Pure G2</span></span></span><br><span><var>Mult_G0</var><span class="hyp-type"><b>: </b><span>Mult G2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Applicative G2</span></span></span><br><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 = map dist2 âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> dist_term_linear; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="join">
<h1>Join</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">join_term</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>} (<span class="nv">t</span>: term B (term B V)): term B V :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | tvar v =&gt; v
  | lam b body =&gt; lam b (join_term body)
  | tap t1 t2 =&gt; tap (join_term t1) (join_term t2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk185"><span class="kn">Lemma</span> <span class="nf">join_ret_term</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>}:
  join_term âˆ˜ ret (A := term B V) = @id (term B V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term âˆ˜ ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk186"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term âˆ˜ ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk187"><span class="kn">Lemma</span> <span class="nf">join_map_ret_term</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>}:
  join_term âˆ˜ map2 (@id B) (ret (A := V)) = @id (term B V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term âˆ˜ map2 id ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk188"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term âˆ˜ map2 id ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk189">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(join_term âˆ˜ map2 id ret) t = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk18a"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (map2 id ret t) = id t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk18b"><span class="nb">induction</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (map2 id ret (tvar v)) = id (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk18c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t) = id t</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk18c"><hr></label><div class="goal-conclusion">join_term (map2 id ret (lam b t)) = id (lam b t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk18d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t2) = id t2</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk18d"><hr></label><div class="goal-conclusion">join_term (map2 id ret (tap t1 t2)) = id (tap t1 t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk18e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (map2 id ret (tvar v)) = id (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk18f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t) = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (map2 id ret (lam b t)) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk190"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t) = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (id b) (join_term (map2 id ret t)) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk191"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t) = id t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (id b) (id t) = id (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk192">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t2) = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (map2 id ret (tap t1 t2)) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk193"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t2) = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (join_term (map2 id ret t1))
  (join_term (map2 id ret t2)) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk194"><span class="nb">rewrite</span> IHt1, IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t1) = id t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (map2 id ret t2) = id t2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (id t1) (id t2) = id (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk195"><span class="kn">Lemma</span> <span class="nf">join_join_term</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>}:
  join_term âˆ˜ join_term (B := B) (V := term B V) =
    join_term âˆ˜ map2 id (join_term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term âˆ˜ join_term = join_term âˆ˜ map2 id join_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk196"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term âˆ˜ join_term = join_term âˆ˜ map2 id join_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk197"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term âˆ˜ join_term = join_term âˆ˜ map2 id join_term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk198">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(join_term âˆ˜ join_term) t =
(join_term âˆ˜ map2 id join_term) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk199"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (join_term t) =
join_term (map2 id join_term t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk19a"><span class="nb">induction</span> t <span class="kr">as</span> [v | b body IHbody | t1 IHt1 t2 IHt2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (join_term (tvar v)) =
join_term (map2 id join_term (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk19b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join_term (join_term body) =
join_term (map2 id join_term body)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk19b"><hr></label><div class="goal-conclusion">join_term (join_term (lam b body)) =
join_term (map2 id join_term (lam b body))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk19c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (join_term t1) =
join_term (map2 id join_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (join_term t2) =
join_term (map2 id join_term t2)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk19c"><hr></label><div class="goal-conclusion">join_term (join_term (tap t1 t2)) =
join_term (map2 id join_term (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk19d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (join_term (tvar v)) =
join_term (map2 id join_term (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk19e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join_term (join_term body) =
join_term (map2 id join_term body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (join_term (lam b body)) =
join_term (map2 id join_term (lam b body))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk19f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join_term (join_term body) =
join_term (map2 id join_term body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam b (join_term (join_term body)) =
lam (id b) (join_term (map2 id join_term body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a0"><span class="nb">rewrite</span> IHbody.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join_term (join_term body) =
join_term (map2 id join_term body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam b (join_term (map2 id join_term body)) =
lam (id b) (join_term (map2 id join_term body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (join_term t1) =
join_term (map2 id join_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (join_term t2) =
join_term (map2 id join_term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join_term (join_term (tap t1 t2)) =
join_term (map2 id join_term (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a2"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (join_term t1) =
join_term (map2 id join_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (join_term t2) =
join_term (map2 id join_term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (join_term (join_term t1))
  (join_term (join_term t2)) =
tap (join_term (map2 id join_term t1))
  (join_term (map2 id join_term t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a3"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (join_term t1) =
join_term (map2 id join_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (join_term t2) =
join_term (map2 id join_term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (join_term (map2 id join_term t1))
  (join_term (join_term t2)) =
tap (join_term (map2 id join_term t1))
  (join_term (map2 id join_term t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a4"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B (term B V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join_term (join_term t1) =
join_term (map2 id join_term t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join_term (join_term t2) =
join_term (map2 id join_term t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (join_term (map2 id join_term t1))
  (join_term (map2 id join_term t2)) =
tap (join_term (map2 id join_term t1))
  (join_term (map2 id join_term t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Join_lambda_term</span>: <span class="kr">forall</span> <span class="nv">B</span>, Join (term B) :=
  @join_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">join_term_rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a5"><span class="kn">Lemma</span> <span class="nf">join_term_rw1</span>: <span class="kr">forall</span> (<span class="nv">v</span>: term B V),
      join (tvar (B := B) v) = v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : term B V, join (tvar v) = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">v</span> : term B V, join (tvar v) = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a7"><span class="kn">Lemma</span> <span class="nf">join_term_rw2</span>: <span class="kr">forall</span> (<span class="nv">b</span>: B) (<span class="nv">body</span>: term B (term B V)),
      join (lam b body) = lam b (join body).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B (term B V)),
join (lam b body) = lam b (join body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">body</span> : term B (term B V)),
join (lam b body) = lam b (join body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1a9"><span class="kn">Lemma</span> <span class="nf">join_term_rw3</span>: <span class="kr">forall</span> (<span class="nv">t1</span> <span class="nv">t2</span>: term B (term B V)),
      join (tap t1 t2) = tap (join t1) (join t2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B (term B V),
join (tap t1 t2) = tap (join t1) (join t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1aa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">t2</span> : term B (term B V),
join (tap t1 t2) = tap (join t1) (join t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">join_term_rewriting</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">naturality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span>: <span class="kt">Type</span>}
    (<span class="nv">Ï</span>: B1 -&gt; B2) (<span class="nv">Ïƒ</span>: V1 -&gt; V2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ab"><span class="kn">Lemma</span> <span class="nf">join_map</span>:
    join (T := term B2) âˆ˜ map2 Ï (map2 Ï Ïƒ) =
      map2 Ï Ïƒ âˆ˜ (join (T := term B1) (A := V1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ map2 Ï (map2 Ï Ïƒ) = map2 Ï Ïƒ âˆ˜ join</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ map2 Ï (map2 Ï Ïƒ) = map2 Ï Ïƒ âˆ˜ join</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ad">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(join âˆ˜ map2 Ï (map2 Ï Ïƒ)) t = (map2 Ï Ïƒ âˆ˜ join) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ae"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join (map2 Ï (map2 Ï Ïƒ) t) = map2 Ï Ïƒ (join t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1af"><span class="nb">induction</span> t <span class="kr">as</span> [v | b body IHbody | t1 IHt1 t2 IHt2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join (map2 Ï (map2 Ï Ïƒ) (tvar v)) =
map2 Ï Ïƒ (join (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) body) =
map2 Ï Ïƒ (join body)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1b0"><hr></label><div class="goal-conclusion">join (map2 Ï (map2 Ï Ïƒ) (lam b body)) =
map2 Ï Ïƒ (join (lam b body))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1b1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t1) =
map2 Ï Ïƒ (join t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t2) =
map2 Ï Ïƒ (join t2)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1b1"><hr></label><div class="goal-conclusion">join (map2 Ï (map2 Ï Ïƒ) (tap t1 t2)) =
map2 Ï Ïƒ (join (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B1 V1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join (map2 Ï (map2 Ï Ïƒ) (tvar v)) =
map2 Ï Ïƒ (join (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) body) =
map2 Ï Ïƒ (join body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join (map2 Ï (map2 Ï Ïƒ) (lam b body)) =
map2 Ï Ïƒ (join (lam b body))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b4"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) body) =
map2 Ï Ïƒ (join body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (Ï b) (join (map2 Ï (map2 Ï Ïƒ) body)) =
lam (Ï b) (map2 Ï Ïƒ (join body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b5"><span class="nb">rewrite</span> IHbody.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) body) =
map2 Ï Ïƒ (join body)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (Ï b) (map2 Ï Ïƒ (join body)) =
lam (Ï b) (map2 Ï Ïƒ (join body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t1) =
map2 Ï Ïƒ (join t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t2) =
map2 Ï Ïƒ (join t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join (map2 Ï (map2 Ï Ïƒ) (tap t1 t2)) =
map2 Ï Ïƒ (join (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b7"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t1) =
map2 Ï Ïƒ (join t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t2) =
map2 Ï Ïƒ (join t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (join (map2 Ï (map2 Ï Ïƒ) t1))
  (join (map2 Ï (map2 Ï Ïƒ) t2)) =
tap (map2 Ï Ïƒ (join t1)) (map2 Ï Ïƒ (join t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b8"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t1) =
map2 Ï Ïƒ (join t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t2) =
map2 Ï Ïƒ (join t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 Ï Ïƒ (join t1)) (join (map2 Ï (map2 Ï Ïƒ) t2)) =
tap (map2 Ï Ïƒ (join t1)) (map2 Ï Ïƒ (join t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1b9"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>B1 -&gt; B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>V1 -&gt; V2</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B1 (term B1 V1)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t1) =
map2 Ï Ïƒ (join t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>join (map2 Ï (map2 Ï Ïƒ) t2) =
map2 Ï Ïƒ (join t2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (map2 Ï Ïƒ (join t1)) (map2 Ï Ïƒ (join t2)) =
tap (map2 Ï Ïƒ (join t1)) (map2 Ï Ïƒ (join t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">naturality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ba">#[export] <span class="kn">Instance</span> <span class="nf">Monad_term</span>: <span class="kr">forall</span> <span class="nv">B</span>, Monad (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, Monad (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1bb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> : <span class="kt">Type</span>, Monad (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1bc"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1bd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1bd"><hr></label><div class="goal-conclusion">Natural (@ret (term B) (Return_lambda_term B))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1be"><hr></label><div class="goal-conclusion">Natural (@join (term B) (Join_lambda_term B))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1bf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1bf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join âˆ˜ ret = id</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1c0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1c0"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join âˆ˜ map ret = id</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1c1"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join âˆ˜ join = join âˆ˜ map join</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@ret (term B) (Return_lambda_term B))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c4"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B0),
map f âˆ˜ ret = ret âˆ˜ map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f âˆ˜ ret = ret âˆ˜ map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Natural (@join (term B) (Join_lambda_term B))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c7"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B0</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B0),
map f âˆ˜ join = join âˆ˜ map f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c8"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f âˆ˜ join = join âˆ˜ map f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1c9"><span class="nb">unfold</span> map, Map2_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 id f âˆ˜ join =
join âˆ˜ Map_compose (term B) (term B) A B0 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ca"><span class="nb">rewrite</span> &lt;- join_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, B0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ map2 id (map2 id f) =
join âˆ˜ Map_compose (term B) (term B) A B0 f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1cb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join âˆ˜ ret = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1cc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ ret = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1cd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join âˆ˜ map ret = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ce"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ map ret = id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1cf"><span class="nb">unfold</span> map, Map2_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ map2 id ret = id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> join_map_ret_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, join âˆ˜ join = join âˆ˜ map join</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ join = join âˆ˜ map join</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d2"><span class="nb">unfold</span> map, Map2_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ join = join âˆ˜ map2 id join</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> join_join_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="distribution-and-decoration">
<h1>Distribution and Decoration</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d3"><span class="kn">Lemma</span> <span class="nf">dist_dec_rec_commute</span>:
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>)
    `{ApplicativeCommutativeIdempotent G}
    (ctx: list (G B))
    (t: term (G B) (G V)),
    dist2 (T := term) (G := G) (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
      pure (dec_term_rec (B := B) (V := V)) &lt;â‹†&gt; (dist list G ctx)
        &lt;â‹†&gt; (dist2 (T := term) (G := G) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutativeIdempotent G -&gt;
<span class="kr">forall</span> (<span class="nv">ctx</span> : list (G B)) (<span class="nv">t</span> : term (G B) (G V)),
dist2 (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutativeIdempotent G -&gt;
<span class="kr">forall</span> (<span class="nv">ctx</span> : list (G B)) (<span class="nv">t</span> : term (G B) (G V)),
dist2 (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d6"><span class="nb">generalize dependent</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2 (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1d7"><span class="nb">induction</span> t; <span class="nb">intro</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx (tvar v))) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 (tvar v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1d8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1d8"><hr></label><div class="goal-conclusion">dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx (lam b t))) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 (lam b t)</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk1d9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk1d9"><hr></label><div class="goal-conclusion">dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx (tap t1 t2))) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 (tap t1 t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx (tvar v))) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 (tvar v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1db"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map tvar (pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; map tvar v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1dc"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose tvar) (pure pair &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
v =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; map tvar v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1dd"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose tvar)) (pure pair) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; v =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; map tvar v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1de"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; map tvar v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1df"><span class="nb">rewrite</span> map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure tvar &lt;â‹†&gt; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e0"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure compose &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; 
pure tvar &lt;â‹†&gt; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e1"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure tvar &lt;â‹†&gt; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e2"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure (compose compose) &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure tvar &lt;â‹†&gt; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e3"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure (compose âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
pure tvar &lt;â‹†&gt; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e4"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure (evalAt tvar) &lt;â‹†&gt;
(pure (compose âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure compose &lt;â‹†&gt; pure (evalAt tvar) &lt;â‹†&gt;
pure (compose âˆ˜ dec_term_rec) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e6"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure (compose (evalAt tvar)) &lt;â‹†&gt;
pure (compose âˆ˜ dec_term_rec) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e7"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>G V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose tvar âˆ˜ pair) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; v =
pure (evalAt tvar âˆ˜ (compose âˆ˜ dec_term_rec)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx (lam b t))) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 (lam b t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1e9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=Z2 B V)) &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt;
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec (ctx ++ [b]) t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* LHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ea"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (lam (V:=Z2 B V)) &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec (ctx ++ [b]) t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1eb"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (lam (V:=Z2 B V))) &lt;â‹†&gt;
(pure pair &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec (ctx ++ [b]) t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ec"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (lam (V:=Z2 B V))) &lt;â‹†&gt;
pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt;
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec (ctx ++ [b]) t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ed"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (lam (V:=Z2 B V)))) &lt;â‹†&gt;
pure pair &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt;
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec (ctx ++ [b]) t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ee"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt;
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec (ctx ++ [b]) t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ef"><span class="nb">rewrite</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
 dist2 t) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f0"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b])) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f1"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
  dist list G ctx &lt;â‹†&gt; b)) &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f2"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f3"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f4"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f5"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f6"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f7"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f8"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (compose âˆ˜ compose))) &lt;â‹†&gt;
pure (compose (lam (V:=Z2 B V)) âˆ˜ pair) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1f9"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
pure dec_term_rec &lt;â‹†&gt; dist list G (ctx ++ [b]) &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1fa"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt dec_term_rec) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
dist list G (ctx ++ [b]) &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1fb"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt dec_term_rec) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G (ctx ++ [b]) &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1fc"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt dec_term_rec)) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G (ctx ++ [b]) &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1fd"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (evalAt dec_term_rec)) &lt;â‹†&gt;
pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G (ctx ++ [b]) &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1fe"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (evalAt dec_term_rec))) &lt;â‹†&gt;
pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G (ctx ++ [b]) &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk1ff"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (evalAt dec_term_rec)
   âˆ˜ (compose (compose âˆ˜ compose)
      âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G (ctx ++ [b]) &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk200"><span class="nb">rewrite</span> dist_list_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (evalAt dec_term_rec)
   âˆ˜ (compose (compose âˆ˜ compose)
      âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt;
(pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
 dist list G [b]) &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk201"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure
   (compose (evalAt dec_term_rec)
    âˆ˜ (compose (compose âˆ˜ compose)
       âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt;
(pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk202"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure
    (compose (evalAt dec_term_rec)
     âˆ˜ (compose (compose âˆ˜ compose)
        âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
  dist list G ctx &lt;â‹†&gt; b)) &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk203"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure
   (compose (evalAt dec_term_rec)
    âˆ˜ (compose (compose âˆ˜ compose)
       âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk204"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure
   (compose (evalAt dec_term_rec)
    âˆ˜ (compose (compose âˆ˜ compose)
       âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk205"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure
   (compose (evalAt dec_term_rec)
    âˆ˜ (compose (compose âˆ˜ compose)
       âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk206"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure
   (compose (evalAt dec_term_rec)
    âˆ˜ (compose (compose âˆ˜ compose)
       âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk207"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
(pure
   (compose (evalAt dec_term_rec)
    âˆ˜ (compose (compose âˆ˜ compose)
       âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk208"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure
  (compose (evalAt dec_term_rec)
   âˆ˜ (compose (compose âˆ˜ compose)
      âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk209"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (compose âˆ˜ compose))) &lt;â‹†&gt;
pure
  (compose (evalAt dec_term_rec)
   âˆ˜ (compose (compose âˆ˜ compose)
      âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk20a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (evalAt dec_term_rec)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
pure (app (A:=B)) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist list G [b] &lt;â‹†&gt; dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk20b"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt (app (A:=B))) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (evalAt dec_term_rec)
       âˆ˜ (compose (compose âˆ˜ compose)
          âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))) &lt;â‹†&gt;
 dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G [b] &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk20c"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (evalAt (app (A:=B))) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (evalAt dec_term_rec)
       âˆ˜ (compose (compose âˆ˜ compose)
          âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G [b] &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk20d"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt (app (A:=B)))) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose)
    âˆ˜ (compose (evalAt dec_term_rec)
       âˆ˜ (compose (compose âˆ˜ compose)
          âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G [b] &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk20e"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt; pure (compose (evalAt (app (A:=B)))) &lt;â‹†&gt;
pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (evalAt dec_term_rec)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G [b] &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk20f"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose (evalAt (app (A:=B))))) &lt;â‹†&gt;
pure
  (compose (compose âˆ˜ compose)
   âˆ˜ (compose (evalAt dec_term_rec)
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G [b] &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk210"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (evalAt (app (A:=B)))
   âˆ˜ (compose (compose âˆ˜ compose)
      âˆ˜ (compose (evalAt dec_term_rec)
         âˆ˜ (compose (compose âˆ˜ compose)
            âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G [b] &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk211"><span class="nb">rewrite</span> dist_list_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (evalAt (app (A:=B)))
   âˆ˜ (compose (compose âˆ˜ compose)
      âˆ˜ (compose (evalAt dec_term_rec)
         âˆ˜ (compose (compose âˆ˜ compose)
            âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; map ret b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk212"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose ret)
  (pure
     (compose (evalAt (app (A:=B)))
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt dec_term_rec)
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))))) &lt;â‹†&gt;
   dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
   dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk213"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (precompose ret))
  (pure
     (compose (evalAt (app (A:=B)))
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt dec_term_rec)
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))))) &lt;â‹†&gt;
   dist list G ctx &lt;â‹†&gt; b) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk214"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (precompose ret)))
  (pure
     (compose (evalAt (app (A:=B)))
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt dec_term_rec)
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))))) &lt;â‹†&gt;
   dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk215"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose (compose (precompose ret))))
  (pure
     (compose (evalAt (app (A:=B)))
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt dec_term_rec)
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk216"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose (precompose ret))
   âˆ˜ (compose (evalAt (app (A:=B)))
      âˆ˜ (compose (compose âˆ˜ compose)
         âˆ˜ (compose (evalAt dec_term_rec)
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair)))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk217"><span class="nb">rewrite</span> (ap_flip_x3 (lhs := b) (rhs := dist list G ctx)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose flip)
  (pure
     (compose (compose (precompose ret))
      âˆ˜ (compose (evalAt (app (A:=B)))
         âˆ˜ (compose (compose âˆ˜ compose)
            âˆ˜ (compose (evalAt dec_term_rec)
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk218"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
   âˆ˜ (compose (compose (precompose ret))
      âˆ˜ (compose (evalAt (app (A:=B)))
         âˆ˜ (compose (compose âˆ˜ compose)
            âˆ˜ (compose (evalAt dec_term_rec)
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (lam (V:=Z2 B V)) âˆ˜ pair))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk219"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map double_input
  (pure
     (flip
      âˆ˜ (compose (compose (precompose ret))
         âˆ˜ (compose (evalAt (app (A:=B)))
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (evalAt dec_term_rec)
                  âˆ˜ (compose (compose âˆ˜ compose)
                     âˆ˜ (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))) &lt;â‹†&gt;
   dist list G ctx &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk21a"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose double_input)
  (pure
     (flip
      âˆ˜ (compose (compose (precompose ret))
         âˆ˜ (compose (evalAt (app (A:=B)))
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (evalAt dec_term_rec)
                  âˆ˜ (compose (compose âˆ˜ compose)
                     âˆ˜ (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))) &lt;â‹†&gt;
   dist list G ctx) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk21b"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (compose double_input))
  (pure
     (flip
      âˆ˜ (compose (compose (precompose ret))
         âˆ˜ (compose (evalAt (app (A:=B)))
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (evalAt dec_term_rec)
                  âˆ˜ (compose (compose âˆ˜ compose)
                     âˆ˜ (compose (lam (V:=Z2 B V))
                        âˆ˜ pair)))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk21c"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose double_input
   âˆ˜ (flip
      âˆ˜ (compose (compose (precompose ret))
         âˆ˜ (compose (evalAt (app (A:=B)))
            âˆ˜ (compose (compose âˆ˜ compose)
               âˆ˜ (compose (evalAt dec_term_rec)
                  âˆ˜ (compose (compose âˆ˜ compose)
                     âˆ˜ (compose (lam (V:=Z2 B V))
                        âˆ˜ pair)))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk21d"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map double_input
  (pure
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk21e"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk21f"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure compose &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
(pure (lam (V:=V)) &lt;â‹†&gt; b) &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk220"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure dec_term_rec &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk221"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk222"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure (compose compose) &lt;â‹†&gt; pure compose &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk223"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk224"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure compose &lt;â‹†&gt; pure (compose âˆ˜ compose) &lt;â‹†&gt;
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk225"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure (compose (compose âˆ˜ compose)) &lt;â‹†&gt;
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk226"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk227"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure (evalAt (lam (V:=V))) &lt;â‹†&gt;
(pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk228"><span class="nb">rewrite</span> &lt;- ap4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure compose &lt;â‹†&gt; pure (evalAt (lam (V:=V))) &lt;â‹†&gt;
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk229"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure (compose (evalAt (lam (V:=V)))) &lt;â‹†&gt;
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk22a"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (compose double_input
      âˆ˜ (flip
         âˆ˜ (compose (compose (precompose ret))
            âˆ˜ (compose (evalAt (app (A:=B)))
               âˆ˜ (compose (compose âˆ˜ compose)
                  âˆ˜ (compose (evalAt dec_term_rec)
                     âˆ˜ (compose (compose âˆ˜ compose)
                        âˆ˜ 
                        (compose (lam (V:=Z2 B V))
                        âˆ˜ pair))))))))) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t =
pure
  (evalAt (lam (V:=V))
   âˆ˜ (compose âˆ˜ compose âˆ˜ dec_term_rec)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; b &lt;â‹†&gt; 
dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk22b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx (tap t1 t2))) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 (tap t1 t2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk22c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=Z2 B V)) &lt;â‹†&gt;
dist2 (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) &lt;â‹†&gt;
dist2 (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk22d"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=Z2 B V)) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t1) &lt;â‹†&gt;
dist2 (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk22e"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=Z2 B V)) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t1) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t2) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk22f"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure (tap (V:=Z2 B V)) &lt;â‹†&gt;
 (pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t1)) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; 
dist2 t2 =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk230"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure (tap (V:=Z2 B V)) &lt;â‹†&gt;
  (pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t1))) &lt;â‹†&gt;
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t2 =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk231"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure (tap (V:=Z2 B V)) &lt;â‹†&gt;
 (pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t1)) &lt;â‹†&gt;
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t2 =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk232"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V)) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; dist2 t1) &lt;â‹†&gt;
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t2 =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk233"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t2 =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk234"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
   âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t2 =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk235"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
   âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t2 =
pure compose &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
(pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1) &lt;â‹†&gt; 
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk236"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
   âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t2 =
pure compose &lt;â‹†&gt;
(pure compose &lt;â‹†&gt;
 (pure dec_term_rec &lt;â‹†&gt; dist list G ctx)) &lt;â‹†&gt;
pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk237"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
   âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t2 =
pure (compose âˆ˜ compose) &lt;â‹†&gt;
(pure dec_term_rec &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt;
pure (tap (V:=V)) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk238"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
   âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; pure dec_term_rec &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk239"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (evalAt dec_term_rec) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
    âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
 dist2 t1) &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk23a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk23a"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (compose (evalAt dec_term_rec)) &lt;â‹†&gt;
(pure
   (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
    âˆ˜ dec_term_rec) &lt;â‹†&gt; dist list G ctx) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk23b"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (compose (evalAt dec_term_rec)
   âˆ˜ (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
      âˆ˜ dec_term_rec)) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk23c"><span class="nb">rewrite</span> (ap_flip_x3 (G := G)
               (lhs := dist2 (T := term) (G := G) t1)
               (rhs := dist list G ctx)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose flip)
  (pure
     (compose (evalAt dec_term_rec)
      âˆ˜ (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
         âˆ˜ dec_term_rec))) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk23d"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (flip
   âˆ˜ (compose (evalAt dec_term_rec)
      âˆ˜ (compose (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
         âˆ˜ dec_term_rec))) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk23e"><span class="nb">rewrite</span> ap_contract.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map double_input
  (pure
     (flip
      âˆ˜ (compose (evalAt dec_term_rec)
         âˆ˜ (compose
              (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
            âˆ˜ dec_term_rec)))) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk23f"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      âˆ˜ (compose (evalAt dec_term_rec)
         âˆ˜ (compose
              (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
            âˆ˜ dec_term_rec)))) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2 =
pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; pure (tap (V:=V)) &lt;â‹†&gt; 
dist2 t1 &lt;â‹†&gt; dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk240"><span class="nb">rewrite</span> ap3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      âˆ˜ (compose (evalAt dec_term_rec)
         âˆ˜ (compose
              (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
            âˆ˜ dec_term_rec)))) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2 =
pure (evalAt (tap (V:=V))) &lt;â‹†&gt;
(pure (compose âˆ˜ compose âˆ˜ dec_term_rec) &lt;â‹†&gt;
 dist list G ctx) &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk241"><span class="nb">rewrite</span> &lt;- ap4; <span class="kp">repeat</span> <span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t1)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t1</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list (G B),
dist2
  (map2 dist_Z dist2_Z2 (dec_term_rec ctx t2)) =
pure dec_term_rec &lt;â‹†&gt; dist list G ctx &lt;â‹†&gt;
dist2 t2</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure
  (double_input
     (flip
      âˆ˜ (compose (evalAt dec_term_rec)
         âˆ˜ (compose
              (compose âˆ˜ compose âˆ˜ tap (V:=Z2 B V))
            âˆ˜ dec_term_rec)))) &lt;â‹†&gt; 
dist list G ctx &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2 =
pure
  (evalAt (tap (V:=V))
   âˆ˜ (compose âˆ˜ compose âˆ˜ dec_term_rec)) &lt;â‹†&gt;
dist list G ctx &lt;â‹†&gt; dist2 t1 &lt;â‹†&gt; 
dist2 t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk242"><span class="kn">Lemma</span> <span class="nf">dist_dec_commute</span>:
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>)
    `{ApplicativeCommutativeIdempotent G}
    (t: term (G B) (G V)),
    dist2 (T := term) (G := G) (map2 dist_Z dist2_Z2 (dec_term t)) =
      pure (dec_term (B := B) (V := V)) &lt;â‹†&gt; (dist2 (T := term) (G := G) t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutativeIdempotent G -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term (G B) (G V),
dist2 (map2 dist_Z dist2_Z2 (dec_term t)) =
pure dec_term &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk243"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutativeIdempotent G -&gt;
<span class="kr">forall</span> <span class="nv">t</span> : term (G B) (G V),
dist2 (map2 dist_Z dist2_Z2 (dec_term t)) =
pure dec_term &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk244"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 dist_Z dist2_Z2 (dec_term t)) =
pure dec_term &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk245"><span class="nb">unfold</span> dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 dist_Z dist2_Z2 (dec_term_rec [] t)) =
pure (dec_term_rec []) &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk246"><span class="nb">rewrite</span> dist_dec_rec_commute; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure dec_term_rec &lt;â‹†&gt; dist list G [] &lt;â‹†&gt; dist2 t =
pure (dec_term_rec []) &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk247"><span class="nb">rewrite</span> dist_list_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure dec_term_rec &lt;â‹†&gt; pure [] &lt;â‹†&gt; dist2 t =
pure (dec_term_rec []) &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk248"><span class="nb">rewrite</span> ap2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (dec_term_rec []) &lt;â‹†&gt; dist2 t =
pure (dec_term_rec []) &lt;â‹†&gt; dist2 t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk249"><span class="kn">Lemma</span> <span class="nf">dist_dec_commute2</span>:
  <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>)
    `{ApplicativeCommutativeIdempotent G},
    dist2 (T := term) (G := G) âˆ˜ map2 (dist_Z (G := G)) (dist2_Z2 (G := G)) âˆ˜ dec_term =
      map (dec_term (B := B) (V := V)) âˆ˜
        (dist2 (T := term) (G := G) (B := B) (A := V)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutativeIdempotent G -&gt;
dist2 âˆ˜ map2 dist_Z dist2_Z2 âˆ˜ dec_term =
map dec_term âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk24a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk24a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutativeIdempotent G -&gt;
dist2 âˆ˜ map2 dist_Z dist2_Z2 âˆ˜ dec_term =
map dec_term âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk24b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 âˆ˜ map2 dist_Z dist2_Z2 âˆ˜ dec_term =
map dec_term âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk24c">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(dist2 âˆ˜ map2 dist_Z dist2_Z2 âˆ˜ dec_term) t =
(map dec_term âˆ˜ dist2) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk24d"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (map2 dist_Z dist2_Z2 (dec_term t)) =
map dec_term (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk24e"><span class="nb">rewrite</span> dist_dec_commute; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure dec_term &lt;â‹†&gt; dist2 t = map dec_term (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk24f"><span class="nb">rewrite</span> &lt;- map_to_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map dec_term (dist2 t) = map dec_term (dist2 t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk250"><span class="kn">Lemma</span> <span class="nf">dist_dec_rec_commute_map</span>:
  <span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span>: <span class="kt">Type</span>)
    `{Applicative G}
    (ctx: list (G B1))
    (t: term (G B1) (G V1))
    (Ï: list B1 * B1 -&gt; G B2)
    (Ïƒ: list B1 * V1 -&gt; G V2),
    <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">Map_G</span> : Map G) (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
list (G B1) -&gt;
term (G B1) (G V1) -&gt;
(list B1 * B1 -&gt; G B2) -&gt;
(list B1 * V1 -&gt; G V2) -&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk251"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B1</span> <span class="nv">V1</span> <span class="nv">B2</span> <span class="nv">V2</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
  (<span class="nv">Map_G</span> : Map G) (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
list (G B1) -&gt;
term (G B1) (G V1) -&gt;
(list B1 * B1 -&gt; G B2) -&gt;
(list B1 * V1 -&gt; G V2) -&gt; <span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk252"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B1, V1, B2, V2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list (G B1)</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>term (G B1) (G V1)</span></span></span><br><span><var>Ï</var><span class="hyp-type"><b>: </b><span>list B1 * B1 -&gt; G B2</span></span></span><br><span><var>Ïƒ</var><span class="hyp-type"><b>: </b><span>list B1 * V1 -&gt; G V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(*</span>
<span class="c">  Check</span>
<span class="c">    (map_term dist_pair dist_pair</span>
<span class="c">       (dec_term_rec ctx</span>
<span class="c">          (map_term Ï Ïƒ t)).</span>
<span class="c">    dist2 (map_term dist_pair dist_pair (dec_term_rec ctx t)) =</span>
<span class="c">      pure (dec_term_rec (B := B1) (V := V1)) &lt;â‹†&gt; (dist list G ctx)</span>
<span class="c">        &lt;â‹†&gt; (dist2 t).</span>
<span class="c">   *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre></div>
<div class="section" id="join-and-decoration">
<h1>Join and Decoration</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk253"><span class="kn">Lemma</span> <span class="nf">decorate_ret_term</span>: <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>) (<span class="nv">V</span>: V),
    dec_term (ret (T := term B) V) =
      ret ([], V).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">V0</span> : V),
dec_term (ret V0) = ret ([], V0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk254"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">V0</span> : V),
dec_term (ret V0) = ret ([], V0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk255"><span class="kn">Lemma</span> <span class="nf">decorate_rec_join_term</span>: <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>) (<span class="nv">ctx</span>: list B),
    dec_term_rec ctx âˆ˜ join (T := term B) (A := V) =
      join (T := term (list B * B))
        âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term)
        âˆ˜ dec_term_rec ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
dec_term_rec ctx âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term)
âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk256"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">ctx</span> : list B),
dec_term_rec ctx âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term)
âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk257"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term)
âˆ˜ dec_term_rec ctx</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk258">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term B âˆ˜ term B) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(dec_term_rec ctx âˆ˜ join) t =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term)
 âˆ˜ dec_term_rec ctx) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk259"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term B âˆ˜ term B) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx (join t) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk25a"><span class="nb">generalize dependent</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term B âˆ˜ term B) V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk25b"><span class="nb">induction</span> t <span class="kr">as</span> [v | b body IHbody | t1 IHt1 t2 IHt2 ]; <span class="nb">intro</span> ctx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx (join (tvar v)) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (tvar v))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk25c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join body) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk25c"><hr></label><div class="goal-conclusion">dec_term_rec ctx (join (lam b body)) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (lam b body))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk25d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t1) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t2) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk25d"><hr></label><div class="goal-conclusion">dec_term_rec ctx (join (tap t1 t2)) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (tap t1 t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk25e">- <span class="c">(* LHS *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx (join (tvar v)) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk25f"><span class="nb">rewrite</span> join_term_rw1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx v =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk260"><span class="nb">rewrite</span> dec_rec_spec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (incr ctx) (incr ctx) âˆ˜ dec_term) v =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (tvar v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* RHS *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk261"><span class="nb">rewrite</span> dec_term_rec_rw1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (incr ctx) (incr ctx) âˆ˜ dec_term) v =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (tvar (ctx, v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk262"><span class="nb">unfold</span> compose <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (incr ctx) (incr ctx) âˆ˜ dec_term) v =
join
  (map2 id (shift2 âˆ˜ map_snd dec_term) (tvar (ctx, v)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk263"><span class="nb">rewrite</span> map2_term_rw1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (incr ctx) (incr ctx) âˆ˜ dec_term) v =
join (tvar ((shift2 âˆ˜ map_snd dec_term) (ctx, v)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk264"><span class="nb">rewrite</span> join_term_rw1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (incr ctx) (incr ctx) âˆ˜ dec_term) v =
(shift2 âˆ˜ map_snd dec_term) (ctx, v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk265"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (incr ctx) (incr ctx) âˆ˜ dec_term) v =
map2 (Datatypes.uncurry incr) 
  (Datatypes.uncurry incr)
  (map2 (pair (id ctx)) (pair (id ctx)) (dec_term v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk266">compose near (dec_term v) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2 (incr ctx) (incr ctx) âˆ˜ dec_term) v =
(map2 (Datatypes.uncurry incr)
   (Datatypes.uncurry incr)
 âˆ˜ map2 (pair (id ctx)) (pair (id ctx))) 
  (dec_term v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk267"><span class="nb">unfold</span> map2, Map2_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2_term (incr ctx) (incr ctx) âˆ˜ dec_term) v =
(map2_term (Datatypes.uncurry incr)
   (Datatypes.uncurry incr)
 âˆ˜ map2_term (pair (id ctx)) (pair (id ctx)))
  (dec_term v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk268"><span class="nb">rewrite</span> (map2_map2_term).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term B V</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(map2_term (incr ctx) (incr ctx) âˆ˜ dec_term) v =
map2_term (Datatypes.uncurry incr âˆ˜ pair (id ctx))
  (Datatypes.uncurry incr âˆ˜ pair (id ctx))
  (dec_term v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk269">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join body) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx (join (lam b body)) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (lam b body))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk26a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join body) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lam (ctx, b) (dec_term_rec (ctx ++ [b]) (join body)) =
lam (id (ctx, b))
  (join
     (map2 id (shift2 âˆ˜ map_snd dec_term)
        (dec_term_rec (ctx ++ [b]) body)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk26b">fequal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join body) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec (ctx ++ [b]) (join body) =
join
  (map2 id (shift2 âˆ˜ map_snd dec_term)
     (dec_term_rec (ctx ++ [b]) body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk26c"><span class="nb">rewrite</span> IHbody.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join body) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx body)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec (ctx ++ [b]) body) =
join
  (map2 id (shift2 âˆ˜ map_snd dec_term)
     (dec_term_rec (ctx ++ [b]) body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk26d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t1) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t2) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec ctx (join (tap t1 t2)) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx (tap t1 t2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk26e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t1) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t2) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap (dec_term_rec ctx (join t1))
  (dec_term_rec ctx (join t2)) =
tap
  (join
     (map2 id (shift2 âˆ˜ map_snd dec_term)
        (dec_term_rec ctx t1)))
  (join
     (map2 id (shift2 âˆ˜ map_snd dec_term)
        (dec_term_rec ctx t2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk26f"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t1) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t2) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap
  ((join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
     (dec_term_rec ctx t1))
  (dec_term_rec ctx (join t2)) =
tap
  (join
     (map2 id (shift2 âˆ˜ map_snd dec_term)
        (dec_term_rec ctx t1)))
  (join
     (map2 id (shift2 âˆ˜ map_snd dec_term)
        (dec_term_rec ctx t2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk270"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term B (term B V)</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t1) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t1)</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">ctx</span> : list B,
dec_term_rec ctx (join t2) =
(join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
  (dec_term_rec ctx t2)</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tap
  ((join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
     (dec_term_rec ctx t1))
  ((join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term))
     (dec_term_rec ctx t2)) =
tap
  (join
     (map2 id (shift2 âˆ˜ map_snd dec_term)
        (dec_term_rec ctx t1)))
  (join
     (map2 id (shift2 âˆ˜ map_snd dec_term)
        (dec_term_rec ctx t2)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk271"><span class="kn">Lemma</span> <span class="nf">decorate_join_term</span>: <span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>),
    dec_term âˆ˜ join (T := term B) (A := V) =
      join (T := term (list B * B)) âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term)
        âˆ˜ dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
dec_term âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk272"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
dec_term âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk273"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term) âˆ˜ dec_term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk274"><span class="nb">unfold</span> dec_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dec_term_rec [] âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd (dec_term_rec []))
âˆ˜ dec_term_rec []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk275"><span class="nb">rewrite</span> decorate_rec_join_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">join âˆ˜ map2 id (shift2 âˆ˜ map_snd dec_term)
âˆ˜ dec_term_rec [] =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd (dec_term_rec []))
âˆ˜ dec_term_rec []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="distribute-and-join">
<h1>Distribute and Join</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* (t: term (G B) (term (G B) (G V))) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk276"><span class="kn">Lemma</span> <span class="nf">dist_join_term</span> {<span class="nv">B</span> <span class="nv">V</span>: <span class="kt">Type</span>}
  `{Applicative G}:
    dist2 (T := term) (G := G) âˆ˜ join (T := term (G B)) (A := (G V)) =
      map (F := G) join âˆ˜ dist2 (T := term) (G := G)
        âˆ˜ map2 (F := term) id (dist2 (T := term) (G := G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 âˆ˜ join = map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk277"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 âˆ˜ join = map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk278"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 âˆ˜ join = map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk279">ext t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term (G B) âˆ˜ term (G B)) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(dist2 âˆ˜ join) t =
(map join âˆ˜ dist2 âˆ˜ map2 id dist2) t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk27a"><span class="nb">unfold</span> compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>(term (G B) âˆ˜ term (G B)) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (join t) = map join (dist2 (map2 id dist2 t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk27b"><span class="nb">induction</span> t <span class="kr">as</span> [v | b body IHbody | t1 IHt1 t2 IHt2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (join (tvar v)) =
map join (dist2 (map2 id dist2 (tvar v)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="categorical-v-chk27c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk27c"><hr></label><div class="goal-conclusion">dist2 (join (lam b body)) =
map join (dist2 (map2 id dist2 (lam b body)))</div></blockquote><input class="alectryon-extra-goal-toggle" id="categorical-v-chk27d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><label class="goal-separator" for="categorical-v-chk27d"><hr></label><div class="goal-conclusion">dist2 (join (tap t1 t2)) =
map join (dist2 (map2 id dist2 (tap t1 t2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk27e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (join (tvar v)) =
map join (dist2 (map2 id dist2 (tvar v)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk27f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 v = map join (map tvar (dist2 v))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk280">compose near (dist2 v) on <span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 v = (map join âˆ˜ map tvar) (dist2 v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk281"><span class="nb">rewrite</span> fun_map_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 v = map (join âˆ˜ tvar) (dist2 v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk282"><span class="nb">change</span> (tvar (B := B) (V := term B V)) <span class="kr">with</span>
      (ret (T := term B) (A := term B V)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 v = map (join âˆ˜ ret) (dist2 v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk283" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk283"><span class="nb">setoid_rewrite</span> join_ret_term. <span class="c">(* not sure why setoid_ required here *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 v = map id (dist2 v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk284"><span class="nb">rewrite</span> fun_map_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>term (G B) (G V)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 v = id (dist2 v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk285">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (join (lam b body)) =
map join (dist2 (map2 id dist2 (lam b body)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk286"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt; dist2 (join body) =
map join
  (pure (lam (V:=term B V)) &lt;â‹†&gt; id b &lt;â‹†&gt;
   dist2 (map2 id dist2 body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk287"><span class="nb">rewrite</span> IHbody.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt;
map join (dist2 (map2 id dist2 body)) =
map join
  (pure (lam (V:=term B V)) &lt;â‹†&gt; id b &lt;â‹†&gt;
   dist2 (map2 id dist2 body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk288"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join) (pure (lam (V:=V)) &lt;â‹†&gt; b) &lt;â‹†&gt;
dist2 (map2 id dist2 body) =
map join
  (pure (lam (V:=term B V)) &lt;â‹†&gt; id b &lt;â‹†&gt;
   dist2 (map2 id dist2 body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk289"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (precompose join)) (pure (lam (V:=V))) &lt;â‹†&gt;
b &lt;â‹†&gt; dist2 (map2 id dist2 body) =
map join
  (pure (lam (V:=term B V)) &lt;â‹†&gt; id b &lt;â‹†&gt;
   dist2 (map2 id dist2 body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk28a"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 (map2 id dist2 body) =
map join
  (pure (lam (V:=term B V)) &lt;â‹†&gt; id b &lt;â‹†&gt;
   dist2 (map2 id dist2 body))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk28b"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 (map2 id dist2 body) =
map (compose join) (pure (lam (V:=term B V)) &lt;â‹†&gt; id b) &lt;â‹†&gt;
dist2 (map2 id dist2 body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk28c"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 (map2 id dist2 body) =
map (compose (compose join))
  (pure (lam (V:=term B V))) &lt;â‹†&gt; id b &lt;â‹†&gt;
dist2 (map2 id dist2 body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk28d"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G B</span></span></span><br><span><var>body</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHbody</var><span class="hyp-type"><b>: </b><span>dist2 (join body) =
map join (dist2 (map2 id dist2 body))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ lam (V:=V)) &lt;â‹†&gt; b &lt;â‹†&gt;
dist2 (map2 id dist2 body) =
pure (compose join âˆ˜ lam (V:=term B V)) &lt;â‹†&gt; id b &lt;â‹†&gt;
dist2 (map2 id dist2 body)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk28e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 (join (tap t1 t2)) =
map join (dist2 (map2 id dist2 (tap t1 t2)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk28f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt; dist2 (join t1) &lt;â‹†&gt;
dist2 (join t2) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk290"><span class="nb">rewrite</span> IHt1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (tap (V:=V)) &lt;â‹†&gt;
map join (dist2 (map2 id dist2 t1)) &lt;â‹†&gt;
dist2 (join t2) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk291"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join) (pure (tap (V:=V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (join t2) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk292"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join (tap (V:=V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (join t2) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk293"><span class="nb">rewrite</span> IHt2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join (tap (V:=V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt;
map join (dist2 (map2 id dist2 t2)) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk294"><span class="nb">rewrite</span> &lt;- ap_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (precompose join)
  (pure (precompose join (tap (V:=V))) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1)) &lt;â‹†&gt;
dist2 (map2 id dist2 t2) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk295"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (compose (precompose join))
  (pure (precompose join (tap (V:=V)))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (map2 id dist2 t2) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk296"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ precompose join (tap (V:=V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (map2 id dist2 t2) =
map join
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1) &lt;â‹†&gt;
   dist2 (map2 id dist2 t2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk297"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ precompose join (tap (V:=V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (map2 id dist2 t2) =
map (compose join)
  (pure (tap (V:=term B V)) &lt;â‹†&gt;
   dist2 (map2 id dist2 t1)) &lt;â‹†&gt;
dist2 (map2 id dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk298"><span class="nb">rewrite</span> map_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ precompose join (tap (V:=V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (map2 id dist2 t2) =
map (compose (compose join))
  (pure (tap (V:=term B V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (map2 id dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk299"><span class="nb">rewrite</span> app_pure_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br><span><var>t1, t2</var><span class="hyp-type"><b>: </b><span>term (G B) (term (G B) (G V))</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span>dist2 (join t1) =
map join (dist2 (map2 id dist2 t1))</span></span></span><br><span><var>IHt2</var><span class="hyp-type"><b>: </b><span>dist2 (join t2) =
map join (dist2 (map2 id dist2 t2))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure (precompose join âˆ˜ precompose join (tap (V:=V))) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (map2 id dist2 t2) =
pure (compose join âˆ˜ tap (V:=term B V)) &lt;â‹†&gt;
dist2 (map2 id dist2 t1) &lt;â‹†&gt; dist2 (map2 id dist2 t2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk29a">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedMonadPoly_term</span>:
  DecoratedMonadPoly term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonadPoly term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk29b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonadPoly term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk29c"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">B&#39;</span> <span class="nv">V</span> <span class="nv">V&#39;</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; B&#39;) (<span class="nv">f</span> : V -&gt; V&#39;),
map2 g f âˆ˜ ret = ret âˆ˜ f</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">B&#39;</span> <span class="nv">V</span> <span class="nv">V&#39;</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; B&#39;) (<span class="nv">f</span> : V -&gt; V&#39;),
map2 g f âˆ˜ join = join âˆ˜ map2 g (map2 g f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>, decp âˆ˜ ret = ret âˆ˜ ret</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
decp âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd decp) âˆ˜ decp</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk29d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">B&#39;</span> <span class="nv">V</span> <span class="nv">V&#39;</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; B&#39;) (<span class="nv">f</span> : V -&gt; V&#39;),
map2 g f âˆ˜ ret = ret âˆ˜ f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk29e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">B&#39;</span> <span class="nv">V</span> <span class="nv">V&#39;</span> : <span class="kt">Type</span>) (<span class="nv">g</span> : B -&gt; B&#39;) (<span class="nv">f</span> : V -&gt; V&#39;),
map2 g f âˆ˜ join = join âˆ˜ map2 g (map2 g f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk29f"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, B', V, V'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>V -&gt; V&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map2 g f âˆ˜ join = join âˆ˜ map2 g (map2 g f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> join_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>, decp âˆ˜ ret = ret âˆ˜ ret</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>,
decp âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd decp) âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a2"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decp âˆ˜ join =
join âˆ˜ map2 id (shift2 âˆ˜ map_snd decp) âˆ˜ decp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> decorate_join_term.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a3">#[export] <span class="kn">Instance</span> <span class="nf">DecoratedTraversableMonadPoly_term</span>:
  DecoratedTraversableMonadPoly term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableMonadPoly term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableMonadPoly term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a5"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctorPoly term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TraversableFunctor2 term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctorPoly term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonadPoly term</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt; dist2 âˆ˜ ret = map ret</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
dist2 âˆ˜ join = map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor2 term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctorPoly term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TraversableFunctor2 term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2a9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctorPoly term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2aa"><span class="nb">constructor</span>; <span class="kp">try</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">mapG</span> : Map G)
  (<span class="nv">pureG</span> : Pure G) (<span class="nv">multG</span> : Mult G),
ApplicativeCommutativeIdempotent G -&gt;
dist2 âˆ˜ map2 (dist Z G) dist2 âˆ˜ decp =
map decp âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2ab"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>mapG</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>pureG</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>multG</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ApplicativeCommutativeIdempotent G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 âˆ˜ map2 (dist Z G) dist2 âˆ˜ decp =
map decp âˆ˜ dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">rewrite</span> dist_dec_commute2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2ac">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedMonadPoly term</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2ad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt; dist2 âˆ˜ ret = map ret</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
dist2 âˆ˜ join = map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2af"><span class="nb">unfold</span> dist2_join.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">B</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">Map_G</span> : Map G)
  (<span class="nv">Pure_G</span> : Pure G) (<span class="nv">Mult_G</span> : Mult G),
Applicative G -&gt;
dist2 âˆ˜ join = map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b0"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dist2 âˆ˜ join = map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b1"><span class="nb">setoid_rewrite</span> dist_join_term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Map_G</var><span class="hyp-type"><b>: </b><span>Map G</span></span></span><br><span><var>Pure_G</var><span class="hyp-type"><b>: </b><span>Pure G</span></span></span><br><span><var>Mult_G</var><span class="hyp-type"><b>: </b><span>Mult G</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Applicative G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map join âˆ˜ dist2 âˆ˜ map2 id dist2 =
map join âˆ˜ dist2 âˆ˜ map2 id dist2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Tealeaves <span class="kn">Require</span>
  Classes.Categorical.DecoratedTraversableMonadPoly
  Classes.Categorical.TraversableFunctor
  Adapters.CategoricalToKleisli.Monad
  Adapters.CategoricalToKleisli.DecoratedFunctor
  Adapters.CategoricalToKleisli.TraversableFunctor
  Adapters.CategoricalToKleisli.DecoratedTraversableFunctor
  Adapters.PolyToMono.Categorical.DecoratedFunctor
  Adapters.PolyToMono.Categorical.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">CategoricalPDTMUsefulInstances</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span>
    Classes.Categorical.DecoratedTraversableMonadPoly.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span>
    Adapters.CategoricalToKleisli.DecoratedTraversableMonadPoly
    Adapters.CategoricalToKleisli.DecoratedTraversableMonadPoly.DerivedOperations
    Adapters.CategoricalToKleisli.DecoratedTraversableMonadPoly.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span>
    Adapters.CategoricalToKleisli.DecoratedTraversableFunctorPoly
    Adapters.CategoricalToKleisli.DecoratedTraversableFunctorPoly.DerivedOperations
    Adapters.CategoricalToKleisli.DecoratedTraversableFunctorPoly.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span>
    Adapters.CategoricalToKleisli.DecoratedFunctorPoly
    Adapters.CategoricalToKleisli.DecoratedFunctorPoly.DerivedOperations
    Adapters.CategoricalToKleisli.DecoratedFunctorPoly.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span>
    Adapters.CategoricalToKleisli.DecoratedTraversableMonad
    Adapters.CategoricalToKleisli.Monad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span>
    Adapters.PolyToMono.Categorical.DecoratedFunctor
    Adapters.PolyToMono.Categorical.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Adapters.CategoricalToKleisli.Monad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.Monad.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.Monad.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Adapters.CategoricalToKleisli.DecoratedFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.DecoratedFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.DecoratedFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Adapters.CategoricalToKleisli.TraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.TraversableFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.TraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Adapters.CategoricalToKleisli.DecoratedTraversableFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.DecoratedTraversableFunctor.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.DecoratedTraversableFunctor.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> Adapters.CategoricalToKleisli.DecoratedTraversableMonad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.DecoratedTraversableMonad.DerivedOperations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> CategoricalToKleisli.DecoratedTraversableMonad.DerivedInstances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> PolyToMono.Categorical.DecoratedFunctor.ToMono1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> PolyToMono.Categorical.TraversableFunctor.ToMono.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">B</span>: <span class="kt">Set</span>) (<span class="nv">V</span>: <span class="kt">Set</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b2"><span class="kn">Goal</span> Functor (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Functor (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b3"><span class="kn">Goal</span> Categorical.Monad.Monad (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monad (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b4"><span class="kn">Goal</span> Categorical.DecoratedFunctor.DecoratedFunctor (list B) (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctor.DecoratedFunctor (list B) (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b5"><span class="kn">Goal</span> Categorical.TraversableFunctor.TraversableFunctor (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TraversableFunctor (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b6" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b6"><span class="kn">Goal</span> Categorical.DecoratedTraversableFunctor.DecoratedTraversableFunctor (list B) (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor.DecoratedTraversableFunctor
  (list B) (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b7"><span class="kn">Fail</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Tactic failure: <span class="kn">Proof</span> search failed.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctor.DecoratedTraversableFunctor
  (list B) (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b8"><span class="kn">Goal</span> Kleisli.Monad.Monad (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Monad.Monad (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2b9"><span class="kn">Goal</span> Kleisli.DecoratedFunctor.DecoratedFunctor (list B) (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Kleisli.DecoratedFunctor.DecoratedFunctor (list B)
  (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2ba"><span class="kn">Goal</span> Kleisli.TraversableFunctor.TraversableFunctor (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Kleisli.TraversableFunctor.TraversableFunctor (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2bb"><span class="kn">Goal</span> Kleisli.DecoratedTraversableFunctor.DecoratedTraversableFunctor (list B) (term B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Kleisli.DecoratedTraversableFunctor.DecoratedTraversableFunctor
  (list B) (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2bc"><span class="kn">Fail</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Tactic failure: <span class="kn">Proof</span> search failed.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Kleisli.DecoratedTraversableFunctor.DecoratedTraversableFunctor
  (list B) (term B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2bd"><span class="kn">Goal</span> Kleisli.DecoratedFunctorPoly.DecoratedFunctorPoly term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedFunctorPoly.DecoratedFunctorPoly term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2be"><span class="kn">Goal</span> Kleisli.DecoratedTraversableMonadPoly.DecoratedTraversableMonadPoly term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableMonadPoly.DecoratedTraversableMonadPoly
  term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="categorical-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="categorical-v-chk2bf"><span class="kn">Goal</span> Kleisli.DecoratedTraversableFunctorPoly.DecoratedTraversableFunctorPoly term.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">DecoratedTraversableFunctorPoly.DecoratedTraversableFunctorPoly
  term</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CategoricalPDTMUsefulInstances</span>.</span></span></pre></div>
</div>
</div></body>
</html>
